<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Julien Pauli PHP&#039;s life</title>
    <subtitle></subtitle>
    <link href="http://jpauli.github.io//feed/index.atom" rel="self" />
    <link href="http://jpauli.github.io//" />
        <id>http://jpauli.github.io//</id>
            <updated>2014-07-21T00:00:00+00:00</updated>
            <entry>
        <title>Reference mismatch in PHP function calls</title>
                <id>http://jpauli.github.io//2014/06/27/references-mismatch.html</id>
                <updated>2014-06-27T00:00:00+00:00</updated>
        <author>
            <name>Julien Pauli</name>
            <email>jpauli@php.net</email>
        </author>
        <link rel="alternate" type="text/html" href="http://jpauli.github.io//2014/06/27/references-mismatch.html"/>
        <content type="html" xml:lang="en"><![CDATA[<h2 id="a-recall-on-references">A recall on references<a href="#a-recall-on-references" class="anchor">#</a></h2>

<p>Once again, a coworker just pinged me about a huge memory usage in a Symfony2 based project.
What is bad about Symfony2 ecosystem, is that people tend to use everyone else's code, because it
seems to fit the <strong>usage</strong> need. This is not bad as-is, but wait, what about the performance of the piece of code you're gonna
heavily use ? Nowadays we want fast things, treating much more data than 10 years ago. I think it's time for programmers
who ignore performance to start learning about it.</p>

<p>Tons of PHP programmers are very nice technical guys
at creating functionnal code, and what they call "nice code", you know, with tons of objects and interfaces everywhere...
Fine, right ! But when it comes to write critical parts of code, where performance
trully matter, here suddenly, noone stays on the scene.
This is simply because unfortunately, many people just ignore how PHP works, let me refresh your mind ;-)</p>

<p>So, usually the main problem comes about memory usage. When I hear "my code is eating a gigabyte of
memory" , I just wonder if it has been designed to solve a problem as huge as its memory impact, or what ?
Seriously...</p>

<p>Memory usage, in PHP code, is not really hard to understand. PHP uses a reference counting mechanism
to track variable usages, just like any other language, or even the Kernel itself to manage lists of ... many things.
Reference counting is a really really common basic computer programming trick to save memory.</p>

<p>PHP is very well designed (I'm serious). It tries to do its best to save memory while running your code.
But should you know how reference counting works, you should know there are some situations you should avoid.</p>

<p>I'm gonna talk about reference mimatch in PHP function calls here.</p>

<h2 id="what-to-do-or-not-to-do">What to do or not to do ?<a href="#what-to-do-or-not-to-do" class="anchor">#</a></h2>

<p>What you should do is not use references (&amp;) , until you really master what you do.</p>

<p>More seriously, you should absolutely avoid <strong>reference mismatch</strong> when calling functions.
This is absolutely awfull for PHP, as any mismatch will make it duplicate the variable's memory.
If the variable is big (a very long string, a very complex array), then you're gonna start feeling it.
Worse, you're gonna complain against PHP, which has nothing to do with that. The problem is you, and the
code you are using.</p>

<h2 id="what-is-a-reference-mismatch">What is a reference mismatch ?<a href="#what-is-a-reference-mismatch" class="anchor">#</a></h2>

<p>A reference mimatch is when you call a function whose argument is expected to be passed by reference, and
you pass it a non-reference, or the opposite case.</p>

<p>Here are few examples :</p>

<pre><code>function foo($arg) { }

$a = "some var";
$b = &amp;$a; /* turn $a and $b into references */

foo($a); /* Reference mismatch */
foo($b); /* idem */
</code></pre>

<p>!</p>

<pre><code>function foo(&amp;$arg) { } /* this function accepts an arg by reference */

$a = "some var";
$b = $a; /* increment $a refcount so that the content is bound to two different variables */

foo($a); /* reference mismatch */
foo($b); /* idem */
</code></pre>

<p>So those both examples are things you should avoid. PHP will duplicate the memory of the argument before
passing it to the function (this is true for every argument).</p>

<h2 id="what-about-the-objects">What about the objects ?<a href="#what-about-the-objects" class="anchor">#</a></h2>

<p>Objects are a special case. Let me be really clear : PHP never, ever, ever, duplicates an object in memory
until you explicitely tells it to do so. And you only have one way to tell it to do so : the <strong>clone</strong> keyword.</p>

<p>This is really easy to demonstrate :</p>

<pre><code>function wow($arg) { var_dump('in function wow : ', memory_get_usage()); }

$big = range(1, 1024*1024); /* This consumes lots of memory */
$big2 = &amp;$big; /* $big and $big2 are both references to the same memory slot */

var_dump('original memory', memory_get_usage());
wow($big); /* $big is a reference, but the function accepts a non-reference : mismatch : duplicate memory */
var_dump('final memory', memory_get_usage());
</code></pre>

<p>Result :</p>

<pre><code>string(15) "original memory"
int(151223288)
string(18) "in function wow : "
int(251886800)
string(12) "final memory"
int(151224488)
</code></pre>

<p>Here, there is a classical reference mismatch on a non-object, so PHP will duplicate the passed argument,
which is a big array, so memory usage will raise significantely because PHP will duplicate (shallow copy) a very huge array
(and this burns many CPU cycles as well). Sure, if you don't use the variable elsewhere, when the function call
is finished, PHP destroys the function stack and cleans the dup memory. This, I repeat, if you don't use the argument
elsewhere. This is just a <a href="http://en.wikipedia.org/wiki/Reference_counting">refcount strategy</a></p>

<p>What about now using an object as passed arg ?</p>

<pre><code>function wow($arg) { var_dump('in function wow : ', memory_get_usage()); }

$big = range(1, 1024*1024); /* This consumes lots of memory */
$obj = new StdClass; /* Create a basic object */
$obj-&gt;big = $big; /* Turn this object into a BIG object by affecting one of its property to a huge var */
$obj2 = &amp;$obj; /* Turn $obj into a reference, by linking it by reference to another variable */

var_dump('original memory', memory_get_usage());
wow($obj);
var_dump('final memory', memory_get_usage());
</code></pre>

<p>Result:</p>

<pre><code>string(15) "original memory"
int(151223928)
string(18) "in function wow : "
int(151224040)
string(15) "final memory"
int(151223992)
</code></pre>

<p>This is a confirmation : PHP doesn't duplicate objects, because objects are internally reference counted themselves.
Here, PHP just adds one more reference to the object, something that can't be done for other types.
So yes : usually, using objects in PHP tend to decrease global memory usage, because if you were using references at some
places, for objects, PHP won't duplicate memory container.</p>

<p>This can easilly be spoted into PHP source code. Have a look at <a href="http://lxr.php.net/xref/PHP_5_5/Zend/zend_variables.c#106">zval_copy_ctor()</a>
,the function called when PHP duplicate a variable. We can see that in the special case of an object,
PHP just increments a counter, whereas for any other types, it really duplicates memory of the variable, which usually is
not a bad thing as you don't use very big memory variables everytime, but cases happen where you'll carry a big array (with
lots of slots) or a huge string (a result of a file_get_contents() for example).</p>

<p>If you were curious about the duplication of arguments when a function is called, you should have a look at the
<a href="http://lxr.php.net/xref/PHP_5_5/Zend/zend_vm_def.h#3182">ZEND_SEND_VAR</a> and <a href="http://lxr.php.net/xref/PHP_5_5/Zend/zend_vm_def.h#3145">ZEND_SEND_REF</a> opcodes</p>

<h2 id="other-use-cases">Other use cases<a href="#other-use-cases" class="anchor">#</a></h2>

<p>Any mismatch in function calls is bad. This is true also for internal functions, and some of them accept
parameters by references, like <strong>array_shift()</strong> for example.
When you use such functions, make sure to respect the references as well.</p>

<p>But there are other tricks, which I consider not tricks, but just normal and logical behaviors.
The case of func_get_args() is interesting :</p>

<pre><code>function foo()
{
    var_dump('Before func_get_args()', memory_get_usage());
    $args = func_get_args();
    var_dump('After func_get_args()', memory_get_usage());
}

/*
An example output with some big input variables could be :

string(22) "Before func_get_args()"
int(151222120)
string(21) "After func_get_args()"
int(251885904)
*/
</code></pre>

<p>What you should know is that func_get_args() will duplicate all the passed variables to the function, ignoring references or not.
It has to do so, because PHP has no way to know if you're gonna modify the variables later-on.
You all agree that modifying a variable in $args here should not modify the passed arg right ?
Example:</p>

<pre><code>function foo()
{
    $args = func_get_args();
    $args[0] = 'foo';
}

$str = 'bar';
foo($str);

// here, $str still owns the string 'bar', and not 'foo'
</code></pre>

<p>So PHP has to duplicate every variable passed on the function stack, when you call func_get_args().</p>

<h2 id="end">End<a href="#end" class="anchor">#</a></h2>

<p>Well, as I said, usually you don't carry over huge variables in PHP scripts. This is a pretty uncommon use case, however,
as time pass and we ask PHP to build more and more complex systems, managing more and more data; knowing what happens
behind the scene becomes more and more valuable.
Scripting languages show advantages and drawbacks, and one should really master them all before choosing the right language.
For example, I will not make PHP the first choice when talking about designing a language grammar parser.</p>]]></content>
    </entry>
        <entry>
        <title>realpath_cache</title>
                <id>http://jpauli.github.io//2014/06/30/realpath-cache.html</id>
                <updated>2014-06-30T00:00:00+00:00</updated>
        <author>
            <name>Julien Pauli</name>
            <email>jpauli@php.net</email>
        </author>
        <link rel="alternate" type="text/html" href="http://jpauli.github.io//2014/06/30/realpath-cache.html"/>
        <content type="html" xml:lang="en"><![CDATA[<h2 id="introduction">Introduction<a href="#introduction" class="anchor">#</a></h2>

<p>Do you know those PHP functions, realpath_cache_get(), realpath_cache_size() ?
php.ini setting <em>realpath_cache</em> ?</p>

<p>Realpath cache is a really important concept to know about, especially when it comes to play with symbolic links, a situation
some meet when they deploy code.
This setting is about performance and IO reduction of your server. It has been introducted in PHP 5.1 , when frameworks started
to show in the PHP scene.</p>

<h3 id="a-recall-on-the-stat-system-call">A recall on the stat system call<a href="#a-recall-on-the-stat-system-call" class="anchor">#</a></h3>

<p>Ok, so, you know how your system works don't you ? Let me refresh your mind.
When one want to play with a <em>path</em>, the Kernel and the filesystem must know exactly what you talk about.
So, whenever you'll use a path to access a file (in the Unix meaning), you or your library or at least your Kernel will
have to resolve it.
Resolving a path is getting information about it : basically is it a file ? is it a directory or is it link ?</p>

<p>The way to do this is by asking the system about the file type, and, in case of a symbolic link, the final file target.
Whenever you use relative paths, such as <em>"../hey/./you/../foobar"</em>, you have to resolve them to full paths, and then resolve
those full paths to file entities (Unix sense of "file", so a true file of any type or a directory or a link).</p>

<p>Usually, for relative paths, you're gonna call the <a href="http://repo.or.cz/w/glibc.git/blob/edea402804bce917cfd7cd1af76212e6364c23db:/stdlib/canonicalize.c#l43">realpath() C function</a>. As you can see, <a href="http://repo.or.cz/w/glibc.git/blob/edea402804bce917cfd7cd1af76212e6364c23db:/stdlib/canonicalize.c#l161">it will lead to</a> a stat() system call.</p>

<p>Calling stat() is heavy, first because this is a system call, needing a Kernel trap and a context switch, and also because it most likely asks the disk about metadata.
The kernel source for stat() is at <a href="http://lxr.free-electrons.com/source/fs/stat.c#L190">http://lxr.free-electrons.com/source/fs/stat.c#L190</a>. Not surprinsingly, it leads to a FileSystem call (inode-&gt;getattr()).
Usually, the kernel uses <a href="http://www.faqs.org/docs/linux_admin/buffer-cache.html">its buffer caches</a>, so the impact is really 
tiny, but the buffer cache on a very busy server may not contain your information, thus an IO, which is something you'd prefer
preventing as much as possible.</p>

<h2 id="what-php-does">What PHP does ?<a href="#what-php-does" class="anchor">#</a></h2>

<p>In PHP projects, we use many files. Nowadays, we use tons of classes, meaning tons of files (assuming one class per file).
So, autoload or not, we'll have to include those files, we'll have to read them, we'll have to ask the Kernel for stat informations about them.
That's why whenever you access a file in PHP, PHP tries to resolve the paths, resolve the links, get file informations; all this using the stat() system call, and then caches the result from this call into what is called the <strong>realpath cache</strong>.
Many other softwares use a stat cache, read their source code and you'll notice that ;-)</p>

<p>PHP will cache the result of the call, but only about the realpath. Any other information (owner, access rights, times ...) won't be
cached in this cache, but in the last file access cache.</p>

<p>As usual, we find the solution by having a look at the source code.
Whenever you access a file in PHP, <a href="http://lxr.php.net/xref/PHP_5_5/main/fopen_wrappers.c#473">php_resolve_path()</a> is used.
This function quickly calls <a href="http://lxr.php.net/xref/PHP_5_5/TSRM/tsrm_virtual_cwd.c#1925">tsrm_reapath()</a> which itself
calls <a href="http://lxr.php.net/xref/PHP_5_5/TSRM/tsrm_virtual_cwd.c#1151">virtual_file_ex()</a> and finally, <a href="http://lxr.php.net/xref/PHP_5_5/TSRM/tsrm_virtual_cwd.c#750">tsrm_realpath_r()</a>.</p>

<p>That's where things get interested. Functions like <a href="http://lxr.php.net/xref/PHP_5_5/TSRM/tsrm_virtual_cwd.c#830">realpath_cache_find()</a> are called, to lookup in a table if the stat informations have already been asked and cached for this
specific path.</p>

<p>A <a href="http://lxr.php.net/xref/PHP_5_5/TSRM/tsrm_virtual_cwd.h#211">realpath_cache_bucket</a> structure is used, which encapsulates many things :</p>

<pre><code>typedef struct _realpath_cache_bucket {
    unsigned long                  key;
    char                          *path;
    int                            path_len;
    char                          *realpath;
    int                            realpath_len;
    int                            is_dir;
    time_t                         expires;
#ifdef PHP_WIN32
    unsigned char                  is_rvalid;
    unsigned char                  is_readable;
    unsigned char                  is_wvalid;
    unsigned char                  is_writable;
#endif
    struct _realpath_cache_bucket *next;
} realpath_cache_bucket;
</code></pre>

<p>If the bucket is not found, <a href="http://lxr.php.net/xref/PHP_5_5/TSRM/tsrm_virtual_cwd.h#139">php_sys_lstat()</a> will be called, this function is a proxy to lstat(). Then finally, the bucket is <a href="http://lxr.php.net/xref/PHP_5_5/TSRM/tsrm_virtual_cwd.c#1139">saved into the realpath cache</a>.</p>

<h2 id="php-settings-and-customization">PHP Settings and customization<a href="#php-settings-and-customization" class="anchor">#</a></h2>

<p>So, in PHP, you have several things to know about realpath cache.
First, the INI settings :</p>

<ul><li><a href="http://www.php.net/manual/en/ini.core.php#ini.realpath-cache-size">realpath_cache_size</a></li>
<li><a href="http://www.php.net/manual/en/ini.core.php#ini.realpath-cache-ttl">realpath_cache_ttl</a></li>
</ul><p>The manual warns you, if you use files that are not modified often (production servers), you should increase the
TTL.
Also, the default size is ridiculously weak. 16K are gonna be filled in one web request, assuming a framework usage like Symfony2.
Monitor your realpath_cache_get() return, you'll see that you hit the default 16K limit very soon. You'd better increase this value to something like 512K or even a megabyte.
If your realpath cache is full, there is no space for other entries, and then PHP will start abusing the stat() call because of cache
misses, stressing your Kernel even more.
The size is hard to compute theoretically. As we can see from the source code <a href="http://lxr.php.net/xref/PHP_5_5/TSRM/tsrm_virtual_cwd.c#643">in here</a>, each entry consume sizeof(realpath_cache_bucket) + the total number of characters of the resolved path + 1.
To me (LP64), sizeof(realpath_cache_bucket) = 56 bytes.</p>

<p>There is another trick. PHP resolves <strong>every paths it meets</strong> and splits every path part, resolving it.
I explain : if you access the file "/home/julien/www/fooproject/app/web/entry.php", PHP is gonna split this path into as many single units
as can fit. PHP is gonna resolve "/home", creating an entry for it into the cache. Then "/home/julien", then "/home/julien/www", etc..
Why this ? Well, first this is used to check access at every level of directory. Secondly, because many PHP users tend to build their
pathnames using string concatenations, PHP may have a chance to have checked simple parts, it will then know if the user may access
it or not, by asking the realpath cache for details. A cache hit is very cheap.
The source code of <a href="http://lxr.php.net/xref/PHP_5_5/TSRM/tsrm_virtual_cwd.c#750">tsrm_realpath_r()</a> details the procedure. this is a recursive function which gets called for every subpath entry, by default.</p>

<p>As you can see from the preceding paragraph, better have a cache !</p>

<p>This also shows that priming the cache by hitting few URLs from your website before opening it to public just after a new deploy is important here as well. This will not only prime your OPcode cache, but also the realpath cache, and your Kernel's page cache as well.</p>

<p>How to clear this cache ? The function is hidden in PHP. realpath_cache_clear() ? No, it doesn't exist, too bad :-)
Welcome <em>clearstatcache(true)</em>.
The true parameter is very important, it is called $clear_realpath_cache, so yes, obviously this is what we want to do.</p>

<h2 id="an-example">An example<a href="#an-example" class="anchor">#</a></h2>

<p>So here is an example.</p>

<pre><code>&lt;?php
$f = @file_get_contents('/tmp/bar.php');

echo "hello";

var_dump(realpath_cache_get());
</code></pre>

<p>And here is the result :</p>

<pre><code>hello
array(5) {
  ["/home/julien.pauli/www/realpath_example.php"]=&gt;
  array(4) {
    ["key"]=&gt;
    float(1.7251638834424E+19)
    ["is_dir"]=&gt;
    bool(false)
    ["realpath"]=&gt;
    string(43) "/home/julien.pauli/www/realpath_example.php"
    ["expires"]=&gt;
    int(1404137986)
  }
  ["/home"]=&gt;
  array(4) {
    ["key"]=&gt;
    int(4353355791257440477)
    ["is_dir"]=&gt;
    bool(true)
    ["realpath"]=&gt;
    string(5) "/home"
    ["expires"]=&gt;
    int(1404137986)
  }
  ["/home/julien.pauli"]=&gt;
  array(4) {
    ["key"]=&gt;
    int(159282770203332178)
    ["is_dir"]=&gt;
    bool(true)
    ["realpath"]=&gt;
    string(18) "/home/julien.pauli"
    ["expires"]=&gt;
    int(1404137986)
  }
  ["/tmp"]=&gt;
  array(4) {
    ["key"]=&gt;
    float(1.6709564980243E+19)
    ["is_dir"]=&gt;
    bool(true)
    ["realpath"]=&gt;
    string(4) "/tmp"
    ["expires"]=&gt;
    int(1404137986)
  }
  ["/home/julien.pauli/www"]=&gt;
  array(4) {
    ["key"]=&gt;
    int(5178407966190555102)
    ["is_dir"]=&gt;
    bool(true)
    ["realpath"]=&gt;
    string(22) "/home/julien.pauli/www"
    ["expires"]=&gt;
    int(1404137986)
</code></pre>

<p>What we can see, is that the full path to my example PHP file has been resolved, parts by parts.
Then, as <em>/tmp/bar.php</em> doesn't exist on my disk, this entry is obviously missing from the cache. However, we can see that PHP
resolved <em>/tmp</em>, so it now knows that it can access to /tmp, and any further resolution behind <em>/tmp</em> will be cheaper than the first one.</p>

<p>In the array returned by realpath_cache_get(), you can see important information, such as the expires timestamp.
This has been computed related to the realpath_cache_ttl setting, and the time the file has been accessed.
The key field is a hash of the resolved path, a variant of <a href="http://www.isthe.com/chongo/tech/comp/fnv/index.html">FNV hash</a> is used, this
is an internal information you shouldn't really need though (which may be integer or float, depending on your integer max size).</p>

<p>Now, if you'd call clearstatcache(true), you'd reset this array and force PHP to stat() any new file access that was previously cached.</p>

<h2 id="the-opcode-caches-case">The OPcode caches case<a href="#the-opcode-caches-case" class="anchor">#</a></h2>

<p>Ready for another trick ?</p>

<p><strong>The realpath cache is process bound, and not shared into shared memory</strong></p>

<p>This means that anytime a cache entry expires, changes, or you empty the cache manually, you have to do this <strong>for every process in your pool</strong>.
This is usually why people fail at deploying code using OPCode caches solutions.
What people usually do when deploying, is changing a symlink from say /www/deploy-a to /www/deploy-b. What they usually forget is that opcode cache solutions (at least OPCache and APC) rely on the internal realpath cache from PHP.
So those opcode cache solutions won't notice the link change, and worse, they're gonna start noticing it little by little, as the realpath cache of every entry slowly expires. You know the result.</p>

<p>What I find beeing the best solution for deployment to prevent this uncool mechanism to happen, is to prepare a totally new PHP worker pool, and load balance your FastCgi Handler onto it, giving up with the old one when all old workers have finished.</p>

<p>This solution has many advantages : deploy A runs on memory pool A, and deploy B runs on memory pool B. End of story. We use memory image isolation to be absolutely sure that nothing will be shared between two deploys. Realpath cache, OPCode cache, etc... Everything is new.
FastCGI pools load balancing is possible at least with Lighttpd and Nginx :-)
I experienced this solution on production, and it is rock solid !</p>

<h1 id="end">End<a href="#end" class="anchor">#</a></h1>

<p>I've been asked to write some lines about realpath cache, probably because people had bad experience about it (I think at code deployment). Well, now you know how it works, why it's here and how and why to customize it. Did I forget anything ?</p>]]></content>
    </entry>
        <entry>
        <title>PHP memory and Zend Memory Manager</title>
                <id>http://jpauli.github.io//2014/07/02/php-memory.html</id>
                <updated>2014-07-02T00:00:00+00:00</updated>
        <author>
            <name>Julien Pauli</name>
            <email>jpauli@php.net</email>
        </author>
        <link rel="alternate" type="text/html" href="http://jpauli.github.io//2014/07/02/php-memory.html"/>
        <content type="html" xml:lang="en"><![CDATA[<h2 id="introduction">Introduction<a href="#introduction" class="anchor">#</a></h2>

<p>This blog post is gonna introduce you the dynamic memory management layer PHP relies on : Zend Memory Manager (ZendMM). We'll detail why we need such a layer, what it does, how to customize it, how to interact with it from PHP land.</p>

<h2 id="recall-on-c-memory-management">Recall on C memory management<a href="#recall-on-c-memory-management" class="anchor">#</a></h2>

<p>C has several allocation storage classes :</p>

<ul><li>automatic allocation ;</li>
<li>static allocation ;</li>
<li>dynamic allocation.</li>
</ul><p>Auto allocation is about function received arguments, or any variable declared into a function body. The compiler has all informations it needs to figure out how many bytes to allocate, and it will automatically free the memory by itself, when the container becomes out of scope. You cannot get your hands on such automatic feature, especially you can't reallocate this memory zone (because you'd need more memory that the compiler computed for you, or less).</p>

<p>Static allocation is about global or static variables. Like with automatic allocation, the compiler allocates memory depending on variable type, but this time it will never free it until the program ends. Here again, you cannot get into that process to customize it.</p>

<p>Finally dynamic allocation is where the programmer (you) will declare himself how much bytes of memory he needs. You can reallocate the memory, meaning you can enlarge it, or shrink it, whenever you want. This is necessary as many things in a program lifetime are not known at compile time, and evolve within the program lifetime. So you can do whatever you want with dynamic allocation, but there is a duty you have to accept : free the memory zone whenever you don't need it anymore, because absolutely noone will do it for you. If you forget, you create what's called a <em>memory leak</em>, that means you allocated some memory for your program, but you never released it back to the OS so that it may use it for any other program which may need it. That's bad.</p>

<p><img src="../../../img/php-memory/os-memory.png" alt="OS memory"></p>

<p>Here is an example :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* Static allocation, global variable
   the compiler takes care of everything, but won't free
   this bloc of memory */
int myint;

char *myfonction(int i)
{
    /* Static allocation, static variable
   the compiler takes care of everything, but won't free
   this bloc of memory */
    static char *my_static = "Foo";

    if (myint == i) {
        my_static = "Bar";
    }
    return my_static;
}

int main(int argc, char *argv[])
{
    /* Automatic allocation, the compiler takes care of allocation
    and will free this memory bloc when the function will end */
    int *p_int;
    int i;

    myint = 18;

    /* Dynamic allocation. The programmer asks himself to allocate
       10*sizeof(int) bytes in memory, he will have to free it by himself */
    p_int = (int *)malloc(10 * sizeof(int));

    for (i=0; i&lt;10; i++) {
        *(p_int + i) = i*myint;
        myfunction(*p_int);
    }

    /* Free of dynamic memory bloc. Forgetting this stage creates a real
      memory leak */
    free(p_int);

    return 0;
}
</code></pre>

<blockquote>
  <p>We stop here. Just note that depending on the allocation class, the memory area will differ.
  An automatic allocation is done on the stack, a dymanic allocation on the heap and a static is done in the BSS or Data segment of your ELF binary.</p>
</blockquote>

<p>Dynamic allocation is really frequently used. PHP uses it as well. It is available through libc's malloc() and free() functions.
As PHP is a long-living process, often a daemon (FastCGI or into Apache using mod_php), any leak will hurt not only PHP, but the whole machine.
As PHP is designed into hundreds of thousands of lines of C code, generating a leak is really really easy. There must be a solution to prevent leaks, and PHP's got a layer that is dedicated in
dynamic memory management and leak tracking : Zend Memory Manager (ZendMM).</p>

<h2 id="dynamic-memory-allocation-problems-regarding-php">Dynamic memory allocation problems regarding PHP<a href="#dynamic-memory-allocation-problems-regarding-php" class="anchor">#</a></h2>

<h3 id="os-differences">OS differences<a href="#os-differences" class="anchor">#</a></h3>

<p>Libc's is a wrapper over the Kernel services, and the Kernel is really different according to OS. Windows and Linux for example, are really different. Unix flavours as well.</p>

<p><img src="../../../img/php-memory/zendMM.png" alt="ZendMM"></p>

<h3 id="heap-fragmentation">Heap fragmentation<a href="#heap-fragmentation" class="anchor">#</a></h3>

<p>To understand heap fragmentation, you should write your own memory manager in C. This is an exercize you usually have to deal with in your studies.
malloc() manages a heap that it cuts into blocs. When you free a bloc, you create a hole in the heap. As any bloc in the heap is managed into binary trees or linked lists, the more holes you
create, the more CPU cycles will be needed for the next malloc() call to succeed. It also happens that a call to free() triggers a heap compacting algorithm, which is usually very CPU intensive as well.
Those are well known problems, and any "serious" software have dealed with them by creating a (usually very complex and big) layer over malloc/free couple, and the program asks for dynamic memory
using this specific layer.</p>

<blockquote>
  <p>As an example, you may read the <a href="http://apr.apache.org/docs/apr/0.9/group__apr__pools.html">Apache server's dynamic memory library</a>. Big projects such as Firefox or MySQL have even more complex and exciting layers.</p>
</blockquote>

<p>Zend Memory Manager is PHP's dynamic allocation layer. It's been designed to offer good performances to PHP, by managing an internal heap over the process heap.
For more information about malloc/free internals, you may start your readings by <a href="http://phrack.org/issues/57/9.html">Once uppon a free()</a> or <a href="http://www.gnu.org/software/libc/manual/html_node/Unconstrained-Allocation.html">the Glibc manual</a></p>

<h3 id="managing-memory-leaks">Managing memory leaks<a href="#managing-memory-leaks" class="anchor">#</a></h3>

<p>Ah... memory leaks... a whole story every programmer knows about. Fortunately, there exists tools to track them, and they work pretty nicely. valgrind, mtrace, ccmalloc, electric fence...
Let's see how valgrind does the job :</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define MYSTRING "Hello, world ; I'm gonna leak some memory"

int main(int argc, char *argv[])
{
    char *p_char = (char *)malloc(sizeof(MYSTRING));
    char string[] = MYSTRING;
    memcpy(p_char, string, sizeof(string));
    return 0;
}

$ valgrind --tool=memcheck --leak-check=full ./leak
==9488== Memcheck, a memory error detector
==9488== Copyright (C) 2002-2010, and GNU GPL'd, by Julian Seward et al.
==9488== Using Valgrind-3.6.0.SVN-Debian and LibVEX; rerun with -h for copyright info
==9488== Command: ./leak
==9488== 
==9488== 
==9488== HEAP SUMMARY:
==9488==     in use at exit: 42 bytes in 1 blocks
==9488==   total heap usage: 1 allocs, 0 frees, 42 bytes allocated
==9488== 
==9488== 42 bytes in 1 blocks are definitely lost in loss record 1 of 1
==9488==    at 0x4C2815C: malloc (vg_replace_malloc.c:236)
==9488==    by 0x4005DB: main (leak.c:8)
==9488== 
==9488== LEAK SUMMARY:
==9488==    definitely lost: 42 bytes in 1 blocks
==9488==    indirectly lost: 0 bytes in 0 blocks
==9488==      possibly lost: 0 bytes in 0 blocks
==9488==    still reachable: 0 bytes in 0 blocks
==9488==         suppressed: 0 bytes in 0 blocks
==9488== 
==9488== For counts of detected and suppressed errors, rerun with: -v
==9488== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 4 from 4)
</code></pre>

<p>Valgrind is a very powerful tool. It tracks leaks, but also invalid accesses, which may be dangerous about program security (nul pointer dereference, write out of alloc'ed bounds, memory leaks, overlaping zones, etc...).</p>

<p>Whatever tool you use, the tool helps you track the problem but won't make it disappear magically. This is your work guy.
As the program gets bigger, it becomes more and more difficult to track the leaks. A solution is to rely on a layer that embeds some checks about leaks or security. Zend Memory Manger does that for PHP, and trully helps a lot designing extensions or patching PHP itself.</p>

<p>Here is a quick example of ZendMM usage :</p>

<pre><code>PHP_FUNCTION(make_leak)
{
    void *leak = emalloc(200); /* emalloc is ZendMM's "malloc" */
    RETURN_NULL(); /* return, forgeting to free the previously allocated buffer */
}

$&gt; php /tmp/leak_check.php

[Thu Apr  7 17:48:07 2011]  Script:  '/tmp/leak_check.php'
/usr/local/src/php/ext/leak/leak.c(172) :  Freeing 0x01DBB2E0 (200 bytes), script=/tmp/leak_check.php
=== Total 1 memory leaks detected ===
</code></pre>

<p>You can easilly see the stderr output : it tells you're leaking some memory, and it tells you in which place in your code (in the example : leak.c line 172).
What you have to do is to use ZendMM specific alloc functions in place of the default libc's ones. Easy to do. ZendMM will then track any allocation you ask for, and checks that you effectively free them.
It will also implement guards (known as <em>canaries</em>) to inform you if you write past the allocated blocks, which is a very nice feature to count on as well because forgetting a +1 or -1 in an allocation is really frequent, particularly in PHP.</p>

<blockquote>
  <p>Reminder : ZendMM only complains about leaks and overlaps if PHP's been built in debug mode (--enable-debug), so this is not the case for any "traditionnal" PHP build.</p>
</blockquote>

<h2 id="introduction-to-zend-memory-manager">Introduction to Zend Memory Manager<a href="#introduction-to-zend-memory-manager" class="anchor">#</a></h2>

<h3 id="goals">Goals<a href="#goals" class="anchor">#</a></h3>

<ul><li>Prevent heap fragmentation by reimplementing a custom heap onto the process' heap. Segmentation, pools and alignment features are in ;</li>
<li>scream at your face about memory leaks or overlaps, very usefull when designing PHP extensions ;</li>
<li>Automatically free leaked memory at request shutdown ;</li>
<li>Monitor and limit memory usage into all PHP (memory_limit) ;</li>
<li>Allow to choose the low level allocation stack (depends on OS) ;</li>
<li>Allow beeing disabled, so that any memory check tool like valgrind is not hindered by ZendMM.</li>
</ul><p>Zend Memory Manager appeared in PHP4 and has been fully redesigned in PHP5.2.</p>

<h3 id="configuration">Configuration<a href="#configuration" class="anchor">#</a></h3>

<p>Zend Memory Manager (ZendMM) is enabled by default, and can be disabled (it will still be here, but skirted). It will however change its behavior depending on your compilation options.
A debug PHP build will have a ZendMM telling you about leaks on stderr, if report_memleaks=1 in php.ini.</p>

<p><img src="../../../img/php-memory/zendMM-phpinfo.png" alt="ZendMM-phpinfo"></p>

<p>Then comes four env variables to set up ZendMM at runtime : USE_ZEND_ALLOC, ZEND_MM_MEM_TYPE, ZEND_MM_SEG_SIZE and ZEND_MM_COMPACT.
If USE_ZEND_ALLOC is set to 0, ZendMM is diabled and any call to its functions will be proxied to the OS's low level call, usually malloc/free. phpinfo() will then tell you Zend Memory Manager is disabled.</p>

<p>ZEND_MM_MEM_TYPE defines the low level implementation ZendMM should rely on. Default is "malloc", but you can choose between "mmap_anon" - "mmap_zero" - or "win32".</p>

<p>ZEND_MM_SEG_SIZE defines the allocation step. Its like Kernel's PAGESIZE, the minimum allocation unit to use. Default is 256Kb which is a good value. More on that later.</p>

<pre><code>$ USE_ZEND_ALLOC=0 valgrind --tool=memcheck php /tmp/small.php 
==6861== Memcheck, a memory error detector
==6861== Copyright (C) 2002-2010, and GNU GPL'd, by Julian Seward et al.
==6861== Using Valgrind-3.6.0.SVN-Debian and LibVEX; rerun with -h for copyright info
==6861== Command: ./php /tmp/small.php
==6861== 

==6861== HEAP SUMMARY:
==6861==     in use at exit: 0 bytes in 0 blocks
==6861==   total heap usage: 9,697 allocs, 9,697 frees, 2,686,147 bytes allocated
==6861== 
==6861== All heap blocks were freed -- no leaks are possible
==6861== 
==6861== For counts of detected and suppressed errors, rerun with: -v
==6861== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 4 from 4)

$ valgrind --tool=memcheck ./php /tmp/small.php
==6866== Memcheck, a memory error detector
==6866== Copyright (C) 2002-2010, and GNU GPL'd, by Julian Seward et al.
==6866== Using Valgrind-3.6.0.SVN-Debian and LibVEX; rerun with -h for copyright info
==6866== Command: ./php /tmp/small.php
==6866== 

==6866== HEAP SUMMARY:
==6866==     in use at exit: 0 bytes in 0 blocks
==6866==   total heap usage: 7,854 allocs, 7,854 frees, 2,547,726 bytes allocated
==6866== 
==6866== All heap blocks were freed -- no leaks are possible
==6866== 
==6866== For counts of detected and suppressed errors, rerun with: -v
==6866== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 4 from 4)
</code></pre>

<blockquote>
  <p>Reminder : PHP memory consumption depends on the run script, and also on PHP extensions which can allocate many memory.</p>
  
  <p>Note : PHP memory consumption is weaker when ZendMM is enabled, and you don't see it but can benchmark it : PHP is faster when ZendMM is enabled. This is obvious, as ZendMM has been designed to fit PHP's memory needs : it preallocates known-size blocs and manages internal lists about them more efficiently than malloc would do. It also prevents many malloc() calls, as the valgrind print above shows.</p>
</blockquote>

<pre><code>$&gt; ZEND_MM_SEG_SIZE=8k php /tmp/my_script.php
</code></pre>

<p>Here, ZendMM will ask the underneath layer for 8Kb allocs.</p>

<p>ZEND_MM_MEM_TYPE lets you choose the underneath layer to use. Libc's malloc() is used by default.</p>

<p>ZEND_MM_COMPACT tells ZendMM the size from which it must compact the internal heap. This feature is not enabled under Unix OSes.</p>

<h2 id="how-does-zendmm-work">How does ZendMM work ?<a href="#how-does-zendmm-work" class="anchor">#</a></h2>

<p>ZendMM is an allocator, so its operation is close to any memory allocator. Here are its structures :</p>

<ul><li>zend_mm_heap : the heap ;</li>
<li>zend_mm_mem_handlers : the bottom allocators available handlers (malloc, mmap_anon, win32...) ;</li>
<li>zend_mm_segment : memory segments. Linked list ;</li>
<li>zend_mm_block / zend_mm_free_block : memory blocs (usefull blocs), pluggued into segments.</li>
</ul><p>I wont detail too much ZendMM as it may become very complex if you are not comfortable with memory allocators, and such details are useless here.</p>

<h3 id="noticeable-structures">Noticeable structures<a href="#noticeable-structures" class="anchor">#</a></h3>

<p>zend_mm_mem_handlers is the low-level allocator to be used by ZendMM, it is then full of function pointers. malloc-based allocator is defined into the ZEND_MM_MEM_MALLOC_DSC macro.</p>

<pre><code>typedef struct _zend_mm_mem_handlers {
    const char *name;
    zend_mm_storage* (*init)(void *params);
    void (*dtor)(zend_mm_storage *storage);
    void (*compact)(zend_mm_storage *storage);
    zend_mm_segment* (*_alloc)(zend_mm_storage *storage, size_t size);
    zend_mm_segment* (*_realloc)(zend_mm_storage *storage, zend_mm_segment *ptr, size_t size);
    void (*_free)(zend_mm_storage *storage, zend_mm_segment *ptr);
} zend_mm_mem_handlers;

#define ZEND_MM_MEM_MALLOC_DSC {"malloc", zend_mm_mem_dummy_init, zend_mm_mem_dummy_dtor, zend_mm_mem_dummy_compact, zend_mm_mem_malloc_alloc,
zend_mm_mem_malloc_realloc, zend_mm_mem_malloc_free}
</code></pre>

<p>zend_mm_segment is a memory segment (the base unit ZendMM will use when allocating from the OS). It's size may be changed using the ZEND_MM_SEG_SIZE env. The allocator will use this size to allocate a buffer, place a zend_mm_segment as head and return the leaving buffer which will be itself cut into blocs linked with each other.</p>

<pre><code>typedef struct _zend_mm_segment {
    size_t  size;
    struct _zend_mm_segment *next_segment;
} zend_mm_segment;

typedef struct _zend_mm_free_block {
    zend_mm_block_info info;
#if ZEND_DEBUG
    unsigned int magic;
# ifdef ZTS
    THREAD_T thread_id;
# endif
#endif
    struct _zend_mm_free_block *prev_free_block;
    struct _zend_mm_free_block *next_free_block;

    struct _zend_mm_free_block **parent;
    struct _zend_mm_free_block *child[2];
} zend_mm_free_block;
</code></pre>

<p>zend_mm_heap is the shared heap. It's shared as a global variable into PHP, but you will usually never use it directly (except if you design extensions that plays with PHP memory in any way).</p>

<pre><code>struct _zend_mm_heap {
    int                 use_zend_alloc;
    void               *(*_malloc)(size_t);
    void                (*_free)(void*);
    void               *(*_realloc)(void*, size_t);
    size_t              free_bitmap;
    size_t              large_free_bitmap;
    size_t              block_size;
    size_t              compact_size;
    zend_mm_segment    *segments_list;
    zend_mm_storage    *storage;
    size_t              real_size;
    size_t              real_peak;
    size_t              limit;
    size_t              size;
    size_t              peak;
    size_t              reserve_size;
    void               *reserve;
    int                 overflow;
    int                 internal;
#if ZEND_MM_CACHE
    unsigned int        cached;
    zend_mm_free_block *cache[ZEND_MM_NUM_BUCKETS];
#endif
    zend_mm_free_block *free_buckets[ZEND_MM_NUM_BUCKETS*2];
    zend_mm_free_block *large_free_buckets[ZEND_MM_NUM_BUCKETS];
    zend_mm_free_block *rest_buckets[2];
#if ZEND_MM_CACHE_STAT
    struct {
        int count;
        int max_count;
        int hit;
        int miss;
    } cache_stat[ZEND_MM_NUM_BUCKETS+1];
#endif
};
</code></pre>

<p>As you can see, compiling PHP with the debug flag enables many things into those low level structures.</p>

<h3 id="published-functions">Published functions<a href="#published-functions" class="anchor">#</a></h3>

<p>ZendMM is mainly used when designing PHP internals (extensions or core development). For this goal, it publishes some functions the developer must use instead of traditionnal libc functions.
Those published functions are very intuitive and easy to use, let's have a look:</p>

<pre><code>void *emalloc(size_t size);
void *pemalloc(size_t size, char persistent)
void *ecalloc(size_t size);
void *pecmalloc(size_t size, char persistent)
void *erealloc(void *ptr, size_t size);
void *perealloc(void *ptr, size_t size, char persistent)
void *estrdup(void *ptr)
void *pestrdup(void *ptr, char persistent)  void *strdup(void *ptr)
void efree(void *ptr)
void pefree(void *ptr, char persistent) void free(void *ptr)
</code></pre>

<p>As you can see, they share the same API as malloc/free/strdup etc... from libc. A quick word on "p" functions. "p" stands for "persitent", this means that the allocation will persist through requests.
In reality, those "persitent" functions directly proxy to the bottom layer (malloc/free), one should use them for every allocation that is not request bound, meaning that ZendMM won't warn you about possible leaks for them, simply because they can't really leak and will anyway be cleaned when PHP shuts down.</p>

<h3 id="from-php-land">From PHP land<a href="#from-php-land" class="anchor">#</a></h3>

<p>PHP allows you, as a PHP developer, to interact with it. Functions memory_get_usage() and memory_get_peak_usage() are published, as well as the ini setting <em>memory_limit</em>.
As most of dynamic allocation request from PHP go through the ZendMM layer, it is very easy for it to count the number of bytes asked so far, and bail out in case of reaching a limit : the <em>memory_limit</em>.</p>

<pre><code>zend_mm_safe_error(heap, "Allowed memory size of %ld bytes exhausted (tried to allocate %ld bytes)", heap-&gt;limit, size);
</code></pre>

<p>To know PHP dynamic memory usage at a given moment, memory_get_usage() may be used. This function returns the size used into the allocated segments. This means that it is less than the real usage of PHP.
To know the real usage, aka the memory to fit the segments in it, pass 1 to the function : memory_get_usage(1);</p>

<pre><code>&lt;?php
ini_set('memory_limit', -1); // unlimited memory

function show_memory($real = false) {
    printf("%.2f Kb\n", memory_get_usage($real) / 1024);
}

show_memory();
show_memory(1);

$a = str_repeat('a', 1024*1024*10); // 10Mb

echo "\n";

show_memory();
show_memory(1);

$&gt; php /tmp/mem.php
621.62Kb
768.00 Kb

10861.83 Kb
11264.00 Kb
</code></pre>

<p>memory_get_peak_usage() returns the peak ZendMM recorded in its life.</p>

<blockquote>
  <p>Important : Nothing forces the C developers to use ZendMM. Anyone developing an extension (for example) could absolutely not use ZendMM and rely directly on malloc/free, thus allocating dynamic memory that will not be seen by ZendMM and memory_get_usage(), memory_limit etc... Here, you may use your OS to monitor this. Obviously, C developers know that and heavily rely on ZendMM, but still.
  Also, note that PHP's source code itself uses ZendMM, but sometimes, somewhere, no. Some parts of code use persistent allocs or directly malloc/free.</p>
  
  <p>That's why memory_get_usage() give an average information, often accurate, but not 100% accurate on a byte-basis. Use your OS for that.</p>
</blockquote>

<h3 id="tuning">Tuning<a href="#tuning" class="anchor">#</a></h3>

<h4 id="zend-mm-seg-size-sizing-zendmm-heap-allocations">ZEND_MM_SEG_SIZE, sizing ZendMM heap allocations<a href="#zend-mm-seg-size-sizing-zendmm-heap-allocations" class="anchor">#</a></h4>

<p>To understand segments and why this is important, imagine a PHP with 256Kb segment size (default). If it has to consume say 320Kb, ZendMM will allocate onto its heap 2 segments, thus using from the OS 512Kb, filled at 320Kb. This is a cursor, and this is where ZendMM gives performances : it allocates more than what is really used, thus it allocates less often, it then prevents the process heap from fragmentation.</p>

<pre><code>// /tmp/mem.php is the code shown in the above example

$&gt; ZEND_MM_SEG_SIZE=1048576 php /tmp/mem.php 
625.67 Kb
1024.00 Kb

10865.88 Kb
12288.00 Kb
</code></pre>

<p>It is clear here. PHP consumes 625.67Kb, ZendMM allocated 1Mb segments, so one segment to fit the usage. The real usage is then 1Mb, and the usage is only 625.67Kb.
We then create a 10Mb string, so the memory consumption raises to 10865.88Kb and the real reaches 12288Kb : 12 segments of 1Mb each (1024Kb).</p>

<blockquote>
  <p>ZEND_MM_SEG_SIZE must obviously be power-of-two aligned</p>
</blockquote>

<pre><code>&lt;?php
ini_set('memory_limit', -1); // unlimited memory

function get_mem_stats() {
    printf("Memory usage %.2f Kb\n", memory_get_usage() / 1024);
    if ($segSize = getenv('ZEND_MM_SEG_SIZE') {
        printf("Heap segmentation : %d segments of %d bytes (%d Kb used)\n", memory_get_usage(1)/$segSize, $segSize, memory_get_usage(1)/1024);
    }
}

get_mem_stats();

$a = str_repeat('a', 1024*1024*10); // 10 Mb

echo "\n";

get_mem_stats();

$&gt; ZEND_MM_SEG_SIZE=2048 php /tmp/mem.php
Memory usage 630.97 Ko
Heap segmentation : 325 segments of 2048 bytes (650 Kb used)

Memory usage 10871.18 Ko
Heap segmentation : 5446 segments of 2048 bytes (10892 Kb used)
</code></pre>

<p>We can then say that the more tiny the segments are, the more the heap close to real memory usage (economical) but the more often it has to create segments.
This is why, by default, the segment size is 256Kb. With such a value, ZendMM will have to allocate few segments to fit the needs, which are usually around 5Mb. Sure, a framework based app (much more greedy in memory) may benefit from a tunning of the allocator. Look at that :</p>

<pre><code>&lt;?php
get_mem_stats();

/* This is the date component from ZF1. This class is known beeing huge
    https://github.com/zendframework/zf1/blob/master/library/Zend/Date.php */
require 'Zend/Date.php';

echo "\n";
get_mem_stats();

$&gt; ZEND_MM_SEG_SIZE=2048 php /tmp/mem.php 
Memory usage 630.35 Ko
Heap segmentation : 325 segments of 2048 bytes (650 Kb used)

Memory usage 4994.70 Ko
Heap segmentation : 2687 segments of 2048 bytes (5374 Kb used)
</code></pre>

<p>Yeah, we raise from 630Kb to about 5Mb just by making PHP parse the Zend/Date.php, which contains a huge class. We even did not make any use of this class, just parsed it.
Remember that in PHP objects are really tiny and very well designed to be thrifty, but all the weigth is passed back to the class. In PHP, a class is something consuming memory, a fortiori a big class.</p>

<p>To well tune segment size, you must know the average PHP memory consumption of your app, so that with well sized segments, the allocator won't create and free too many segments too often.
A bad thing for performance is having an application oscillate around a segment, forcing the ZendMM to call the underlying allocator.</p>

<p><img src="../../../img/php-memory/mm.png" alt="memory_get_usage"><img src="../../../img/php-memory/mm2.png" alt="memory_get_usage"></p>

<h4 id="zend-mm-mem-type-choosing-the-underlying-allocator">ZEND_MM_MEM_TYPE : choosing the underlying allocator<a href="#zend-mm-mem-type-choosing-the-underlying-allocator" class="anchor">#</a></h4>

<p>As we've seen so far, the underlying allocator ZendMM will rely on is configurable. By default, it is set to 'malloc' ('win32' under Windows).</p>

<pre><code>#define ZEND_MM_MEM_WIN32_DSC {"win32", zend_mm_mem_win32_init, zend_mm_mem_win32_dtor, zend_mm_mem_win32_compact, zend_mm_mem_win32_alloc,
 zend_mm_mem_win32_realloc, zend_mm_mem_win32_free}

#define ZEND_MM_MEM_MALLOC_DSC {"malloc", zend_mm_mem_dummy_init, zend_mm_mem_dummy_dtor, zend_mm_mem_dummy_compact, zend_mm_mem_malloc_alloc,
 zend_mm_mem_malloc_realloc, zend_mm_mem_malloc_free}
</code></pre>

<p>You can choose also mmap_anon or mmap_zero. mmap_anon will create a new anonymous memory mapping in your process mapping table :</p>

<pre><code>zend_mm_segment *ret = (zend_mm_segment*)mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);
</code></pre>

<p>mmap_zero is the same, but using /dev/zero descriptor (usually BSD based Unixes) :</p>

<pre><code>zend_mm_dev_zero_fd = open("/dev/zero", O_RDWR, S_IRUSR | S_IWUSR);
zend_mm_segment *ret = (zend_mm_segment*)mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE, zend_mm_dev_zero_fd, 0);
</code></pre>

<p>Using mmap_anon or mmap_zero is better if you don't want to suffer from your libc's malloc overhead :</p>

<pre><code>ini_set('memory_limit', -1);

function heap() {
return shell_exec(sprintf('grep "VmData:" /proc/%s/status', getmypid()));
}

printf ("Original heap status: %s\n", heap());

$a = range(1, 1024*1024); /* A very big array */

printf("I'm now eating heap memory: %s\n", heap());
unset($a); /* Free the memory */
printf("Memory should now have been freed: %s\n", heap());
</code></pre>

<p>This code gets information about the process heap usage using the VmData field provided by the Linux Kernel. Here is the output with malloc :</p>

<pre><code>&gt; php leak.php

Original heap status: VmData:         4504 kB
I'm now eating heap memory: VmData:    152232 kB
Memory should now have been freed: VmData:    143780 kB
</code></pre>

<p>mmm, seems like there is something strange. Seems like memory is heavily leaking because it does not reach back its original value when I destroy the very big array that did ask for mush memory from the heap. What's happening ?</p>

<p>Let's launch this script again, but now choosing mmap_anon as underlying allocator for ZendMM :</p>

<pre><code>&gt;ZEND_MM_MEM_TYPE=mmap_anon php leak.php 

Original heap status: VmData:         4404 kB
I'm now eating heap memory: VmData:   152116 kB
Memory should now have been freed: VmData:      4916 kB
</code></pre>

<p>Aha, seems much better. In this particular case, we've been hit by malloc implementation. When we freed the memory, ZendMM did call free(), but free() itself did not free the memory back to the OS, but prefered keeping the blocks in a heat area to serve them back later. This is good if you don't use an overlay, like ZendMM. But using ZendMM, which itself implements a heat zone an reusage of pointers, it is silly to suffer from libc's malloc implementation details (which may vary a lot depending on how malloc() has been compiled on your system, you should read your system manual to know about this).</p>

<p>So using mmap_anon, if you know what this is, ZendMM will call munmap(), which is a Kernel service (system call) which will mark the physical pages as freed, thus unpaging them from your process memory image : your memory consumption will then drop.</p>

<h2 id="a-quick-word-on-the-garbage-collector">A quick word on the Garbage Collector<a href="#a-quick-word-on-the-garbage-collector" class="anchor">#</a></h2>

<p>Just to be clear, because we tend to read so many bullshit on the Web about PHP, by people just telling things that are not true... Anyway, let me clarify. Zend Memory Manager has nothing to share with ZendGC. ZendGC, appeared in PHP 5.3, is about clearing circular references in PHP variables and that's absolutely all it does. It then acts on top of ZendMM, for PHP variables containing themselves (circular references). PHP has always freed back the memory when it has not used it anymore, and this is ZendMM role</p>

<p><img src="../../../img/php-memory/zendgc.png" alt="ZendGC"></p>

<h2 id="deeper-example">Deeper example<a href="#deeper-example" class="anchor">#</a></h2>

<p>We're gonna trace every dynamic memory allocation from a PHP process, just to have an idea of how PHP uses the heap memory. We're gonna use Valgrind-Massif for that.</p>

<p>Here is the very simple script we'll benchmark :</p>

<pre><code>&lt;?php
echo "hello world";
</code></pre>

<p>With such a script, there is no chance we use lots of memory from PHP land, as echoing a tiny string is something trivial for memory usage</p>

<pre><code>&gt; valgrind --tool=massif --massif-out-file=massif.out --max-snapshots=1000 --stacks=yes php /tmp/void.php &amp;&amp; ms_print massif.out &gt; massif.txt

    MB
4.189^                                                                  #     
     |                                                                 @#@    
     |                                                               ::@#@:   
     |                                                              :::@#@@   
     |                                                             @:::@#@@@  
     |                                                            :@:::@#@@@  
     |                                                           @:@:::@#@@@  
     |                                                          @@:@:::@#@@@: 
     |                                                        ::@@:@:::@#@@@@ 
     |                                            @@@@@@:@@@@@@:@@:@:::@#@@@@ 
     |                                          @:@@@@@@:@@@@@@:@@:@:::@#@@@@ 
     |                                         @@:@@@@@@:@@@@@@:@@:@:::@#@@@@ 
     |                                        @@@:@@@@@@:@@@@@@:@@:@:::@#@@@@:
     |                                        @@@:@@@@@@:@@@@@@:@@:@:::@#@@@@:
     |                                   @:::@@@@:@@@@@@:@@@@@@:@@:@:::@#@@@@:
     |                                   @:::@@@@:@@@@@@:@@@@@@:@@:@:::@#@@@@:
     |                                   @:::@@@@:@@@@@@:@@@@@@:@@:@:::@#@@@@:
     |                                   @:::@@@@:@@@@@@:@@@@@@:@@:@:::@#@@@@:
     |                                   @:::@@@@:@@@@@@:@@@@@@:@@:@:::@#@@@@:
     |                                   @:::@@@@:@@@@@@:@@@@@@:@@:@:::@#@@@@:
   0 +-----------------------------------------------------------------------&gt;Mi
     0                                                                   27.69

Number of snapshots: 589
 Detailed snapshots: [14, 19, 24, 27, 40, 44, 52, 59, 71, 77, 81, 82, 95, 113, 117, 154, 170, 172, 188, 192, 218, 221, 264, 268, 270, 299, 307, 317, 323, 324, 325, 338, 343, 351, 361, 364, 375, 390, 396, 400, 403, 406, 414, 423, 438, 442, 443, 446, 458, 461, 462, 492, 498 (peak), 508, 518, 528, 538, 548, 558, 568, 578, 588]
</code></pre>

<p>The max memory usage is (about) 4Mb, and 588 snapshots have been taken. Be warned that this represents the memory usage of my PHP, on my platform etc...
If you have another OS or architecture, the numbers will vary. Also, if you activate more or less PHP extensions, those numbers will vary as well.</p>

<pre><code>--------------------------------------------------------------------------------
  n        time(i)         total(B)   useful-heap(B) extra-heap(B)    stacks(B)
--------------------------------------------------------------------------------
265     14,029,321              640               37            19          584
266     14,097,959              848               37            19          792
267     14,152,209           10,064            3,841           751        5,472
268     14,194,235        1,336,904        1,328,911         1,913        6,080
99.40% (1,328,911B) (heap allocation functions) malloc/new/new[], --alloc-fns, etc.
-&gt;78.43% (1,048,576B) 0x83F90B: zend_interned_strings_init (zend_string.c:48)
| -&gt;78.43% (1,048,576B) 0x81E0AC: zend_startup (zend.c:744)
|   -&gt;78.43% (1,048,576B) 0x7BDA18: php_module_startup (main.c:2055)
|     -&gt;78.43% (1,048,576B) 0x8CFA9B: php_cli_startup (php_cli.c:417)
|       -&gt;78.43% (1,048,576B) 0x445AA6: main (php_cli.c:1358)
|         
-&gt;19.61% (262,144B) 0x7F75FB: _zend_mm_alloc_int (zend_alloc.c:1982)
| -&gt;19.61% (262,144B) 0x7F8750: zend_mm_startup_ex (zend_alloc.c:1126)
|   -&gt;19.61% (262,144B) 0x7F8888: zend_mm_startup (zend_alloc.c:1221)
|     -&gt;19.61% (262,144B) 0x7F9306: start_memory_manager (zend_alloc.c:2733)
|       -&gt;19.61% (262,144B) 0x81DD8A: zend_startup (zend.c:649)
|         -&gt;19.61% (262,144B) 0x7BDA18: php_module_startup (main.c:2055)
|           -&gt;19.61% (262,144B) 0x8CFA9B: php_cli_startup (php_cli.c:417)
|             -&gt;19.61% (262,144B) 0x445AA6: main (php_cli.c:1358)
|               
-&gt;01.36% (18,191B) in 20 places, all below massif's threshold (01.00%)
</code></pre>

<p>At timeslot 268, we can notice that 1.3Mb have been allocated, of which zend_interned_string_init() uses 1Mb, and _zend_mm_alloc_int() uses 256Kb.
zend_interned_string_init() is the interned string buffer used for string interning. By default, <a href="http://lxr.php.net/xref/PHP_5_5/Zend/zend_string.c#43">it is 1Mb size</a> and can only be changed
at PHP compilation.
_zend_mm_alloc_int() allocated 256Kb, yes, this is our underlying allocator call, to allocate one segment of memory, the very first one (default is 256Kb), PHP is actually starting and we are very soon in that process at timeslot 268.
Let's keep going :</p>

<pre><code>--------------------------------------------------------------------------------
  n        time(i)         total(B)   useful-heap(B) extra-heap(B)    stacks(B)
--------------------------------------------------------------------------------
300     15,909,135        1,406,104        1,377,534        12,882       15,688
301     15,963,752        1,407,088        1,378,252        13,196       15,640
302     16,018,604        1,407,112        1,378,248        13,176       15,688
303     16,089,865        1,408,296        1,379,153        13,503       15,640
304     16,144,629        1,407,288        1,386,986        14,806        5,496
305     16,183,971        1,743,384        1,720,538        16,886        5,960
306     16,248,952        1,771,944        1,746,686        19,298        5,960
307     16,288,999        1,790,200        1,763,176        20,960        6,064
98.49% (1,763,176B) (heap allocation functions) malloc/new/new[], --alloc-fns, etc.
-&gt;58.57% (1,048,576B) 0x83F90B: zend_interned_strings_init (zend_string.c:48)
| -&gt;58.57% (1,048,576B) 0x81E0AC: zend_startup (zend.c:744)
|   -&gt;58.57% (1,048,576B) 0x7BDA18: php_module_startup (main.c:2055)
|     -&gt;58.57% (1,048,576B) 0x8CFA9B: php_cli_startup (php_cli.c:417)
|       -&gt;58.57% (1,048,576B) 0x445AA6: main (php_cli.c:1358)
|         
-&gt;17.88% (320,000B) 0x83D6F5: gc_init (zend_gc.c:124)
| -&gt;17.88% (320,000B) 0x81DA5F: OnUpdateGCEnabled (zend.c:81)
|   -&gt;17.88% (320,000B) 0x833883: zend_register_ini_entries (zend_ini.c:208)
|     -&gt;17.88% (320,000B) 0x7BDFC7: php_module_startup (main.c:2191)
|       -&gt;17.88% (320,000B) 0x8CFA9B: php_cli_startup (php_cli.c:417)
|         -&gt;17.88% (320,000B) 0x445AA6: main (php_cli.c:1358)
|           
-&gt;14.64% (262,144B) 0x7F75FB: _zend_mm_alloc_int (zend_alloc.c:1982)
| -&gt;14.64% (262,144B) 0x7F8750: zend_mm_startup_ex (zend_alloc.c:1126)
|   -&gt;14.64% (262,144B) 0x7F8888: zend_mm_startup (zend_alloc.c:1221)
|     -&gt;14.64% (262,144B) 0x7F9306: start_memory_manager (zend_alloc.c:2733)
|       -&gt;14.64% (262,144B) 0x81DD8A: zend_startup (zend.c:649)
|         -&gt;14.64% (262,144B) 0x7BDA18: php_module_startup (main.c:2055)
|           -&gt;14.64% (262,144B) 0x8CFA9B: php_cli_startup (php_cli.c:417)
|             -&gt;14.64% (262,144B) 0x445AA6: main (php_cli.c:1358)
|               
-&gt;03.43% (61,493B) in 42 places, all below massif's threshold (01.00%)
| 
-&gt;02.72% (48,640B) 0x82B9B2: _zend_hash_quick_add_or_update (zend_alloc.h:95)
| -&gt;02.52% (45,136B) 0x824F74: zend_register_functions (zend_API.c:2139)
| | -&gt;02.52% (45,136B) 0x8257C6: zend_register_module_ex (zend_API.c:1946)
| |   -&gt;01.79% (31,992B) 0x7BD8B3: php_register_extensions (main.c:1924)
| |   | -&gt;01.79% (31,992B) 0x7BE020: php_module_startup (main.c:2213)
| |   |   -&gt;01.79% (31,992B) 0x8CFA9B: php_cli_startup (php_cli.c:417)
| |   |     -&gt;01.79% (31,992B) 0x445AA6: main (php_cli.c:1358)
| |   |       
| |   -&gt;00.73% (13,144B) in 1+ places, all below ms_print's threshold (01.00%)
| |   
| -&gt;00.20% (3,504B) in 1+ places, all below ms_print's threshold (01.00%)
</code></pre>

<p>Interesting. At timeslot 307, the snapshot starts showing the famous garbage collector impact. The circular garbage collector, to be able to run and do its job, needs not less than 320Kb of memory, which is not trivial.  php_module_startup() is the call to start every PHP extensions, which will start registering some classes, some functions etc... 48Kb so far</p>

<p>Etc... We could detail all the snapshot if you wish to have a full night reading this article ;-)</p>

<h2 id="end">End<a href="#end" class="anchor">#</a></h2>

<p>Zend Memory Manager (ZendMM) is a layer sitting on top of every (ideally) PHP heap allocation request. It has been designed to improve PHP performances, as PHP started becoming more and more complex and heap dependent. As you know now, you must compile a debug build of PHP to activate all the interesting parts of ZendMM.</p>

<p>In any case, PHP is build with ZendMM, so you benefit from it, from its very complex lines of codes, without having noticing it yet. Am I wrong ? Memory allocation in a programm can easilly turn to nightmare when you want to take in consideration all the parts : leaks, performance, thread safety, etc...</p>

<p>You can read many articles about allocators (low level ones) on the web, starting by <a href="http://locklessinc.com/benchmarks_allocator.shtml">Benchmarks of the Lockless Memory Allocator</a> or <a href="https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919">Scalable memory allocation using jemalloc</a>.</p>]]></content>
    </entry>
        <entry>
        <title>PHP and MySQL communication, mysqlnd</title>
                <id>http://jpauli.github.io//2014/07/21/php-and-mysql-communication-mysqlnd.html</id>
                <updated>2014-07-21T00:00:00+00:00</updated>
        <author>
            <name>Julien Pauli</name>
            <email>jpauli@php.net</email>
        </author>
        <link rel="alternate" type="text/html" href="http://jpauli.github.io//2014/07/21/php-and-mysql-communication-mysqlnd.html"/>
        <content type="html" xml:lang="en"><![CDATA[<h2 id="introduction">Introduction<a href="#introduction" class="anchor">#</a></h2>

<p>Appeared with PHP5.3, mysqlnd is an unknown part of PHP. Yet, this extension is a must-have if your system relies heavily on the MySQL database server. We'll see what mysqlnd is, what it brings to PHP
and how to use it.</p>

<h2 id="foresee">Foresee<a href="#foresee" class="anchor">#</a></h2>

<p>PHP communicates with MySQL through a connector. 2 of them exist : libmysql or mysqlnd. libmysql is developed by Oracle, while mysqlnd is developed by the PHP team.
If a user wants to communicate with MySQL using the PHP language, this latter publishes 3 APIs in this goal : ext/mysql, ext/mysqli and ext/pdo_mysql.</p>

<p><img src="../../../img/php-mysql-com/php-arch-libmysql.png" alt="libmysql"><img src="../../../img/php-mysql-com/php-arch-libmysql.png" alt="mysqlnd"></p>

<h3 id="connectors">Connectors<a href="#connectors" class="anchor">#</a></h3>

<h4 id="libmysql">libmysql<a href="#libmysql" class="anchor">#</a></h4>

<p>Historicaly, PHP needed the MySQL server C connector to be able to talk with it. This connector is also known as "libmysql", and may be installed on your system with a command like <code>apt-get install libmysql</code>. This connector implements the MySQL communication API, let's see an example :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;mysql/mysql.h&gt;
#include "mysql_example.h" /* Pour MYSQL_HOST, MYSQL_USER, MYSQL_PASS */

int main(int argv, char *argc[])
{
    MYSQL_RES *results = NULL; MYSQL_ROW row; MYSQL *db = NULL;

    db = (MYSQL *)malloc(sizeof(MYSQL));
    mysql_init(db);
    mysql_options(db, MYSQL_INIT_COMMAND, "SET NAMES UTF8;");
    if(!mysql_real_connect(db, MYSQL_HOST, MYSQL_USER, MYSQL_PASS, NULL, 0, NULL, 0)) {
        fprintf(stderr, "Failed to connect to host %s (%s)", MYSQL_HOST, mysql_error(db));
        exit(EXIT_FAILURE);
    }

    mysql_set_character_set(db, "utf8");
    mysql_select_db(db, "my_database");
    mysql_query(db , "SELECT user_id AS id FROM users WHERE user_description='member' LIMIT 10000");
    results = mysql_use_result(db);

    while(row = mysql_fetch_row(results)) {
        printf("%s\n", row[0]);
    }

    mysql_free_result(results);
    exit(EXIT_SUCCESS);
}
</code></pre>

<p>You can run this code by linking your binary with libmysql, GCC's switch "-lmysql".
The libmysql documentation is detailed, and online, at <a href="http://dev.mysql.com/doc/refman/5.0/en/c-api.html">http://dev.mysql.com/doc/refman/5.0/en/c-api.html</a></p>

<p>As you could have noticed, the PHP extensions "mysql" and "mysqli" borrow this C API to publish it to PHP land. This is one of the PHP way of doing things : when an extension creator embeds a C API
into PHP's source to publish it to PHP user land, usually he gives it the same API as the C one, this way when you know one of them, you are not lost getting hands into the second one.</p>

<p>libmysql however brings two problems to your architecture :</p>

<ul><li>The licencing is complex. For example, if you wish to build a closed-source commercial product on top of libmysql, you'll need to pay for a licence. <a href="http://www.mysql.com/about/legal/licensing/oem/">Details about libmysql licencing here</a>.</li>
<li>Updating libmysql involves updating the MySQL server, which sometimes is not what you want in your upgrading strategies.</li>
</ul><h4 id="mysqlnd">mysqlnd<a href="#mysqlnd" class="anchor">#</a></h4>

<p>As of PHP5.3, the PHP developers rewrote entirely the libmysql source code, into a PHP extension named "mysqlnd". mysql native driver. This connector is licenced under the PHP licence, which is much more appropriate than the complex Oracle's licences for any PHP software, should it be closed or open source.</p>

<p>Also, rewriting the code of a library that was not part of PHP (libmysql) was also the way to improve many things in the MySQL-PHP communication. We'll detail how mysqlnd can improve your application performance drastically, especially if this one runs big select queries (batch scripts are the appropriate use case here).</p>

<p>Just keep in mind that mysqlnd is a PHP extension that does not publish any class or function to PHP (this in not totally right, we'll get back to that point later on), it however can serve as a big basis for other PHP extensions mysql,mysqli and pdo_mysql to rely on when communicating with MySQL servers.</p>

<p>mysqlnd is to be activated at compile time in PHP 5.3 (--with-pdo-mysql=mysqlnd switch, for pdo_mysql example), and it is proposed <em>as the default connector</em> starting from PHP 5.4.</p>

<h3 id="extensions">Extensions<a href="#extensions" class="anchor">#</a></h3>

<p>PHP publishes 3 extensions for the PHP user to talk to MySQL servers.</p>

<h4 id="mysql">mysql<a href="#mysql" class="anchor">#</a></h4>

<p>This very old extension was the first one published. It was contributed by the MySQL authors back before year 2000. It publishes the <em>mysql_</em> functions in PHP by adopting the underlying C API.
This extension borrows the MySQL server 3.23 API, so for today, it is not to be used as it is too old. It's still here for compatibility purposes, throws E_DEPRECATED errors in latest PHP versions and is meant to die sooner or later. Please, don't use it for your recent projects.</p>

<h4 id="mysqli">mysqli<a href="#mysqli" class="anchor">#</a></h4>

<p>mysqli is written with an end "i" which stands for "improved". This extension appeared in PHP5.0, and is meant to replace the old ext/mysql API, because it is internally based or more recent MySQL server API : 4.1 or later. It then supports stored procedure, secured authentification protocol, prepared statements and much more.
It also publishes an object oriented API to the PHP user, together with a procedural API.</p>

<p>PHP contributors designed this extension so that it has a very common API shared with ext/mysql, and migrations from ext/mysql to ext/mysqli should really be painless.</p>

<p>We'll detail ext/mysqli API in a few moment to introduce not well understood but critical concepts such as buffered/unbuffered queries and prepared statements.</p>

<h4 id="pdo">PDO<a href="#pdo" class="anchor">#</a></h4>

<p>PDO is different from mysql/mysqli because it has been designed to support other RDBMS than MySQL. In this fact, this extension is imperfect and tries to guess many things from the user, which could lead to strange behaviors. Let me explain.</p>

<p>PDO ships with an SQL parser which is to emulate prepared statements if the underlying RDBMS doesn't support them. The problem is that this layer behaves differently from the RDBMS' one, when present.
If you take the MySQL case, the PDO emulation layer is active by default when you prepare a query, and this one will never hit MySQL prepared statement layer which is probably not what you want. In fact, PDO's code will parse and build your query, never communicating with MySQL about this (by default). This is weird. Turn this emulation layer off as soon as you can :</p>

<pre><code>/* Disable PDO prepared statements emulation */
$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);

/* This is exactly the same, take care, we really pass 0 here and not 1 */
$pdo-&gt;setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);
</code></pre>

<p>When the emulation layer is disabled, you rely with a true prepared statement. When it is enabled, PDO will take care of constructing the query for you, and will send a traditionnal normal query to the RDBMS. This has lots of drawbacks and can lead to strange behaviors. As PDO doesn't know anything about tables' columns, its emulation layer will quote every parameter when bound to an emulated prepared statement, even the parameter of integer type, which don't need such quoting. This leads to errors :</p>

<pre><code>$stmt = $pdo-&gt;prepare("SELECT user_id FROM users LIMIT :limit");
$stmt-&gt;bindValue('limit', 10);
$stmt-&gt;execute();

$result = $stmt-&gt;fetch();
var_dump($result);

/*
PHP Fatal error:  Uncaught exception 'PDOException' with message 'SQLSTATE[42000]: Syntax error or access violation: 1064 You have an error in your SQL syntax;
check the manual that corresponds to your MySQL server version for the right syntax to use near ''10'' 
*/
</code></pre>

<p>We see from this error message that PDO escaped my 'limit' parameter quoting it wrongly, as it is an integer and doesn't need that.
Let's try again with no emulation layer, relying only on the RDBMS layer (MySQL here):</p>

<pre><code>$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, 0); /* Disable prepared statement emulation layer */
$stmt = $pdo-&gt;prepare("SELECT user_id FROM users LIMIT :limit"); /* A true prepare() will be sent to the RDBMS, it has to support it */
$stmt-&gt;bindValue('limit', 10);
$stmt-&gt;execute();

$result = $stmt-&gt;fetch();
var_dump($result);
/*
array(4) {
  ["user_id"]=&gt;
  string(7) "18"
  [0]=&gt;
  string(7) "18"
}
*/
</code></pre>

<p>Things now work.
If you would want to still use the emulation layer, you'd then need to precise to PDO that your parameter is of type integer, like this :</p>

<pre><code> /* Tells the PDO prepared statement emulation layer that this column is of type integer (SQL type) */
$stmt-&gt;bindValue('limit', 10, PDO::PARAM_INT);
</code></pre>

<p>And here you don't have the whole story.</p>

<p>Whereas we explicitely disabled the prepared statement emulation layer in PDO, this one is still a little active. The layer is still triggered for parameter parsing. You know about the two parameter syntax : anonymous parameters, implemented as "?" in your query for placeholders, or the named parameters, as ":myparam". Those two syntaxes are not supported by every RDBMS, and guess what ? MySQL doesn't support the named parameters one, only the question-mark-based one.
However, our preceding query still completed fine... This is because the PDO query analyzer is still active, even with prepared statement emulation layer tured off. It stepped in and replaced every named parameter by an anonymous one, because it asked the RDBMS (MySQL here) about its capabilities to support those syntaxes, and MySQL answered it did not support the named parameters syntax. PDO then replaced every ":myparamname" by a "?".
Tricky isn't it ?</p>

<p>By trying to satisfy every soul on earth, PDO created an API that is full of trade-offs. It is in fact well designed, and eases the PHP developers life in a huge majority of cases, but hidding complexity is a double-edged sword. If you hit the bogus case, your are then in trouble if you don't know what happens in the lower layers.</p>

<h2 id="zoom-on-the-mysqli-extension">Zoom on the mysqli extension<a href="#zoom-on-the-mysqli-extension" class="anchor">#</a></h2>

<p>mysqli is a nice extension, really. Nowadays, everybody uses PDO, because if you were to switch from one RDBMS to an other, this would ease many things. I don't know you, but I've never met such a situation. If you use MySQL RDBMS, and you are pretty unlikely to change (in production), which usually is the case : don't use PDO, you'll lose many things and suffer from one more layer of abstraction which can't offer everything the RDBMS can offer.</p>

<p><img src="../../../img/php-mysql-com/mysqli-api.jpg" alt="mysqli"></p>

<p>First of all, mysqli has always been blamed for not generating exceptions but PHP errors. This is wrong.</p>

<pre><code>&lt;?php
mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);

try {
    $db = mysqli_connect('myserver', 'myuser', 'secret', 'unknown_database');
} catch (mysqli_sql_exception $e) {
    exit($e-&gt;getMessage());
}
try {
    mysqli_query($db, "SELECT foo FROM bar");
    /* ... */
} catch(mysqli_sql_exception $e) { }
</code></pre>

<p>You see ?</p>

<p>mysqli can even tell you when you miss an index :</p>

<pre><code>&lt;?php
mysqli_report(MYSQLI_REPORT_INDEX);
$db = mysqli_connect('myserver', 'myuser', 'secret', 'my_database');

mysqli_query($db, "SELECT photo FROM Users WHERE source ='web' LIMIT 1000");

/* PHP Warning:  mysqli_query(): (00000/0): No index used in query/prepared statement ... */
</code></pre>

<p>MySQL communicates many things with its client (PHP in our case). For more information, you should read the <a href="http://dev.mysql.com/doc/internals/en/client-server-protocol.html">MySQL client/server protocol documentation</a></p>

<p>Second thing : mysqli provides a function to change the character set : mysqli_set_character_name(). You should never use "SET NAMES" query, because the escaping strategies won't use it.
You can read more info about this at <a href="http://php.net/mysqlinfo.concepts.charset.php">http://php.net/mysqlinfo.concepts.charset.php</a> or <a href="http://dev.mysql.com/doc/refman/5.7/en/charset-connection.html">http://dev.mysql.com/doc/refman/5.7/en/charset-connection.html</a></p>

<p>Now, let's talk about buffered queries, which is a very obscur part.
When you query MySQL for results, so usually when you use SELECT queries, a resultset will be created and results will be in. Buffered resultsets is the concept about where to store the resultset ? Should it be stored into the client memory (buffered query), or stay on the MySQL side (unbuffered query) ? That's all.</p>

<p>Please, note that we are talking about direct queries and not prepared statements, which are not the same at all. We'll give a word about prepared statements later on.</p>

<p>By default, every direct query issued from mysqli to MySQL is buffered, this means that at the time you issue a <code>mysqli_query()</code> call, all the resultset is transmitted over the wire, back to PHP memory, and freed from the MySQL side. As the resultset resides on the PHP part, you can count it : <code>mysqli_num_rows()</code>, and you can seek into it at any place : <code>mysqli_data_seek()</code> and you can issue another query() while the resultset is not freed yet. Let's show an example :</p>

<pre><code>$mysqli = mysqli_connect(/*...*/);

/* By default, the resultset will be buffered into the client : PHP */
$result = mysqli_query($mysqli, "SELECT id, nom, email FROM members");
$line1 = mysqli_fetch_row($result);
mysqli_data_seek($result, mysqli_num_rows($result)); /* Let's jump to the last result */
$last_result = mysqli_fetch_row($result); /* Let's fetch that last result */

/* Should we not need this resultset anymore, let's free it, which will free memory :*/
mysqli_free_result($result);
</code></pre>

<p>This is classical and default case. Remember that the whole resultset is immediately transmitted by MySQL to PHP, so if you expect it to be big, like if you selected very large blob columns or a lot of results, PHP's memory footprint will increase proportionally. However, you will not be able to see this memory footprint using <code>memory_get_usage()</code> until you use mysqlnd as low level connector. We'll detail this later.</p>

<p>If you'd like to issue the same request using non buffered result set, you'll use the MYSQLI_USE_RESULT flag. But be carefull, if you use a non buffered resultset, this means that the resultset will be allocated on the MySQL side (into the MySQL process memory) for your connection, and MySQL can only store one resultset by connection, which means you won't be able to re-issue another direct query on this connection until you freed the resultset. Also, as the resultset is not stored on the PHP side, it is not possible you seek into it, nor you count how many results are in :</p>

<pre><code>$mysqli = mysqli_connect(/*...*/);

/* The resultset will be allocated on the MySQL side this time */
$result = mysqli_query($mysqli, "SELECT id, email FROM members", MYSQLI_USE_RESULT);

$line1 = mysqli_fetch_row($result); /* This may trigger the network to fetch a result from the resultset */

/* This leads to an error, you cant seek a resultset which is not "yours",
it is still located into MySQL memory */
mysqli_data_seek($result, mysqli_num_rows($result));

/* This leads to an error, you can't issue another unbuffered query if you did not
free the last resultset */
$result2 = mysqli_query($mysqli, "SELECT name FROM membres", MYSQLI_USE_RESULT);
</code></pre>

<p><code>mysqli_free_result()</code> frees the resultset, should it be stored on the PHP side or MySQL side.</p>

<p>Now, let's talk about prepared statements.</p>

<p>Prepared statements are very different from traditionnal direct queries :</p>

<ul><li>Prepared statements don't use the same underlying protocol as direct queries. The protocol is called the binary protocol, it is very otpimized and offers many things such as true data type bindings.</li>
<li>Prepared statements resultsets are not buffered by default. This is the opposite as direct queries resultsets.</li>
</ul><p>Let's start by dumping the protocol for a direct query :</p>

<pre><code>$m = mysqli_connect(/* params */);
$q = mysqli_query($m, 'SELECT * FROM Users LIMIT 1');
while($r = mysqli_fetch_row($q)) {
    /* do something */
}
mysqli_free_result($r);
</code></pre>

<p><img src="../../../img/php-mysql-com/mysql-simple-dump.png" alt="mysql text protocol"></p>

<p>As you can see on the picture, this is a textual protocol, this means that the data that MySQL sends back to PHP is only text. You asked for an integer column in your query ? you'll be given some text. Ouch ! That first means that MySQL has some additionnal work to do to turn the data types from its columns into texts. And that also means that on the PHP side, you'll only be able to retrieve PHP strings, even if your asked columns store different types.</p>

<p>Here we go for the same query as prepared statement :</p>

<pre><code>$m = mysqli_connect(/* params */);
$ps = mysqli_prepare($m, 'SELECT * FROM Users LIMIT 1');
mysqli_stmt_execute($ps);
while(mysqli_stmt_fetch($ps)) {
    /*  */
}
mysqli_stmt_close($ps);
</code></pre>

<p><img src="../../../img/php-mysql-com/mysql-ps-dump.png" alt="mysql binary protocol"></p>

<p>The protocol image shows that this time, there are more communications. Every bind (not done on our example) and every fetch will trigger MySQL to receive or transmit data on the wire.
However, we can't see that on the picture but the protocol used was binary, that means that every column type is respected and transmetted as-is : an integer will be sent as an integer, and not a string
anymore. Should you remember your type sizes, transmitting for example a TINYINT 200 will weigh one byte on the network whereas it would have used 4 bytes if turned to text. The binary protocol is then lighter from this point of view, but there are also more network interchange for signaling.</p>

<pre><code>$m = mysqli_connect(/* params */);
$ps = mysqli_prepare($m, 'SELECT id FROM Users LIMIT 10'); /* 'id 'column is of type INTEGER */
mysqli_stmt_execute($ps);
mysqli_stmt_bind_result($ps, $id); /* let's bind the result column on $id */
while(mysqli_stmt_fetch($ps)) {
    var_dump($id);
}
/*
int(62)
int(64)
int(65)
int(66)
int(67)
int(68)
int(69)
int(70)
int(71)
int(72)
*/
</code></pre>

<p>The example above shows clearly that PHP recovers integers, not strings any more.</p>

<p>It is however possible to keep types using the text protocol. This will need the client (PHP) to transtype the received strings ito the right expected types, and as you'd have guessed, only mysqlnd can do that, libmysql will be no help :</p>

<pre><code>$m = mysqli_connect(/* */);
$q = mysqli_query($m, 'SELECT id FROM users LIMIT 10';

while($r = mysqli_fetch_row($q)) {
    var_dump($r[0]);
}
/*
string(2) "62"
string(2) "64"
*/

$m = mysqli_connect(/* */);
mysqli_options($m, MYSQLI_OPT_INT_AND_FLOAT_NATIVE, true); /* This is only available using mysqlnd */
$q = mysqli_query($m, 'SELECT id FROM users LIMIT 10');

while($r = mysqli_fetch_row($q)) {
    var_dump($r[0]);
}
/*
int(62)
int(64)
*/
</code></pre>

<p>If we talk about the resultset of a prepared statement, it is not buffered by default, every fetch() operation will trigger a network communication. You may however buffer those resultsets, using <code>mysqli_stmt_store_result()</code>.</p>

<pre><code>$m = mysqli_connect(/* params */);
$ps = mysqli_prepare($m, 'SELECT id, name FROM Users LIMIT 1000');
mysqli_stmt_execute($ps);
mysqli_stmt_bind_result($ps, $id, $name);

/* Store every result into PHP in one call */
mysqli_stmt_store_result($ps);

while(mysqli_stmt_fetch($ps)) {
    /* do something with $id and $name */
}
mysqli_stmt_close($ps);
</code></pre>

<p>We've seen we still can buffer the resultset if we want to, but with prepared statements it is necessary to bind every result column to a PHP variable to be able to read some useful data.
Once more, if you use mysqlnd, you'll have access to mysqli_stmt_get_result(), which will turn a prepared statement resultset into a mysqli_result, and you'll be back using a direct-query-like API, but with prepared statements :</p>

<pre><code>$m = mysqli_connect(/* params */);
$ps = mysqli_prepare($m, 'SELECT id, name FROM Users LIMIT 1000');
mysqli_stmt_execute($ps);

/* Turn the result set into a mysqli_result */
$r = mysqli_stmt_get_result($ps); /* Only available under mysqlnd */

while($result = mysqli_fetch_row($r)) { /* direct query API */
    /* do something */
}
mysqli_free_result($r);
mysqli_stmt_close($ps);
</code></pre>

<h2 id="zoom-on-mysqlnd">Zoom on mysqlnd<a href="#zoom-on-mysqlnd" class="anchor">#</a></h2>

<p>We've seen so far that mysqlnd acts as a hidden extension which adds many features to the existing APIs, especially mysqli (this is true for PDO as well).
Let's now detail other parts of mysqlnd.</p>

<h3 id="memory-savings">Memory savings<a href="#memory-savings" class="anchor">#</a></h3>

<p>To understand this part, we need to recall some points :</p>

<ul><li>A buffered query fetches all the results from MySQL to PHP memory</li>
<li>The buffered result set is created by the library which is used to communicate, weither libmysql or mysqlnd</li>
<li>A resultset is not directly usable from PHP land, it has to be turned into a PHP structure such as an array, this operation is called a "fetch"</li>
</ul><p>Here we go.</p>

<p>Doing this is silly, and wastes a huge part of memory :</p>

<pre><code>$db  = mysqli_connect(/* */);
$result = mysqli_query($db, "SELECT very_huge_blob_column, lots, of, columns FROM foobar"); /* big query generating a huge heavy resultset */

while($results[] = mysqli_fetch_row($result)) { }
mysqli_free_result($result); /* This step is often forgotten, which is even worse! */
foreach($results as $foo) { /* do something */ }
</code></pre>

<p>Let's prove what we say :</p>

<pre><code>function memory_usage()
{
    $pid = getmypid();
    $r = explode(':',shell_exec("grep VmData /proc/$pid/status"));
    return '-&gt;'.trim($r[1])."\n";
}
$db = mysqli_connect(/* */);

echo "initial memory " . memory_usage();
$result = mysqli_query($db,"SELECT very_huge_blob_column FROM foobar");
echo "resultSet stored " . memory_usage();
while($results[] = mysqli_fetch_row($result)) { }
echo "query result saved " . memory_usage();
mysqli_free_result($result);
echo "resultSet freed " . memory_usage();
unset($results);
echo "saved result freed " . memory_usage();
unset($db);
echo "Db closed " . memory_usage();
</code></pre>

<p>With libmysql, here are the numbers :</p>

<pre><code>initial memory -&gt;3348 kB
resultSet stored -&gt;72724 kB
query result saved -&gt;149012 kB
resultSet freed -&gt;81156 kB
saved result freed -&gt;25348 kB
Db closed -&gt;24260 kB
</code></pre>

<p>As you can see, as soon as the <code>mysqli_query()</code> is executed, all the resultset is transmitted into PHP's memory. On this example, the memory raises from 3Mb to 70Mb ! (this is a true, real life example).
This is normal behavior as by default, direct queries are in buffered mode. What is important to understand here is that the resultset memory buffer <strong>has been allocated by the communication library : libmysql</strong>. And when it comes to turn this resultset to something PHP can use, fetch it into an array, <strong>the entire data into the resultset will be duplicated in memory</strong>, resulting in an enormous waste.</p>

<p>As the resultset buffer is allocated by libmysql, it wont show into memory_get_usage(), but you'll need to monitor your process heap to see that (like its done in the example using /proc).</p>

<p>So transforming the data from a resultset into a PHP variable blows up the memory. At this stage, libmysql buffer is still allocated and the data is fully duplicated into buckets of a PHP array, thus we are consuming now about 140Mb. Let's convince ourselves about those allocation by running valgrind memory analyzer with massif :</p>

<pre><code>99.92% (257,473,815B) (heap allocation functions) malloc/new/new[], --alloc-fns, etc.
-&gt;52.90% (136,314,880B) 0x69A01E: _zend_mm_alloc_int (zend_alloc.c:1908)
| -&gt;52.60% (135,528,448B) 0x69A1DE: _estrndup (zend_alloc.c:2503)
| | -&gt;52.60% (135,528,448B) 0x533BCE: php_mysqli_fetch_into_hash (mysqli.c:1191)
| |   -&gt;52.60% (135,528,448B) 0x53F2E1: zif_mysqli_fetch_row (mysqli_nonapi.c:352)
| |     -&gt;52.60% (135,528,448B) 0x70186A: zend_do_fcall_common_helper_SPEC (zend_vm_execute.h:320)
| |       -&gt;52.60% (135,528,448B) 0x6D9D96: execute (zend_vm_execute.h:107)
| |         -&gt;52.60% (135,528,448B) 0x6B4B98: zend_execute_scripts (zend.c:1236)
| |           -&gt;52.60% (135,528,448B) 0x663D0C: php_execute_script (main.c:2308)
| |             -&gt;52.60% (135,528,448B) 0x73BCDC: main (php_cli.c:1184)
| |               
| -&gt;00.31% (786,432B) in 1+ places, all below ms_print's threshold (01.00%)
| 
-&gt;45.85% (118,130,675B) 0x52DD010: my_malloc (my_malloc.c:37)
| -&gt;45.84% (118,112,344B) 0x52E0583: alloc_root (my_alloc.c:219)
| | -&gt;45.83% (118,096,024B) 0x5307A40: cli_read_rows (client.c:1418)
| | | -&gt;45.83% (118,096,024B) 0x5305955: mysql_store_result (client.c:2957)
| | |   -&gt;45.83% (118,096,024B) 0x53EF09: zif_mysqli_query (mysqli_nonapi.c:540)
| | |     -&gt;45.83% (118,096,024B) 0x70186A: zend_do_fcall_common_helper_SPEC (zend_vm_execute.h:320)
| | |       -&gt;45.83% (118,096,024B) 0x6D9D96: execute (zend_vm_execute.h:107)
| | |         -&gt;45.83% (118,096,024B) 0x6B4B98: zend_execute_scripts (zend.c:1236)
| | |           -&gt;45.83% (118,096,024B) 0x663D0C: php_execute_script (main.c:2308)
| | |             -&gt;45.83% (118,096,024B) 0x73BCDC: main (php_cli.c:1184)
</code></pre>

<p>my_alloc() is libmysql's allocator on top of malloc.</p>

<p>To free the resultset libmysql's keeping warm, you must call mysqli_free_result(). We can see that we fall back to about 70Mb after this call, and then, when we finally free the PHP array containing a copy of the resultset, we drop back to initial memory usage (on average, some cache systems may trigger, this is not leaked memory).</p>

<p>This duplication from libmysql's buffer to PHP memory can be prevented using mysqlnd. mysqlnd will benefit from the copy on write behavior of PHP zvals to save those copies. Let's show that :</p>

<pre><code>phpmysqlnd/bin/php poc_mysqli.php
initial memory -&gt;3208 kB
resultSet stored -&gt;70452 kB
query result saved -&gt;71220 kB
resultSet freed -&gt;81148 kB
saved result freed -&gt;19196 kB
Db closed -&gt;19196 kB
</code></pre>

<p>As you can see, when the buffered resultset is fetched into a PHP array, the memory does not move. Far from beeing multiplied by two hun ?
At the time you'll start writing into this array, thus modifying the fetched results, PHP will duplicate the result on a case by case basis, which is really cool for memory usage.
Also, mysqlnd used the PHP memory allocator to store the resultset into its own buffer, the memory usage is shared with PHP, and <code>memory_get_usage()</code> will show this memory.</p>

<p>Knowing that apps mainly SELECT data, then fetches them to usually display them (read only), it is a pure waste to still use libmysql as low level communication for such use cases.
And I don't talk about batch scripts, written in PHP, treating lots of data from MySQL, and from where people often complain about memory usage... It's not PHP's fault you know ;-)</p>

<h3 id="statistics">Statistics<a href="#statistics" class="anchor">#</a></h3>

<p>As mysqlnd act between any PHP Mysql layer, and the MySQL server, it sees everything : every single byte exchanged between both parts is seen, and can be counted to collect very useful statistics.
Let's have a look at some of them :</p>

<p><img src="../../../img/php-mysql-com/mysqlnd-stats-phpinfo.png" alt="mysqlnd statistics"></p>

<p>Here are some useful questions mysqlnd can answer very easily without requiring monitoring plugins, which are always heavy to setup and live on server side :</p>

<ul><li>How many MySQL active connections do I have ?</li>
<li>How many MySQL connection errors PHP met so far ?</li>
<li>How many queries have been prepared, but not executed (which is a waste of performance) ?</li>
<li>How many queries have been prepared, but used only once (prepared statements are useful if you reuse them, if not, its often a waste of bandwidth) ?</li>
<li>How many queries have queried for columns but have not fetched them (waste of bandwidth and memory )?</li>
<li>How many MySQL slow queries happened so far ?</li>
<li>How many queries not using an index ?</li>
</ul><p>mysqlnd can answer all those questions. Let's see :</p>

<pre><code>$db = mysqli_connect(/* */);

$result = mysqli_query($db,"SELECT user_id, email FROM users LIMIT 5");
mysqli_data_seek($result, 5);
$data = mysqli_fetch_row($result);
do_something($data);
mysqli_free_result($result);
var_dump(mysqli_get_connection_stats($db)); /* nly available under mysqlnd */

/*
["buffered_sets"]=&gt;
  string(1) "1"
["rows_fetched_from_server_normal"]=&gt;
  string(1) "5"
["rows_buffered_from_client_normal"]=&gt;
  string(1) "5"
["rows_fetched_from_client_normal_buffered"]=&gt;
  string(1) "1"
["connect_success"]=&gt;
  string(1) "1"
["connect_failure"]=&gt;
  string(1) "0"
["connection_reused"]=&gt;
  string(1) "0"
["reconnect"]=&gt;
  string(1) "0"
["active_connections"]=&gt;
  string(1) "1"
*/
</code></pre>

<p>The above code queries for 5 results, seeks into the resultset directly to the 5th, fetches it, uses it and frees all the resultset. Why so query for 5 results and only use one ?
We can see from the statistics array that <em>rows_fetched_from_server_normal</em> shows we queried 5 results and MySQL sent us 5 of them, they were all here, but <em>rows_fetched_from_client_normal_buffered</em> shows we only effectively fetched one result from the stored resultset. We then wasted bandwidth, MySQL CPU and PHP memory.</p>

<p>Let's extend MySQLi class to have a simple log about this waste :</p>

<pre><code>class JPMysqli extends Mysqli
{
    public function __destruct()
    {
        $stats = $this-&gt;get_connection_stats();
        $this-&gt;close();
        if($diff = $stats["rows_fetched_from_server_normal"] - ($stats["rows_fetched_from_client_normal_unbuffered"] + $stats["rows_fetched_from_client_normal_buffered"])) {
            trigger_error("You didn't use *$diff* selected results", E_USER_NOTICE);
        }
    }
}

$db = new JPMysqli(/* */);

$result = mysqli_query($db,"SELECT user_id, email FROM users LIMIT 5");
mysqli_data_seek($result, 5);
$data = mysqli_fetch_row($result);
do_something($data);
exit();
/*
Notice : "You didn't use *4* selected results"
*/
</code></pre>

<p>Nice, knowing that this particular behavior is really common is userland. So many applications run queries selecting tons of result, but only effectively using part of them.</p>

<h3 id="plugins">Plugins<a href="#plugins" class="anchor">#</a></h3>

<p>mysqlnd is a so nice extension... It is even extensible !
This means that it's been thought to be extensible without further changing its source code. mysqlnd is plugable, and one may activate other PHP extensions which are in fact plugins for mysqlnd which will add new features.
Plugins may be developed in C and some already exist :</p>

<p>mysqlnd_qc : Query cache. This plugin allow you to cache SQL query resultsets into different backend and reuse them later. Why the hell do people reinvent such a system in PHP land ?</p>

<p>mysqlnd_ms : Master Slave balancer which is able to select the right server depending on the query sent. This is totally transparent to userland. Why the hell do people reinvent such a system in PHP land ?</p>

<p>mysqlnd_uh : UserHandler Hooks : Write your own plugin using PHP (and not C). Branch on different hooks into the low level mysqlnd layer, and implement whatever you want : SQL injection protections, load balancers, loggers, etc...</p>

<h2 id="conclusion">Conclusion<a href="#conclusion" class="anchor">#</a></h2>

<p>So, I hope you know have a better understanding on how PHP communicates with MySQL servers. I also hope you noticed how mysqlnd can help you implementing so many ideas, and how its licence allows you to do the same things you'd do using just PHP and the PHP licence.
Special thanks to Ulf Wendel, Andrey Hristov, Georg Richter and Johannes Schl&uuml;ter ; main mysqlnd creators.</p>]]></content>
    </entry>
    </feed>
