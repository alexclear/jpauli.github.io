<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Julien Pauli PHP&#039;s life</title>
    <subtitle></subtitle>
    <link href="http://jpauli.github.io//feed/index.atom" rel="self" />
    <link href="http://jpauli.github.io//" />
        <id>http://jpauli.github.io//</id>
            <updated>2015-03-24T00:00:00+00:00</updated>
            <entry>
        <title>Zoom on PHP objects and classes</title>
                <id>http://jpauli.github.io//2015/03/24/zoom-on-php-objects.html</id>
                <updated>2015-03-24T00:00:00+00:00</updated>
        <author>
            <name>Julien Pauli</name>
            <email>jpauli@php.net</email>
        </author>
        <link rel="alternate" type="text/html" href="http://jpauli.github.io//2015/03/24/zoom-on-php-objects.html"/>
        <content type="html" xml:lang="en"><![CDATA[<h2 id="php-objects-introduction">PHP objects introduction<a href="#php-objects-introduction" class="anchor">#</a></h2>
<p>Everybody uses objects nowadays. Something that was not that easy to bet on when PHP5 got released 10 years ago (2005).
I still remember this day, I wasn't involved in internals code yet, so I didn't know much things about how all this big machine
could work. But I had to note at this time, when using this new release of the language, that jumps had been made compared to old
PHP4.
The major point advanced for PHP5 adoption was : "it has a new very powerful object model". That wasn't lies.
Today, 10 years later, something like 90% of the PHP source code involving objects haven't changed since PHP5.0.
That shows how resulted this object model was when released. Sure it got improved through time, with new features especially.</p>
<p>Here, I will show you as usual how all this stuff works internally. The goal is always the same : you understand and master
what happens in the low level, to make a better usage of the language everyday.
Also, I will show you how memory usage has been really worked hard about objects, and how objects are nice about memory, compared
to equivalent arrays (when possible).</p>
<p>We will focus on PHP5, starting with PHP 5.4, for this article. The statements will be true for 5.5 and 5.6, which have changed
nearly nothing in object model internals. This is not the case of PHP 5.3, which has a less resulted object model, nice improvements (both in term of user features, and general performances) were added back in PHP 5.4.</p>
<p>About PHP7, which is still under heavy development nowadays, the object model has not been reworked deeply, only tidy up things on
surface. Why ? Because we don't need to : it works. Userland features were added, but here we don't care about those : only the
internal design (the truth) scores :-)</p>
<h2 id="starter-example">Starter example<a href="#starter-example" class="anchor">#</a></h2>
<p>Ok so let's start with some synthetic benchmarks to demonstrate things :</p>
<pre><code>class Foo {
    public $a = "foobarstring";
    public $b;
    public $c = ['some', 'values'];
}

for ($i=0; $i&lt;1000; $i++) {
    $m = memory_get_usage();
    ${'var'.$i} = new Foo;
    echo memory_get_usage() - $m"\n";
}</code></pre>
<p>This code declares a simple 3 attributes class, and then in a loop, it creates 1000 objects of this class, showing the memory usage diff
between allocations.</p>
<p>That are 262 bytes diff at every object creation. Creating an object of class Foo, plus creating a PHP variable to store the object into it, allocate 262 bytes in PHP heap memory.</p>
<p>Let's try now to turn this object into an equivalent array, some kind of :</p>
<pre><code>for ($i=0; $i&lt;1000; $i++) {
    $m = memory_get_usage();
    ${'var'.$i} = [['some', 'values'], null, 'foobarstring'];
    echo memory_get_usage() - $m . "\n";
}</code></pre>
<p>The array embeds the same values : an array, a null and a foobar string.
The difference between arrays creation is 1160 bytes : that is something like 4 to 5 times more memory eaten.</p>
<p>Let's do another quick bench :</p>
<pre><code>$class = &lt;&lt;&lt;'CL'
class Foo {
    public $a = "foobarstring";
    public $b;
    public $c = ['some', 'values'];
}
CL;
echo memory_get_usage() . "\n";
eval($class);
echo memory_get_usage() . "\n";</code></pre>
<p>As class declaration is honorred at compile time, we use an <code>eval()</code> statement to declare it at runtime and measure, with the PHP memory manager, its memory usage, just for it, we haven't created any object of it in this code.</p>
<p>The diff memory is 2216 bytes, aka about 2Kb.</p>
<p>Now, we are going to dive into PHP's sources to show you what happens, and to confirm our practice by some theory. </p>
<h2 id="it-all-begins-with-a-class">It all begins with a class...<a href="#it-all-begins-with-a-class" class="anchor">#</a></h2>
<p>A class is represented internally by the <em>zend_class_entry</em> structure. Here it is :</p>
<pre><code>struct _zend_class_entry {
    char type;
    const char *name;
    zend_uint name_length;
    struct _zend_class_entry *parent;
    int refcount;
    zend_uint ce_flags;

    HashTable function_table;
    HashTable properties_info;
    zval **default_properties_table;
    zval **default_static_members_table;
    zval **static_members_table;
    HashTable constants_table;
    int default_properties_count;
    int default_static_members_count;

    union _zend_function *constructor;
    union _zend_function *destructor;
    union _zend_function *clone;
    union _zend_function *__get;
    union _zend_function *__set;
    union _zend_function *__unset;
    union _zend_function *__isset;
    union _zend_function *__call;
    union _zend_function *__callstatic;
    union _zend_function *__tostring;
    union _zend_function *serialize_func;
    union _zend_function *unserialize_func;

    zend_class_iterator_funcs iterator_funcs;

    /* handlers */
    zend_object_value (*create_object)(zend_class_entry *class_type TSRMLS_DC);
    zend_object_iterator *(*get_iterator)(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC);
    int (*interface_gets_implemented)(zend_class_entry *iface, zend_class_entry *class_type TSRMLS_DC); /* a class implements this interface */
    union _zend_function *(*get_static_method)(zend_class_entry *ce, char* method, int method_len TSRMLS_DC);

    /* serializer callbacks */
    int (*serialize)(zval *object, unsigned char **buffer, zend_uint *buf_len, zend_serialize_data *data TSRMLS_DC);
    int (*unserialize)(zval **object, zend_class_entry *ce, const unsigned char *buf, zend_uint buf_len, zend_unserialize_data *data TSRMLS_DC);

    zend_class_entry **interfaces;
    zend_uint num_interfaces;

    zend_class_entry **traits;
    zend_uint num_traits;
    zend_trait_alias **trait_aliases;
    zend_trait_precedence **trait_precedences;

    union {
        struct {
            const char *filename;
            zend_uint line_start;
            zend_uint line_end;
            const char *doc_comment;
            zend_uint doc_comment_len;
        } user;
        struct {
            const struct _zend_function_entry *builtin_functions;
            struct _zend_module_entry *module;
        } internal;
    } info;
};</code></pre>
<p>Huge isn't it ? Its size, assuming an LP64 platform, is <strong>568 bytes</strong>.</p>
<blockquote>
<blockquote>
<p>Everytime PHP needs to declare a class, it must allocate a <em>zend_class_entry</em>, and that will raise its memory heap usage of barely half a kilobyte, just for the class structure, not talking about everything behind it.</p>
</blockquote>
</blockquote>
<p>And of course that is not finished, because like you can see, this zend_class_entry structure is full of pointers, that need to be allocated.</p>
<blockquote>
<blockquote>
<p>The first thing one may remember is that a PHP class (not a PHP object), is a "heavy" thing to store in memory.
In fact, classes are much more heavy in memory that related future objects to create from it.</p>
</blockquote>
</blockquote>
<p>Also, a class is not alone : it declares attributes (static or not, whatever), and methods.
Those will consume memory as well. For methods, the computation is not really easy to make, but obviously, the bigger the method body, the more memory this method will eat, because the bigger its OPArray will be. Also, static variables declared into a method (if any) will eat memory.</p>
<p>Then come the attributes. Those later will also allocate memory, depending on their default values : an integer will be light, but a big static array will eat more memory.</p>
<p>There is a last thing to take care of, which is detailed into the <em>zend_class_entry</em> source code as well : PHP comments.
PHP comments, also known as annotations, are strings, in C : char* buffers, and they need to be allocated and are really easy to compute, as in C, not using Unicode like PHP does : <strong>one character = one byte</strong>.</p>
<blockquote>
<blockquote>
<p>The more annotations you have in your class, the more memory will be eaten when the class will be parsed.</p>
</blockquote>
</blockquote>
<p>The <em>doc_comment</em> field is used, for <em>zend_class_entry</em>, it retains the class annotations. For methods : their structure also has a <em>doc_comment</em> field, and same for attributes.</p>
<h3 id="user-classes-vs-internal-classes">User classes VS internal classes<a href="#user-classes-vs-internal-classes" class="anchor">#</a></h3>
<p>Everybody spotted it : a user class is a class defined using PHP, an internal class in a class defined hacking PHP's source, or provided by any extension.</p>
<blockquote>
<blockquote>
<p>The biggest difference to know, is that user classes allocate request-bound memory whereas internal classes allocate "permanent" memory</p>
</blockquote>
</blockquote>
<p>That means that when PHP finishes to treat the actual web HTTP request, it will deallocate and destroy every user classes it knows, to leave the room blank for the next request. This is known as <em>the share nothing architecture</em>, this is how PHP has been designed since the begining, and there is no plan to change it.</p>
<p>So everytime you start a request and make PHP parse classes : it allocates memory for your class. Then you use your class, and then PHP destroys everything about it.
So you really should be sure to use every class you declared, if not : you are wasting memory.
Use an autoloader, because autoloaders delay class parsing/declaration at runtime, when PHP really needs, the class.
An autoloader will slow down runtime, but will be smart about your process memory usage, as it will not be triggered if the class is not actually really used.</p>
<p>This is not the case at all for internal classes : their memory is allocated permanently, weither or not they will ever be used, and they will only be destroyed when PHP itself will die : when it has finished treating the number of requests you asked it for (assuming web SAPI, like PHP-FPM f.e), usually, a PHP web worker treats several thousands of requests before dying.
That's a point why internal classes are more performant than user classes. (Only static attributes will be destroyed at the end of every request, nothing more).</p>
<pre><code>if (EG(full_tables_cleanup)) {
    zend_hash_reverse_apply(EG(function_table), (apply_func_t) clean_non_persistent_function_full TSRMLS_CC);
    zend_hash_reverse_apply(EG(class_table), (apply_func_t) clean_non_persistent_class_full TSRMLS_CC);
} else {
    zend_hash_reverse_apply(EG(function_table), (apply_func_t) clean_non_persistent_function TSRMLS_CC);
    zend_hash_reverse_apply(EG(class_table), (apply_func_t) clean_non_persistent_class TSRMLS_CC);
}

static int clean_non_persistent_class(zend_class_entry **ce TSRMLS_DC)
{
    return ((*ce)-&gt;type == ZEND_INTERNAL_CLASS) ? ZEND_HASH_APPLY_STOP : ZEND_HASH_APPLY_REMOVE;
}</code></pre>
<p>Note that even with an OPCode cache, like OPCache, class creation and destruction still happen at every request, about user declared classes. OPCache only speeds up those two steps.</p>
<p>So you have noted, if you activate many PHP extensions that each declare many classes, but you just use a small part of them : you are wasting memory as well.
Remember that PHP extensions declare their classes at the time PHP starts, even if in later requests to come those classes will not be used.
That's why we usually tell users to not keep enabled PHP extensions they just don't use : that's a pure memory waste, especially if the extension declares many classes (among other things extension may allocate as well).</p>
<h3 id="classes-interfaces-or-traits-are-all-the-same">Classes, interfaces or traits are all the same<a href="#classes-interfaces-or-traits-are-all-the-same" class="anchor">#</a></h3>
<p>PHP uses the same <em>zend_class_entry</em> structure internally to manage PHP classes, PHP interfaces and PHP traits.
So everytime you declare an interface or a trait, the <em>zend_class_entry</em> will be used as well.</p>
<blockquote>
<blockquote>
<p>Internally, PHP classes, interfaces and traits are managed by the exact same structure : <em>zend_class_entry</em></p>
</blockquote>
</blockquote>
<p>And as you've seen, the structure is heavy.
Sometimes in code, users declare interfaces to be able to use their name in PHP catch blocks. That allows them to catch one kind of exception only.
Something like this :</p>
<pre><code>interface BarException { }
class MyException extends Exception implements BarException { }

try {
    $foo-&gt;bar():
} catch (BarException $e) { }</code></pre>
<p>What is pitty here, is that nearly one kilobyte is used, just to declare the <em>BarException</em> interface. Exactly 912 bytes :</p>
<pre><code>$class = &lt;&lt;&lt;'CL'
interface Bar { }
CL;
$m = memory_get_usage();
eval($class);
echo memory_get_usage() - $m . "\n"; /* 912 bytes */</code></pre>
<p>I'm not telling it is bad, nor silly, I'm not blaming anyone nor anything. I just show you facts you perhaps were not aware of.</p>
<p>So remember, internally, classes and interfaces (and traits), are exactly used the same way. Simply, an interface will not be able to be added attributes, the PHP parser or compiler will forbid this to you, but the <em>zend_class_entry</em> structure is still used, just that its <em>static_members_table</em> and other fields will not be allocated pointers, that's all.</p>
<blockquote>
<blockquote>
<p>Declaring a class or an equivalent trait or equivalent interface, will barely use the same memory amount, as internally, those 3 concepts share the same structure.</p>
</blockquote>
</blockquote>
<h3 id="class-binding">Class binding<a href="#class-binding" class="anchor">#</a></h3>
<p>Class binding is a hidden thing PHP users are usually not aware of, until they wonder how things work.
This concept is yet really important to understand, we could define it as "the process that prepares a class and every piece of related data for it to be fully usable by the PHP user".</p>
<p>This process is very easy and cheap when we talk about a single class, that is a class not extending anyone, not using any trait, and not implementing any interface. The binding process for such class will be entirely done at compile time, that means that it will be very optimized and won't consume some PHP runtime.</p>
<p>Please, notice here that we're interested in the user declared class binding process. For internal classes, the same process is done when the classes are registered by PHP Core or PHP extensions, this happens very soon before the user scripts are run, and this happens only once in PHP lifetime.</p>
<blockquote>
<blockquote>
<p>Binding a single class is entirely done at compile time. On this point, performances tend to reach internal classes'.</p>
</blockquote>
</blockquote>
<p>Things become much more complicated when we talk about interfaces implementations, or class inheritance.
In such case, class binding will mainly copy every thing of interest from the parent to the child, would both be classes or interfaces. Let's see that :</p>
<pre><code>/* Single class */
case ZEND_DECLARE_CLASS:
    if (do_bind_class(CG(active_op_array), opline, CG(class_table), 1 TSRMLS_CC) == NULL) {
        return;
    }
    table = CG(class_table);
    break;</code></pre>
<p>In case of a simple class declaration, we run <code>do_bind_class()</code>. This function just registers the already-fully-defined class into the class table for further use at runtime, and performs checks about eventual abstract methods into it, like this :</p>
<pre><code>void zend_verify_abstract_class(zend_class_entry *ce TSRMLS_DC)
{
    zend_abstract_info ai;

    if ((ce-&gt;ce_flags &amp; ZEND_ACC_IMPLICIT_ABSTRACT_CLASS) &amp;&amp; !(ce-&gt;ce_flags &amp; ZEND_ACC_EXPLICIT_ABSTRACT_CLASS)) {
        memset(&amp;ai, 0, sizeof(ai));

        zend_hash_apply_with_argument(&amp;ce-&gt;function_table, (apply_func_arg_t) zend_verify_abstract_class_function, &amp;ai TSRMLS_CC);

        if (ai.cnt) {
            zend_error(E_ERROR, "Class %s contains %d abstract method%s and must therefore be declared abstract or implement the remaining methods (" MAX_ABSTRACT_INFO_FMT MAX_ABSTRACT_INFO_FMT MAX_ABSTRACT_INFO_FMT ")",
                ce-&gt;name, ai.cnt,
                ai.cnt &gt; 1 ? "s" : "",
                DISPLAY_ABSTRACT_FN(0),
                DISPLAY_ABSTRACT_FN(1),
                DISPLAY_ABSTRACT_FN(2)
                );
        }
    }
}</code></pre>
<p>Nothing to add, that was the easy case.</p>
<p>Now, things become more complicated about interface implementation, here are the task needed to be done to bind a class implementing an interface :</p>
<ul><li>Check if the interface is not already implemented</li>
<li>Check if the class that wants to implement the interface, is actually a class, and not an interface itself (remember that both are treated the same)</li>
<li>Copy the constants from interface into the class, checking possible collisions</li>
<li>Copy the methods from the interface into the class
<ol><li>Checking for possible collisions</li>
<li>Checking mismatch in declaration (turning an interface method into static in child class, f.e)</li>
</ol></li>
<li>Add the interface and all its possible mother interfaces to the interface list the class implements</li>
</ul><p>But take care, when we say "copy", this is not a full deep copy, constants, attributes and functions are all refcounted : the refcount is just incremented by one, meaning one more entity into memory is using the item.</p>
<blockquote>
<blockquote>
<p>Constants, attributes and functions are all refcounted</p>
</blockquote>
</blockquote>
<pre><code>ZEND_API void zend_do_implement_interface(zend_class_entry *ce, zend_class_entry *iface TSRMLS_DC)
{
    /* ... ... */

    } else {
        if (ce-&gt;num_interfaces &gt;= current_iface_num) {
            if (ce-&gt;type == ZEND_INTERNAL_CLASS) {
                ce-&gt;interfaces = (zend_class_entry **) realloc(ce-&gt;interfaces, sizeof(zend_class_entry *) * (++current_iface_num));
            } else {
                ce-&gt;interfaces = (zend_class_entry **) erealloc(ce-&gt;interfaces, sizeof(zend_class_entry *) * (++current_iface_num));
            }
        }
        ce-&gt;interfaces[ce-&gt;num_interfaces++] = iface;

        zend_hash_merge_ex(&amp;ce-&gt;constants_table, &amp;iface-&gt;constants_table, (copy_ctor_func_t) zval_add_ref, sizeof(zval *), (merge_checker_func_t) do_inherit_constant_check, iface);
        zend_hash_merge_ex(&amp;ce-&gt;function_table, &amp;iface-&gt;function_table, (copy_ctor_func_t) do_inherit_method, sizeof(zend_function), (merge_checker_func_t) do_inherit_method_check, ce);

        do_implement_interface(ce, iface TSRMLS_CC);
        zend_do_inherit_interfaces(ce, iface TSRMLS_CC);
    }
}</code></pre>
<p>Notice the difference between internal classes and user ones ? The former will use <code>realloc()</code> to allocate memory, while the later will use <code>erealloc()</code>. Like I said : <code>realloc()</code> will allocated "permanent" memory, whereas <code>erealloc()</code> will allocate "request-bound" memory, like said earlier.</p>
<p>So, you can see that when the two constant tables are merged (the interface one and the class one), <code>zval_add_ref</code> is used as merge callback : it will not copy the constant from one table to another, but share its pointer just adding a refcount.</p>
<p>For the functions tables (methods), <code>do_inherit_method</code> is run for any of them. Here it is :</p>
<pre><code>static void do_inherit_method(zend_function *function)
{
    function_add_ref(function);
}

ZEND_API void function_add_ref(zend_function *function)
{
    if (function-&gt;type == ZEND_USER_FUNCTION) {
        zend_op_array *op_array = &amp;function-&gt;op_array;

        (*op_array-&gt;refcount)++;
        if (op_array-&gt;static_variables) {
            HashTable *static_variables = op_array-&gt;static_variables;
            zval *tmp_zval;

            ALLOC_HASHTABLE(op_array-&gt;static_variables);
            zend_hash_init(op_array-&gt;static_variables, zend_hash_num_elements(static_variables), NULL, ZVAL_PTR_DTOR, 0);
            zend_hash_copy(op_array-&gt;static_variables, static_variables, (copy_ctor_func_t) zval_add_ref, (void *) &amp;tmp_zval, sizeof(zval *));
        }
        op_array-&gt;run_time_cache = NULL;
    }
}</code></pre>
<p>The function's OPArray is added a refcount, and every possible static variables declared in the function (which here is a method) is also copied, again also using <code>zval_add_ref</code>.</p>
<p>Thus, the overall copy process is heavy in term of CPU because it involves many loops and checks, but in term of memory usage, we are really kind here.
Unfortunately, the interface binding is nowadays fully delayed at runtime, and you will suffer from it at every request. I'm planning to change that soon.</p>
<p>When it comes to talk about inheritance, well, the process is barely the same as interface implementation, thus it is even more complicated because it involves more stuff.
What is interesting to note however, is that the binding is done at compile time if PHP already knows about the class, and in runtime for the opposite case</p>
<blockquote>
<blockquote>
<p>The inheritance binding is done at compile time if PHP already knows the parent class, and in runtime for the opposite case.</p>
</blockquote>
</blockquote>
<p>So you'd better declare things like this :</p>
<pre><code>/* good */
class A { }
class B extends A { }</code></pre>
<p>Instead of :</p>
<pre><code>/* bad */
class B extends A { }
class A { }</code></pre>
<p>Class binding routine can even lead to very strange behaviors, like :</p>
<pre><code>/* this code snippet works */
class B extends A { }
class A { }

/* this code snippet doesn't work :
Fatal error: Class 'B' not found */
class C extends B { }
class B extends A { }
class A { }</code></pre>
<p>I already explained such a case in <a href="http://jpauli.github.io/2015/02/05/zend-vm-executor.html">another article</a>.</p>
<p>In case one, the binding of class B is delayed at runtime, because when the compiler reaches the class B declaration, it knows nothing about A yet. When runtime fires, it binds the class to A and it finds A, because the compiler compiled A, as A is a single class, the compiler could take care of it entirely.</p>
<p>In case two, things are different. The binding of C is delayed at runtime, because the compiler knows nothing about B when it tries to compile B.
But when the runtime fires to bind C, it looks for B, which doesn't exist, because the compiler couldn't compile it neither, as B itself extends someone. "Class B doesn't exist" , end of story.</p>
<h2 id="then-come-objects">...then come objects<a href="#then-come-objects" class="anchor">#</a></h2>
<p>Ok, now you know several statements :</p>
<ul><li>Classes are heavy items in memory</li>
<li>Internal classes are more optimized than user classes, because those latter will need to be created/destroyed at every request, internal classes are permanent.</li>
<li>Classes, interfaces or traits use the exact same structure and same procedures, very little differences</li>
<li>When doing inheritance or implementations, the binding process is heavy and long for CPU, but light about memory usage as many things are shared and not duplicated. Also, you'd better have class binding fire at compile time</li>
</ul><p>Now let's talk about our objects.</p>
<p>Our first chapter showed that creating a "classical" object, of a "classical" user class (that is : there is nothing special in there), the object creation was very light in term of memory, something like a ridiculous amount of 200 bytes...</p>
<p>This, is because of the class.
The class itself has been compiled, and this latter eats memory; but that's for the good : this is to make every single object eat less memory</p>
<p>An object is in fact a ridiculously tiny set of tiny structures.</p>
<h3 id="object-methods-management">Object methods management<a href="#object-methods-management" class="anchor">#</a></h3>
<blockquote>
<blockquote>
<p>Methods and functions are exactly the same into the engine : a zend_function structure (union). This is just vocabulary ("method", "function").</p>
</blockquote>
</blockquote>
<p>Methods are represented by an union (zend_function). Methods are compiled by the PHP compiler, and added to the <em>function_table</em> attribute of the <em>zend_class_entry</em>. So at runtime every method is present, this is just a matter of fetching back its pointer to execute it.</p>
<pre><code>typedef union _zend_function {
    zend_uchar type;

    struct {
        zend_uchar type;
        const char *function_name;
        zend_class_entry *scope;
        zend_uint fn_flags;
        union _zend_function *prototype;
        zend_uint num_args;
        zend_uint required_num_args;
        zend_arg_info *arg_info;
    } common;

    zend_op_array op_array;
    zend_internal_function internal_function;
} zend_function;</code></pre>
<p>When an object tries to invoke a method, the engine by default, will lookup into the object's class function table to invoke it, and if the method doesn't exist, it will invoke the magic <code>__call()</code>. It will also check visibility (public/protected/private), and act accordingly :</p>
<pre><code>static union _zend_function *zend_std_get_method(zval **object_ptr, char *method_name, int method_len, const zend_literal *key TSRMLS_DC)
{
    zend_function *fbc;
    zval *object = *object_ptr;
    zend_object *zobj = Z_OBJ_P(object);
    ulong hash_value;
    char *lc_method_name;
    ALLOCA_FLAG(use_heap)

    if (EXPECTED(key != NULL)) {
        lc_method_name = Z_STRVAL(key-&gt;constant);
        hash_value = key-&gt;hash_value;
    } else {
        lc_method_name = do_alloca(method_len+1, use_heap);
        zend_str_tolower_copy(lc_method_name, method_name, method_len);
        hash_value = zend_hash_func(lc_method_name, method_len+1);
    }
    /* If the method is not found */
    if (UNEXPECTED(zend_hash_quick_find(&amp;zobj-&gt;ce-&gt;function_table, lc_method_name, method_len+1, hash_value, (void **)&amp;fbc) == FAILURE)) {
        if (UNEXPECTED(!key)) {
            free_alloca(lc_method_name, use_heap);
        }
        if (zobj-&gt;ce-&gt;__call) { /* if the class has got a __call() handler */
            return zend_get_user_call_function(zobj-&gt;ce, method_name, method_len); /* call the __call() handler */
        } else {
            return NULL; /* else return NULL, which will likely lead to a fatal error : method not found */
        }
    }

    /* Check access level */
    if (fbc-&gt;op_array.fn_flags &amp; ZEND_ACC_PRIVATE) {
        zend_function *updated_fbc;
        updated_fbc = zend_check_private_int(fbc, Z_OBJ_HANDLER_P(object, get_class_entry)(object TSRMLS_CC), lc_method_name, method_len, hash_value TSRMLS_CC);
        if (EXPECTED(updated_fbc != NULL)) {
            fbc = updated_fbc;
        } else {
            if (zobj-&gt;ce-&gt;__call) {
                fbc = zend_get_user_call_function(zobj-&gt;ce, method_name, method_len);
            } else {
                zend_error_noreturn(E_ERROR, "Call to %s method %s::%s() from context '%s'", zend_visibility_string(fbc-&gt;common.fn_flags), ZEND_FN_SCOPE_NAME(fbc), method_name, EG(scope) ? EG(scope)-&gt;name : "");
            }
        }
    } else {

    /* ... ... */
}</code></pre>
<p>You may spot an interesting thing, look at the first lines :</p>
<pre><code>if (EXPECTED(key != NULL)) {
        lc_method_name = Z_STRVAL(key-&gt;constant);
        hash_value = key-&gt;hash_value;
    } else {
        lc_method_name = do_alloca(method_len+1, use_heap);
        /* Create a zend_copy_str_tolower(dest, src, src_length); */
        zend_str_tolower_copy(lc_method_name, method_name, method_len);
        hash_value = zend_hash_func(lc_method_name, method_len+1);
    }</code></pre>
<p>This is PHP case insensibility. PHP must turn every function to lowercase (<code>zend_str_tolower_copy()</code>), before calling it. Not every function, there is an <code>if</code> statement. The <code>key</code> variable prevents the code from running the case lowering function (the <code>else</code> part), and this <code>key</code> is an optimization that has been added starting from PHP5.4. If the method call is not dynamic, the compiler has already computed the key, and the runtime will have less job to do.</p>
<pre><code>class Foo { public function BAR() { } }
$a = new Foo;
$b = 'bar';

$a-&gt;bar(); /* static call : good */
$a-&gt;$b(); /* dynamic call : bad */</code></pre>
<p>When the compiler compiles a function/method, it immediately lowercases it. The above function <code>BAR()</code> is turned into <code>bar()</code> by the compiler, when it adds the method to the class function table.</p>
<blockquote>
<blockquote>
<p>The compiler turns every function/method name to lowercase when it compiles it</p>
</blockquote>
</blockquote>
<p>When the call happens, on the example above, the first call is static : the compiler have computed the <code>key</code> for the string "bar", and then when it comes to run the method call, it has less job to do.
The second call above however, is dynamic; then the compiler knows nothing about "$b" : it can't compute a <code>key</code> for the method call, we will then fall into the <code>else</code> case at runtime, and we will have to both turn the string to lowercase, and to compute its hash (<code>zend_hash_func()</code>) at runtime, which is not especially what you're looking for if we talk about performances.</p>
<p>About <code>__call()</code>, it is not that bad about performances, there is however more work to do than calling an existing function though.</p>
<h3 id="object-attributes-management">Object attributes management<a href="#object-attributes-management" class="anchor">#</a></h3>
<p>Here is what happens :</p>
<p><img alt="PHP-objects-and-class-attributes" src="../../../img/php-objects/PHP-objects-and-class-attributes.png"></p>
<p>As you can see, when you create several objects of the same class, the engine will make every attribute point on the same pointer as the one defined into the class attributes.
The class stores the attributes, not only its own, static attributes, but also objects ones, for the life of the class : forever for internal classes, request bound lifetime for user classes. Creating an object does not involve creating its attributes, thus, that's a fast and memory saver approach.
Only at the time an object is going to change one of its attribute, the engine will create a new one and affect it, assuming you change the $a attribute on the object Foo #2 :</p>
<p><img alt="PHP-objects-cow" src="../../../img/php-objects/PHP-objects-cow.png"></p>
<p>So creating an object, is in fact "just" creating a <em>zend_object</em> structure, which weight 32 bytes :</p>
<pre><code>typedef struct _zend_object {
    zend_class_entry *ce;
    HashTable *properties;
    zval **properties_table;
    HashTable *guards; /* protects from __get/__set ... recursion */
} zend_object;</code></pre>
<p>And add this new <em>zend_object</em> to the object store. The object store is a <em>zend_object_store</em> structure : it is the global Zend Engine registry of objects, the place where in every object is stored exactly once :</p>
<pre><code>ZEND_API zend_object_value zend_objects_new(zend_object **object, zend_class_entry *class_type TSRMLS_DC)
{
    zend_object_value retval;

    *object = emalloc(sizeof(zend_object));
    (*object)-&gt;ce = class_type;
    (*object)-&gt;properties = NULL;
    (*object)-&gt;properties_table = NULL;
    (*object)-&gt;guards = NULL;

    /* Add the object into the store */
    retval.handle = zend_objects_store_put(*object, (zend_objects_store_dtor_t) zend_objects_destroy_object, (zend_objects_free_object_storage_t) zend_objects_free_object_storage, NULL TSRMLS_CC);

    retval.handlers = &amp;std_object_handlers;
    return retval;
}</code></pre>
<p>Then, the engine creates the properties vector of our object :</p>
<pre><code>ZEND_API void object_properties_init(zend_object *object, zend_class_entry *class_type)
{
    int i;

    if (class_type-&gt;default_properties_count) {
        object-&gt;properties_table = emalloc(sizeof(zval*) * class_type-&gt;default_properties_count);
        for (i = 0; i &lt; class_type-&gt;default_properties_count; i++) {
            object-&gt;properties_table[i] = class_type-&gt;default_properties_table[i];
            if (class_type-&gt;default_properties_table[i]) {
#if ZTS
                ALLOC_ZVAL( object-&gt;properties_table[i]);
                MAKE_COPY_ZVAL(&amp;class_type-&gt;default_properties_table[i], object-&gt;properties_table[i]);
#else
                Z_ADDREF_P(object-&gt;properties_table[i]);
#endif
            }
        }
        object-&gt;properties = NULL;
    }
}</code></pre>
<p>Like you can see, we allocate a pure C table/vector of <code>zval*</code> based on the object's class declared properties, and, in case of non thread safe PHP, we just add a refcount to the property, whereas using Zend thread safety (ZTS), we must deeply copy the zval.
That's one of the numerous point that confirms that ZTS mode is slower and more resource user than a non ZTS PHP.</p>
<blockquote>
<blockquote>
<p>PHP running with ZendThreadSafety activated (ZTS) is both slower and less memory friendly than a non-ZTS PHP.</p>
</blockquote>
</blockquote>
<p>Now you wonder two things :</p>
<ul><li>What's the difference bewteen <em>properties_table</em> and <em>properties</em> in the <em>zend_object</em> structure ?</li>
<li>If we affected our object's attributes in a C vector, how will we fetch them back ? Browser the vector every time ? (counter-performant)</li>
</ul><p>The answer to both those questions relies in a clever trick : <em>zend_property_info</em>.</p>
<p>Here is <em>zend_property_info</em> :</p>
<pre><code>typedef struct _zend_property_info {
    zend_uint flags;
    const char *name;
    int name_length;
    ulong h;
    int offset;
    const char *doc_comment;
    int doc_comment_len;
    zend_class_entry *ce;
} zend_property_info;</code></pre>
<p>Every <strong>declared</strong> attribute(property) of an object has a corresponding property info that has been added to its <em>zend_class_entry</em>, into the <em>property_info</em> field. The compiler created this when it compiled the declared attributes in the class :</p>
<pre><code>class Foo
{
    public $a = 'foo';
    protected $b;
    private $c;
}
struct _zend_class_entry {
        /* ... ... */
        HashTable function_table;
        HashTable properties_info; /* here are the properties infos about $a, $b and $c */
        zval **default_properties_table; /* and here, we'll find $a, $b and $c with their default values */
        int default_properties_count; /* this will have the value of 3 : 3 properties */
        /* ... ... */</code></pre>
<p>The <em>properties_infos</em> is a table that will both tell the object if the attribute it asks access for exists, and if it exists, what is its index number in the <em>object-&gt;properties</em> pure C array. Clever and fast way of accessing attributes.
If the attribute doesn't exist, and if we try to write into it : we try to call <code>__set()</code> if possible, if not, we create a dynamic attribute, and this one will be stored into <em>object-&gt;property_table</em> field. If the attribute exists, we then check the visibility and scope access (public/protected/private).</p>
<pre><code>property_info = zend_get_property_info_quick(zobj-&gt;ce, member, (zobj-&gt;ce-&gt;__set != NULL), key TSRMLS_CC);

if (EXPECTED(property_info != NULL) &amp;&amp;
    ((EXPECTED((property_info-&gt;flags &amp; ZEND_ACC_STATIC) == 0) &amp;&amp;
     property_info-&gt;offset &gt;= 0) ?
        (zobj-&gt;properties ?
            ((variable_ptr = (zval**)zobj-&gt;properties_table[property_info-&gt;offset]) != NULL) :
            (*(variable_ptr = &amp;zobj-&gt;properties_table[property_info-&gt;offset]) != NULL)) :
        (EXPECTED(zobj-&gt;properties != NULL) &amp;&amp;
          EXPECTED(zend_hash_quick_find(zobj-&gt;properties, property_info-&gt;name, property_info-&gt;name_length+1, property_info-&gt;h, (void **) &amp;variable_ptr) == SUCCESS)))) {
/* ... ... */
} else {
    zend_guard *guard = NULL;
        if (zobj-&gt;ce-&gt;__set &amp;&amp; /* class has a __set() ? */
        zend_get_property_guard(zobj, property_info, member, &amp;guard) == SUCCESS &amp;&amp;
        !guard-&gt;in_set) {
        Z_ADDREF_P(object);
        if (PZVAL_IS_REF(object)) {
            SEPARATE_ZVAL(&amp;object);
        }
        guard-&gt;in_set = 1; /* prevent circular setting */
        if (zend_std_call_setter(object, member, value TSRMLS_CC) != SUCCESS) { /* call __set() */
        }
        guard-&gt;in_set = 0;
        zval_ptr_dtor(&amp;object);
    /* ... ... */</code></pre>
<p>So, until you write to your object, its memory consumption will not vary. When you write to it, you start making it bigger, as it will retain the attributes you wrote into it, until it dies.</p>
<h2 id="objects-acting-as-references-thanks-to-the-object-store">Objects acting as references, thanks to the object store<a href="#objects-acting-as-references-thanks-to-the-object-store" class="anchor">#</a></h2>
<p>Objects are not references. I demonstrate it in a small script :</p>
<pre><code>function foo($var) {
    $var = 42;
}
$o = new MyClass;
foo($o);
var_dump($o); /* this is still an object, not the integer 42 */</code></pre>
<p>Everybody says that "objects are references in PHP5", even the official manual sometimes suggests this ;-) This is horribly wrong technically.
However, objects borrow references behavior, as when you pass a variable which is an object to a function, this function can modify the same object.</p>
<blockquote>
<blockquote>
<p>Objects are <strong>not</strong> passed by references, this is <strong>wrong</strong>. However, they borrow the same behavior as PHP variables references.</p>
</blockquote>
</blockquote>
<p>This is because in the zval you pass to the function, you don't pass an object precisely, but its unique identifier, that will serve to look it up into the global object store, thus effectively leading to the same object at the end.
You can end up having 3 different zvals in memory, they can all store into them the same object handle, and then they will lead to the same object into memory.</p>
<pre><code>object(MyClass)#1 (0) { } /* #1 is the object handle (number), it is unique */</code></pre>
<p><img alt="PHP-objects-zvals" src="../../../img/php-objects/PHP-objects-zvals.png"></p>
<p>So you carry in your variables the same object handle, and then it will lead to the same object.
The <em>zend_object_store</em> takes care of memorizing objects only once in memory. The only way to write into the store, is to create a new object, weither with the <code>new</code> keyword, the <code>unserialize()</code> function, the reflection API or the <code>clone</code> keyword. Every other operation will never duplicate or create a new object into the store.</p>
<pre><code>typedef struct _zend_objects_store {
    zend_object_store_bucket *object_buckets;
    zend_uint top;
    zend_uint size;
    int free_list_head;
} zend_objects_store;

typedef struct _zend_object_store_bucket {
    zend_bool destructor_called;
    zend_bool valid;
    zend_uchar apply_count;
    union _store_bucket {
        struct _store_object {
            void *object;
            zend_objects_store_dtor_t dtor;
            zend_objects_free_object_storage_t free_storage;
            zend_objects_store_clone_t clone;
            const zend_object_handlers *handlers;
            zend_uint refcount;
            gc_root_buffer *buffered;
        } obj;
        struct {
            int next;
        } free_list;
    } bucket;
} zend_object_store_bucket;</code></pre>
<h2 id="what-is-this">What is $this ?<a href="#what-is-this" class="anchor">#</a></h2>
<p>You know <code>$this</code> from PHP. Internally, <code>$this</code> is not very complex to understand, but there is code related to it in several parts of the engine, in fact, at every needed stage : at compile time, in execution time variable fetching code, etc...
As <code>$this</code> is "magical", appears and disappears when it has to, automaticaly owns the current object, then that means that internal code to manage <code>$this</code> does everything for you. Let's have a look.</p>
<p>First, the compiler will forbid you to write to <code>$this</code>. For that, it checks every assignation you try to do, and if you assign <code>$this</code>, you'll generate a fatal error.</p>
<pre><code>/* ... ... */
 if (opline_is_fetch_this(last_op TSRMLS_CC)) {
    zend_error(E_COMPILE_ERROR, "Cannot re-assign $this");
}
/* ... ... */

static zend_bool opline_is_fetch_this(const zend_op *opline TSRMLS_DC)
{
    if ((opline-&gt;opcode == ZEND_FETCH_W) &amp;&amp; (opline-&gt;op1_type == IS_CONST)
        &amp;&amp; (Z_TYPE(CONSTANT(opline-&gt;op1.constant)) == IS_STRING)
        &amp;&amp; ((opline-&gt;extended_value &amp; ZEND_FETCH_STATIC_MEMBER) != ZEND_FETCH_STATIC_MEMBER)
        &amp;&amp; (Z_HASH_P(&amp;CONSTANT(opline-&gt;op1.constant)) == THIS_HASHVAL)
        &amp;&amp; (Z_STRLEN(CONSTANT(opline-&gt;op1.constant)) == (sizeof("this")-1))
        &amp;&amp; !memcmp(Z_STRVAL(CONSTANT(opline-&gt;op1.constant)), "this", sizeof("this"))) {
        return 1;
    } else {
        return 0;
    }
}</code></pre>
<p>You can trick that by many ways, thus it is useless to do so ;-)</p>
<p>Now how is <code>$this</code> managed ?
When you call a method, which is the only place where you are allowed to use <code>$this</code>, the compiler emits an <code>INIT_METHOD_CALL</code> OPCode.
You can read <a href="http://jpauli.github.io/2015/01/22/on-php-function-calls.html">On PHP function calls</a> or <a href="http://jpauli.github.io/2015/02/05/zend-vm-executor.html">getting into the Zend execution engine</a> about OPCodes for functions.
In the <code>INIT_METHOD_CALL</code>, the engine knows who is calling the method, for <code>$a-&gt;foo()</code> : it is <code>$a</code>.
It then fetches <code>$a</code>'s value, and memorize it in a global space. Then, it calls the method, issuing a <code>DO_FCALL</code> OPCode. In this OPcode, we fetch back the value memorized (the object calling the method), and we assign it to the internally-global <code>$this</code> pointer : <code>EG(This)</code> :</p>
<pre><code>if (fbc-&gt;type == ZEND_USER_FUNCTION || fbc-&gt;common.scope) {
    should_change_scope = 1;
    EX(current_this) = EG(This);
    EX(current_scope) = EG(scope);
    EX(current_called_scope) = EG(called_scope);
    EG(This) = EX(object); /* fetch the object prepared in previous INIT_METHOD opcode and affect it to EG(This) */
    EG(scope) = (fbc-&gt;type == ZEND_USER_FUNCTION || !EX(object)) ? fbc-&gt;common.scope : NULL;
    EG(called_scope) = EX(call)-&gt;called_scope;
}</code></pre>
<p>Now, when the method is called, if you use <code>$this</code> in its body to affect a variable or call a method, like <code>$this-&gt;a = 8</code>, that leads to the <code>ZEND_ASSIGN_OBJ</code> OPCode, that fetches back <code>$this</code> from <code>EG(This)</code>.</p>
<pre><code>static zend_always_inline zval **_get_obj_zval_ptr_ptr_unused(TSRMLS_D)
{
    if (EXPECTED(EG(This) != NULL)) {
        return &amp;EG(This);
    } else {
        zend_error_noreturn(E_ERROR, "Using $this when not in object context");
        return NULL;
    }
}</code></pre>
<p>In case you were using <code>$this</code> to issue a method call like <code>$this-&gt;foo()</code>, or to pass <code>$this</code> to another function call like <code>$this-&gt;foo($this);</code> the engine will try to fetch <code>$this</code> from the current symbol table, like it does for every standard variable.
But this one has been specially prepared, when the current function stack frame has been built :</p>
<pre><code>if (op_array-&gt;this_var != -1 &amp;&amp; EG(This)) {
     Z_ADDREF_P(EG(This));
    if (!EG(active_symbol_table)) {
        EX_CV(op_array-&gt;this_var) = (zval **) EX_CV_NUM(execute_data, op_array-&gt;last_var + op_array-&gt;this_var);
        *EX_CV(op_array-&gt;this_var) = EG(This);
    } else {
        if (zend_hash_add(EG(active_symbol_table), "this", sizeof("this"), &amp;EG(This), sizeof(zval *), (void **) EX_CV_NUM(execute_data, op_array-&gt;this_var))==FAILURE) {
            Z_DELREF_P(EG(This));
        }
    }
}</code></pre>
<p>Last thing : the scopes.
When we call a method, the engine changes the scope :</p>
<pre><code>if (fbc-&gt;type == ZEND_USER_FUNCTION || fbc-&gt;common.scope) {
    /* ... ... */
    EG(scope) = (fbc-&gt;type == ZEND_USER_FUNCTION || !EX(object)) ? fbc-&gt;common.scope : NULL;
    /* ... ... */
}</code></pre>
<p><code>EG(scope)</code> is of type <code>zend_class_entry</code> : this is the class the method you ask for belongs to, and this one will be used for whatever object operation you will now perform into the method body; when the engine checks the visibility :</p>
<pre><code>static zend_always_inline int zend_verify_property_access(zend_property_info *property_info, zend_class_entry *ce TSRMLS_DC)
{
    switch (property_info-&gt;flags &amp; ZEND_ACC_PPP_MASK) {
        case ZEND_ACC_PUBLIC:
            return 1;
        case ZEND_ACC_PROTECTED:
            return zend_check_protected(property_info-&gt;ce, EG(scope));
        case ZEND_ACC_PRIVATE:
            if ((ce==EG(scope) || property_info-&gt;ce == EG(scope)) &amp;&amp; EG(scope)) {
                return 1;
            } else {
                return 0;
            }
            break;
    }
    return 0;
}</code></pre>
<p>That's why you can access private members of objects that are not yours, but descendant of your current scope :</p>
<pre><code>class A
{
    private $a;

    public function foo(A $obj)
    {
        $this-&gt;a = 'foo';
        $obj-&gt;a  = 'bar'; /* yes, this is possible */
    }
}

$a = new A;
$b = new A;
$a-&gt;foo($b);</code></pre>
<p>This strangeness has lead to many bugs reported by users, but that's the rule in PHP object model : we don't actually define an object based scope, but a class based scope.
So in a class "Foo", you can play with every private of every other eventual "Foo" , not only yourself, like the above example demonstrates.</p>
<blockquote>
<blockquote>
<p>PHP's object model scope is class based, not object based.</p>
</blockquote>
</blockquote>
<h2 id="on-destructors">On destructors<a href="#on-destructors" class="anchor">#</a></h2>
<p>Destructors are dangerous. Don't rely on them, because PHP will even not call them in case of fatal errors :</p>
<pre><code>class Foo { public function __destruct() { echo "byebye foo"; } }
$f = new Foo;
thisfunctiondoesntexist();
/* fatal error, function not found, the Foo's destructor is NOT run */</code></pre>
<p>And how about the order the destructors are called, when are they called ?
The rule is clear into the source code :</p>
<pre><code>void shutdown_destructors(TSRMLS_D)
{
    zend_try {
        int symbols;
        do {
            symbols = zend_hash_num_elements(&amp;EG(symbol_table));
            zend_hash_reverse_apply(&amp;EG(symbol_table), (apply_func_t) zval_call_destructor TSRMLS_CC);
        } while (symbols != zend_hash_num_elements(&amp;EG(symbol_table)));
        zend_objects_store_call_destructors(&amp;EG(objects_store) TSRMLS_CC);
    } zend_catch {
        /* if we couldn't destruct cleanly, mark all objects as destructed anyway */
        zend_objects_store_mark_destructed(&amp;EG(objects_store) TSRMLS_CC);
    } zend_end_try();
}

static int zval_call_destructor(zval **zv TSRMLS_DC)
{
    if (Z_TYPE_PP(zv) == IS_OBJECT &amp;&amp; Z_REFCOUNT_PP(zv) == 1) {
        return ZEND_HASH_APPLY_REMOVE;
    } else {
        return ZEND_HASH_APPLY_KEEP;
    }
}</code></pre>
<p>As you can see, this is a three step destructor calling strategy :</p>
<ul><li>Loop backwards the global symbol table and call destructors for objects where refcount = 1</li>
<li>Then loop forward the global symbol table and call destructors for all the other objects (refcount &gt; 1)</li>
<li>If a problem happens in step 1 or 2, stop calling the remaining destructors</li>
</ul><p>So, that leads to those behaviors :</p>
<pre><code>class Foo { public function __destruct() { var_dump("destroyed Foo"); } }
class Bar { public function __destruct() { var_dump("destroyed Bar"); } }</code></pre>
<p>Case 1 :</p>
<pre><code>$a = new Foo;
$b = new Bar;
"destroyed Bar"
"destroyed Foo"</code></pre>
<p>Case 1 again :</p>
<pre><code>$a = new Bar;
$b = new Foo;
"destroyed Foo"
"destroyed Bar"</code></pre>
<p>Case 2 :</p>
<pre><code>$a = new Bar;
$b = new Foo;
$c = $b; /* increment $b's object refcount */
"destroyed Bar"
"destroyed Foo"</code></pre>
<p>Case 3 :</p>
<pre><code>class Foo { public function __destruct() { var_dump("destroyed Foo"); die();} } /* notice the die() here */
class Bar { public function __destruct() { var_dump("destroyed Bar"); } }

$a = new Foo;
$a2 = $a;
$b = new Bar;
$b2 = $b;

destroyed Foo</code></pre>
<p>This procedure has not been randomly chosen. We do things this way, to be extra sure about everything.
You don't like it ? Destroy your own objects by yourself ! This is the only way to master <code>__destruct()</code> calls. If you leave PHP destroy your objects for you, don't come complaining about the procedure that has been matured for years, you always have the choice of destroying yourself your objects, to master the order of destructs (I tell this because here again, we've been filled tons of bug reports about PHP objects destructors beeing called "strangely").</p>
<p>However, in case of any fatal error, PHP will not call any destructor, because a fatal error is likely to have left the Zend Engine in an unstable state, and calling destructors will run user code that may access pointers that are invalid now, and then crash PHP.
We prefer having something stable, and thus we chose not to call destructors in such cases. Things could change in PHP7 about that.</p>
<blockquote>
<blockquote>
<p>In case of fatal error, PHP will not call any destructor</p>
</blockquote>
</blockquote>
<p>About recursion also : PHP has not many recursion protection. The only ones that exist are about <code>__get()</code> and <code>__set()</code>.
If you happen, somewhere in the stack frame of your destructor, to destroy an object of your own : you'll find yourself into an infinite recursion loop that will exaust your process stack size (usually 8Kb, <em>ulimit -s</em>), and crash PHP.</p>
<pre><code>class Foo
{
    public function __destruct() { new Foo; } /* you will crash */
}</code></pre>
<p>So, to sum up things in short : do not put critical code into destructors, such as lock mechanism management, because PHP could not call your destructor, or call in an order that's hard to master. If you have critical code in destructors, and rely on them, then manage your objects lifetime by yourself, PHP will call your destructor when your object's refcount falls down to zero, meaning the object is not used anywhere else, and it is safe now to destroy it.</p>
<h2 id="end">End<a href="#end" class="anchor">#</a></h2>
<p>Here we are for PHP object model internal design tour. I hope you have a better glance of what happens when you manipulate objects everyday in PHP. Objects are light in term of memory, and their handling is very optimized into the engine. Feel free to use them. Use a well designed autoloader to boost your memory usage, declare your classes in the logical inheritance order, and if you can turn some of the most complex ones into C extensions, you'll be able to optimize many things and increase even more the overall performances of such classes.</p>]]></content>
    </entry>
        <entry>
        <title>PHP&#039;s OPCache extension review</title>
                <id>http://jpauli.github.io//2015/03/05/opcache.html</id>
                <updated>2015-03-05T00:00:00+00:00</updated>
        <author>
            <name>Julien Pauli</name>
            <email>jpauli@php.net</email>
        </author>
        <link rel="alternate" type="text/html" href="http://jpauli.github.io//2015/03/05/opcache.html"/>
        <content type="html" xml:lang="en"><![CDATA[<h2 id="reminder-on-opcodes-caches">Reminder on OPCodes caches<a href="#reminder-on-opcodes-caches" class="anchor">#</a></h2>
<p>PHP is a scripting language, that by default will compile any file you ask it to run, obtain <a href="http://jpauli.github.io/2015/02/05/zend-vm-executor.html">OPCodes</a> from compilation, run them, and trash them away immediately.
PHP has been designed like that : it "forgets" everything it's done in request R-1, when it comes to run request R.</p>
<p>On production servers, the PHP code is very unlikely to change between several requests, thus, the compilation step will always read the same source code, leading to the very exact same OPCode to be run. This is a big waste of time and resources, as the PHP compiler is invoked for every request, for every script.</p>
<p><img alt="php-compile-execute-process" src="../../../img/opcache/php-compile-execute-process.png"></p>
<p>Knowing that compilation can really take a lot of time, OPCode cache extensions have been designed. Their main goal is to <strong>compile once and only once</strong> each PHP script, and cache the resulting OPCodes into shared memory, so that every other PHP worker of your production worker pool (usually using PHP-FPM) can make use of the OPCodes by reading then and executing then back.</p>
<p>The result is a massive boost in overall performance of the language, dividing time to run a script by a factor of at least 2 (very depend on the script), usually more than 2, as PHP now doesn't have to compile again and again the same PHP scripts.</p>
<p>The boost is higher as the application is more complex. If you take applications running tons of files, like framework based applications, or products like wordpress, you will experience a factor of 10 or so. This is because the PHP compiler is slow, and this is just a normal situation : a compiler is slow, whatever it is, because its work is to turn a syntax into another, trying to understand what you asked, and somehow to optimize the generated code ; so yes, compiling a PHP script is really slow. Profilers like <a href="https://blackfire.io">Blackfire</a> allows you to know the compile time.</p>
<p><img alt="compile-time" src="../../../img/opcache/compile-execute.png"></p>
<h2 id="introducing-opcache">Introducing OPCache<a href="#introducing-opcache" class="anchor">#</a></h2>
<p>OPCache has been opensourced by its authors : Zend, back in 2013, to be bundled into PHP's source starting from PHP 5.5.
It has thus become a standard for PHP OPcode cache solutions. There exists other solutions, such as XCache, APC, Eaccelerator and others. I will not talk about those other solutions, as I myself don't know them except APC : APC support has been discontinued in favor of OPCache. Short : if you were using APC before, please, use OPCache now.
<strong>OPCache has become the real official recommanded OPCode cache solution by the PHPGroup</strong>. You may still use other solutions if you want, however, <strong>never ever activate more than one OPCode cache extension at the same time</strong> : you will likely crash PHP.</p>
<p>OPCache is compatible for PHP from PHP 5.2 to PHP 7.0 (actually under development) and is bundled into PHP distribution starting from PHP 5.5.0
Be aware that new development involving OPCache won't target PHP5 branch, but PHP7 branch.
For PHP5, nowadays, OPCache is pretty mature and stable, so we don't add big new features to it, but try to keep it as stable and bug free as possible. <em>This article will target OPCache for PHP5 branches</em>.</p>
<p>So OPCache is an extension, a <em>zend_extension</em> more precisely, which is shipped into the PHP source code, starting from PHP 5.5.0 (Pecl for others), and that must be activated through the normal php.ini process of activating an extension. For distros, please refer to your distribution manual to know how PHP and OPCache have been bundled.</p>
<h3 id="two-features-into-one-product">Two features into one product<a href="#two-features-into-one-product" class="anchor">#</a></h3>
<p>OPCache is an extension which provides two main features :</p>
<ul><li>OPCodes caching</li>
<li>OPCodes optimization</li>
</ul><p>Because OPCache triggers the PHP compiler, to get OPCodes and cache them, it could use this step to optimize the OPCodes.
Optimizations are basically about compiler optimizations, and share many concepts of this computer science discipline. OPCache optimizer is a multi pass compiler optimizer.</p>
<p><img alt="php-compile-execute-process" src="../../../img/opcache/cache-optimization-steps.png"></p>
<h2 id="opcache-in-deep">OPCache in deep<a href="#opcache-in-deep" class="anchor">#</a></h2>
<p>Let's now see together how OPCache works internally. If you want to follow the code, you can fetch it from the PHP source code, <a href="http://lxr.php.net/xref/PHP_5_6/ext/opcache/">here it is for PHP 5.6</a>.</p>
<p>Unlike what you can think, OPCode caching is not a that hard concept to analyze and understand. You must have a good knowledge on how the Zend Engine works and has been designed, then you should start spotting places where the job can be done.</p>
<h3 id="shared-memory-models">Shared memory models<a href="#shared-memory-models" class="anchor">#</a></h3>
<p>As you know, there exists many shared memory models under the different Operating Systems. I myself ignore many things about Windows, we'll then talk about Unix systems.
Under modern Unixes, there exist several ways of sharing memory through processes :</p>
<ul><li>System-V shm API</li>
<li>POSIX API</li>
<li>mmap API</li>
</ul><p>OPCache is able to use any of them, as soon as your OS supports the layer. The INI setting <em>opcache.preferred_memory_model</em> allows you to explicitly select the memory model you want.
If you leave the parameter to NULL, OPCache will select the first model which works for your platform, iterating through its table :</p>
<pre><code>static const zend_shared_memory_handler_entry handler_table[] = {
#ifdef USE_MMAP
    { "mmap", &amp;zend_alloc_mmap_handlers },
#endif
#ifdef USE_SHM
    { "shm", &amp;zend_alloc_shm_handlers },
#endif
#ifdef USE_SHM_OPEN
    { "posix", &amp;zend_alloc_posix_handlers },
#endif
#ifdef ZEND_WIN32
    { "win32", &amp;zend_alloc_win32_handlers },
#endif
    { NULL, NULL}
};</code></pre>
<p>So by default, "mmap" should be used. It's a nice memory model, however it is less informative to sysadmin that System-V SHM model is, and its <code>ipcs</code> and <code>ipcrm</code> commands.</p>
<p>As soon as OPCache starts (as soon as PHP starts), OPCache will try a shared memory model, and will allocate one big memory segment that it will then shrink and manage on its side. However, it will never free this segment back, nor will it try to resize it.</p>
<blockquote>
<p>OPCache allocates one segment of shared memory when PHP starts, once for all, and never frees it nor fragments it.</p>
</blockquote>
<p>The size of the memory segment can be told using the <em>opcache.memory_consumption</em> INI setting (Megabytes). Size it big, don't hesitate to give space. <strong>Never ever run out of shared memory space</strong>, if you do, you will lock your processes, we'll get back to that later.</p>
<p>Size the shared memory segment according to your needs, don't forget that a production server dedicated to PHP processes may bundle several dozens of Gigabytes of memory, just for PHP. Having a 1Gb shared memory segment (or more) is not uncommon, it will depend on your needs.</p>
<p>The shared memory segment will be used for several things in OPCache :</p>
<ul><li>Script's datastructure caching, involving obviously OPCodes caching but not only</li>
<li>Shared interned strings buffer</li>
<li>Cached scripts HashTable</li>
<li>Global OPCache shared memory state</li>
</ul><p>So remember, the shared memory segment size will not only contain raw OPCodes, but other things needed for OPCache internals.
Measure on your side and size it accordingly.</p>
<p><img alt="opcache-shm" src="../../../img/opcache/opcache-shm.png"></p>
<h3 id="opcodes-caching">OPCodes caching<a href="#opcodes-caching" class="anchor">#</a></h3>
<p>Here we go to detail how the caching mechanism works.</p>
<p>The overall idea is to copy into shared memory (shm) every pointer data that will vary from request to request.
After, once loading back the same script : restore every pointer data from shared memory to standard process memory, tied to the current request.
When the PHP compiler is working, it uses Zend Memory Manager to allocate every pointer. This kind of memory used is request bound, and Zend Memory Manager will automaticaly attempt to free it as soon as the current request finishes. OPCache's job is to browse every structure returned by the PHP compiler, and not leave one single pointer allocated onto this pool, but copy it into a shared memory allocated pool.</p>
<p>This memory model is used to prevent locks at maximum. We'll go back to locks in a later subject, but basically, OPCache does its job all at once, before runtime, so that during the runtime of the script, OPCache has nothing more to do.</p>
<p>OPCache hooks into the compiler, and replaces the structure this latter should fill-in while compiling PHP scripts, by its own.
It then makes the compiler fills a persistent_script structure, instead of it filling directly the Zend Engine tables and internal structures.</p>
<p>Here is a <code>persistent_script</code> structure :</p>
<pre><code>typedef struct _zend_persistent_script {
    ulong          hash_value;
    char          *full_path;              /* full real path with resolved symlinks */
    unsigned int   full_path_len;
    zend_op_array  main_op_array;
    HashTable      function_table;
    HashTable      class_table;
    long           compiler_halt_offset;   /* position of __HALT_COMPILER or -1 */
    int            ping_auto_globals_mask; /* which autoglobals are used by the script */
    accel_time_t   timestamp;              /* the script modification time */
    zend_bool      corrupted;
#if ZEND_EXTENSION_API_NO &lt; PHP_5_3_X_API_NO
    zend_uint      early_binding;          /* the linked list of delayed declarations */
#endif

    void          *mem;                    /* shared memory area used by script structures */
    size_t         size;                   /* size of used shared memory */

    /* All entries that shouldn't be counted in the ADLER32
     * checksum must be declared in this struct
     */
    struct zend_persistent_script_dynamic_members {
        time_t       last_used;
        ulong        hits;
        unsigned int memory_consumption;
        unsigned int checksum;
        time_t       revalidate;
    } dynamic_members;
} zend_persistent_script;</code></pre>
<p>And here is how OPCache replaces the compiler structure by the persistent_script ones :</p>
<pre><code>new_persistent_script = create_persistent_script();

/* Save the original values for the op_array, function table and class table */
orig_active_op_array = CG(active_op_array);
orig_function_table = CG(function_table);
orig_class_table = CG(class_table);
orig_user_error_handler = EG(user_error_handler);

/* Override them with ours */
CG(function_table) = &amp;ZCG(function_table);
EG(class_table) = CG(class_table) = &amp;new_persistent_script-&gt;class_table;
EG(user_error_handler) = NULL;

zend_try {
#if ZEND_EXTENSION_API_NO &gt;= PHP_5_3_X_API_NO
    orig_compiler_options = CG(compiler_options);
    CG(compiler_options) |= ZEND_COMPILE_HANDLE_OP_ARRAY;
    CG(compiler_options) |= ZEND_COMPILE_IGNORE_INTERNAL_CLASSES;
    CG(compiler_options) |= ZEND_COMPILE_DELAYED_BINDING;
    CG(compiler_options) |= ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION;
#endif
    op_array = *op_array_p = accelerator_orig_compile_file(file_handle, type TSRMLS_CC); /* Trigger PHP compiler */
#if ZEND_EXTENSION_API_NO &gt;= PHP_5_3_X_API_NO
    CG(compiler_options) = orig_compiler_options;
#endif
} zend_catch {
    op_array = NULL;
    do_bailout = 1;
#if ZEND_EXTENSION_API_NO &gt;= PHP_5_3_X_API_NO
    CG(compiler_options) = orig_compiler_options;
#endif
} zend_end_try();

/* Restore originals */
CG(active_op_array) = orig_active_op_array;
CG(function_table) = orig_function_table;
EG(class_table) = CG(class_table) = orig_class_table;
EG(user_error_handler) = orig_user_error_handler;</code></pre>
<p>As we can see, the PHP compiler is fully isolated and disconnected from the tables it usually fills : it will now fill the persistent_script structures. Then OPCache will have to browse those structures, and replace request allocated pointers to shm ones. OPCache is interested in :</p>
<ul><li>The script functions</li>
<li>The script classes</li>
<li>The script main OPArray</li>
<li>The script path</li>
<li>The script structure itself</li>
</ul><p><img alt="opcache-shm-detailed" src="../../../img/opcache/opcache-shm-detailed.png"></p>
<p>The compiler is also told some options to disable some optimizations it does, like <code>ZEND_COMPILE_NO_CONSTANT_SUBSTITUTION</code> and <code>ZEND_COMPILE_DELAYED_BINDING</code>. That would add more work to OPCache. Remember that OPCache hooks into the Zend Engine, it is not a source code patch.</p>
<p>Now that we have a persitent_script structure, we must cache its informations. Remember that the PHP Compiler has filled-in our structures, but it allocated the memory behind this using the Zend Memory Manager : this memory will be freed at the end of the current request. We then need to browse this memory, and copy all of it into the shared memory segment, so that the informations we just gathered will now persist through several requests.</p>
<p>The process is as follow :</p>
<ul><li>Take the PHP script to cache, and compute every variable data size (every pointer target)</li>
<li>Allocate into shared memory one big block of this precise size</li>
<li>Iterate over the PHP script variable structures, and for each variable-data pointer target, copy it into the just-allocated shared memory block</li>
<li>Do the exact opposite for script loading, when this comes to play.</li>
</ul><p>So OPCache is clever about shared memory, and will not fragment it by freeing it and compacting it.
For every script, it computes the exact size this script needs to store informations into shared memory, and then copies the data into the segment. <strong>The memory is never freed nor given back to OPCache</strong> , thus the memory is perfectly aligned and never fragmented. This gives a big boost in performance of shared memory, as there is no linked-list to store and traverse when managing memory that can be freed (like malloc/free do). OPcache keeps storing things into the shared memory segment, and when the data become stale (because of script revalidation) : it does not free the buffers but mark them as "wasted". When the max wasted percentage is reached, OPCache triggers a restart. This model is very different from APC, for example, and has the big advantage of providing the same performances as time runs, because the memory buffer from SHM is never managed (freed, compacted, etc...), memory management operations are trully technically stuff which brings nothing to functionnalities, but performance penalty. <strong>OPCache has been designed with highest possible performance in mind</strong>, not touching back the shared memory segment provides as well a very good rate of CPU caches hits (especially L1 and L2, as OPCache also aligns the memory pointers for them to fit in an L1/L2 line).</p>
<p>Caching a script thus involves -as a first step- computing the exact size of its data. Here is the algorithm :</p>
<pre><code>uint zend_accel_script_persist_calc(zend_persistent_script *new_persistent_script, char *key, unsigned int key_length TSRMLS_DC)
{
    START_SIZE();

    ADD_SIZE(zend_hash_persist_calc(&amp;new_persistent_script-&gt;function_table, (int (*)(void* TSRMLS_DC)) zend_persist_op_array_calc, sizeof(zend_op_array) TSRMLS_CC));
    ADD_SIZE(zend_accel_persist_class_table_calc(&amp;new_persistent_script-&gt;class_table TSRMLS_CC));
    ADD_SIZE(zend_persist_op_array_calc(&amp;new_persistent_script-&gt;main_op_array TSRMLS_CC));
    ADD_DUP_SIZE(key, key_length + 1);
    ADD_DUP_SIZE(new_persistent_script-&gt;full_path, new_persistent_script-&gt;full_path_len + 1);
    ADD_DUP_SIZE(new_persistent_script, sizeof(zend_persistent_script));

    RETURN_SIZE();
}</code></pre>
<p>I repeat : what we have to cache are :</p>
<ul><li>The script functions</li>
<li>The script classes</li>
<li>The script main OPArray</li>
<li>The script path</li>
<li>The script structure itself</li>
</ul><p>For functions, classes and OPArray, the iterating algorithm is deep searching : it caches every pointer data.
For example, for the functions, we must copy into shared memory (shm) :</p>
<ul><li>The functions HashTable
<ol><li>The functions HashTable buckets table (Bucket **)</li>
<li>The functions HashTable buckets (Bucket *)</li>
<li>The functions HashTable buckets' key (char *)</li>
<li>The functions HashTable buckets' data pointer (void *)</li>
<li>The functions HashTable buckets' data (*)</li>
</ol></li>
<li>The functions OPArray
<ol><li>The OPArray filename (char *)</li>
<li>The OPArray literals (names (char <em>) and values (zval </em>))</li>
<li>The OPArray OPCodes (zend_op *)</li>
<li>The OPArray function name (char *)</li>
<li>The OPArray arg_infos (zend_arg_info <em>, and the name and class name as both char </em>)</li>
<li>The OPArray break-continue array (zend_brk_cont_element *)</li>
<li>The OPArray static variables (Full deep HashTable and zval *)</li>
<li>The OPArray doc comments (char *)</li>
<li>The OPArray try-catch array (zend_try_catch_element *)</li>
<li>The OPArray compiled variables (zend_compiled_variable *)</li>
</ol></li>
</ul><p>I did not detail all ;-)
The idea is as I expressed it : copy in shared memory every pointer data. As deep copies may involve recursive structures, OPCache uses a translate table for pointer storage : everytime it copies a pointer from regular request-bound memory to shared memory, it saves the association between the old pointer address, and the new pointer address.
The copy process, before copying, looks up this translate table to know if it has already copied the data, if so, it reuses the old pointer data so that it never duplicates any pointer data :</p>
<pre><code>void *_zend_shared_memdup(void *source, size_t size, zend_bool free_source TSRMLS_DC)
{
    void **old_p, *retval;

    if (zend_hash_index_find(&amp;xlat_table, (ulong)source, (void **)&amp;old_p) == SUCCESS) {
        /* we already duplicated this pointer */
        return *old_p;
    }
    retval = ZCG(mem);;
    ZCG(mem) = (void*)(((char*)ZCG(mem)) + ZEND_ALIGNED_SIZE(size));
    memcpy(retval, source, size);
    if (free_source) {
        interned_efree((char*)source);
    }
    zend_shared_alloc_register_xlat_entry(source, retval);
    return retval;
}</code></pre>
<p><code>ZCG(mem)</code> represents the fixed-size shared memory segment and is filled-in as elements are added. It then has already been allocated, there is no need to allocate memory on each copy (which would have been less performant), but simply fill-in the memory, and move forward the pointer address.</p>
<p>We detailed the script caching algorithm, which role is to take any request-bound memory pointer and data and duplicate it into shared memory, if not already copied.
The loading algorithm does the exact opposite : it gets the persistent_script back from shared memory and browse every of its dynamic structures to duplicate every shared pointer to a request-bound allocated pointer.
The script is then ready to be run by the Zend Engine Executor, as it now doesn't embed any shared pointer address (which would lead to massive bugs of one script modifing the structure of its brother). The Zend Engine is tricked (hooked by OPCache) : it has seen nothing of the pointers replacement happening before the execution happens.</p>
<p>This process of copying from regular memory to shared memory (cache script), or the opposite (load script), is highly optimized, and even if it involves many memory copies or hash lookups, which are not really nice in term of performance, we are way faster than triggering the PHP compiler every time.</p>
<h3 id="sharing-interned-strings">Sharing interned strings<a href="#sharing-interned-strings" class="anchor">#</a></h3>
<p>Interned strings is a nice memory optimisation that's been added to PHP 5.4. This may feel like some comonsense : every time PHP meets a string (a char*), it stores it into a special buffer and reuses the pointer for every occurence of this same string next to come.</p>
<p>Before PHP5.4 , PHP allocated a buffer for every piece of string it met. That led to memory waste, because some strings were stored in memory several times.</p>
<p>Interned strings work like this :</p>
<p><img alt="PHP-interned-strings" src="../../../img/opcache/PHP-interned-strings.png"></p>
<p>The same instance of a string is shared to every pointer. This leads to a huge memory saving compared to PHP5.3 and lower.
But there still is a problem with that : this interned string buffer is a per-process buffer. That means that in a PHP-FPM pool, every PHP worker will store its own copy of this buffer, something like this :</p>
<p><img alt="PHP-interned-strings-pools" src="../../../img/opcache/PHP-interned-strings-pools.png"></p>
<p>This leads to a massive waste of memory, especially in case you have tons of workers (you're likely to have), and you use very big strings in your PHP code (tip: PHP comments all are strings as well). What OPCache takes care of, is sharing this buffer between every PHP worker of a pool. Something like this :</p>
<p><img alt="PHP-interned-strings-pools-shared" src="../../../img/opcache/PHP-interned-strings-pools-shared.png"></p>
<p>Et voila! OPCache shares the interned string buffers of all the PHP-FPM worker of the same pools, and uses its shm segment to store those.
Thus, you need to size the shm segment according to your interned string usage as well. Also, OPCache allows you to tune the interned strings shm usage using <em>opcache.interned_strings_buffer</em> INI setting. Monitor OPCache and once more : make sure you have enough memory.
However here, if you run out of interned strings memory space (<em>opcache.interned_strings_buffer</em> setting is too low), OPCache will not trigger a restart, because it still has some shm available, only interned string buffer is full, which is not blocking to continue processing request, you'll simply end up having some strings interned and shared, and some other that use PHP worker's memory. I don't recommand that for performance.</p>
<p>Read your logs, when you run out of interned string memory, OPCache warns you :</p>
<pre><code>if (ZCSG(interned_strings_top) + ZEND_MM_ALIGNED_SIZE(sizeof(Bucket) + nKeyLength) &gt;=
        ZCSG(interned_strings_end)) {
        /* no memory, return the same non-interned string */
        zend_accel_error(ACCEL_LOG_WARNING, "Interned string buffer overflow");
        return arKey;
    }</code></pre>
<blockquote>
<p>Interned strings are about every piece of string the PHP compiler is going to meet while doing its job : variable names, "php strings", function names, class names... PHP comments, nowadays used and called "annotations", are strings as well, and they are usually huge strings, that will eat most of your interned strings buffer. Think about them as well.</p>
</blockquote>
<h3 id="the-locking-mechanism">The locking mechanism<a href="#the-locking-mechanism" class="anchor">#</a></h3>
<p>As soon as we talk about shared memory (shm), we must talk about memory locking mecanisms.
The base line is simple : <strong>every PHP process that is willing to write into shared memory will lock every other process willing to write into shared memory as well</strong>. So the critical section is done on write operations, and not read operations. You may happen to have 150 PHP processes reading the shared memory, only one of them may write into the shm at the same time.</p>
<p>So, <strong>there should be no dead-lock in OPCache, until you don't prime your cache smoothly</strong> . If, after your code deployment, you open your webserver to trafic, then there will be a massive rush on your scripts to compile and cache them, and as the cache write-to-shm operation is done under exclusive lock, you will probably lock every processes once the first lucky one has obtained a lock to write. When this latter will release the lock, every process waiting for it will then see that the file they just compiled is already stored into shm , and then they will trash the compilation result to load it from shm. This is a big waste of resources.</p>
<pre><code>/* exclusive lock */
zend_shared_alloc_lock(TSRMLS_C);

/* Check if we still need to put the file into the cache (may be it was
 * already stored by another process. This final check is done under
 * exclusive lock) */
bucket = zend_accel_hash_find_entry(&amp;ZCSG(hash), new_persistent_script-&gt;full_path, new_persistent_script-&gt;full_path_len + 1);
if (bucket) {
    zend_persistent_script *existing_persistent_script = (zend_persistent_script *)bucket-&gt;data;

    if (!existing_persistent_script-&gt;corrupted) {
        if (!ZCG(accel_directives).revalidate_path &amp;&amp;
            (!ZCG(accel_directives).validate_timestamps ||
             (new_persistent_script-&gt;timestamp == existing_persistent_script-&gt;timestamp))) {
            zend_accel_add_key(key, key_length, bucket TSRMLS_CC);
        }
        zend_shared_alloc_unlock(TSRMLS_C);
        return new_persistent_script;
    }
}</code></pre>
<p>What you should do, is cut off your server from external webtraffic, deploy your new code, curl some of your most heavy URLs, so that your curl requests will smoothly prime the shm. When you think you are done with the big majority of your scripts, you may now open your webserver to traffic, so that now this one will massively read shm, which is a lock-free operation. Sure there may still be some little scripts not compiled yet, but as soon as they are uncommon, there is no pressure on the write lock.</p>
<p>What you should avoid, is writing PHP files at runtime, and then make use of them. For the exact same reason : as soon as you write a new PHP file onto your production server documentroot, and you make use of it, chances are that it will be rushed by thousands of PHP workers trying to compile and cache it into shm : you will lock.
Those dynamically generated PHP files should be added to the OPCache blacklist, using the <em>opcache.blacklist-filename</em> INI setting (which accepts glob patterns).</p>
<p>Technically speaking, the lock mecanism is not very strong, but it works on many flavors of Unix : it uses the famous <code>fcntl()</code> call</p>
<pre><code>void zend_shared_alloc_lock(TSRMLS_D)
{
    while (1) {
        if (fcntl(lock_file, F_SETLKW, &amp;mem_write_lock) == -1) {
            if (errno == EINTR) {
                continue;
            }
            zend_accel_error(ACCEL_LOG_ERROR, "Cannot create lock - %s (%d)", strerror(errno), errno);
        }
        break;
    }
    ZCG(locked) = 1;
    zend_hash_init(&amp;xlat_table, 100, NULL, NULL, 1);
}</code></pre>
<p>I here talked about memory locks happening on normal process : nothing bad, if you take care, no more than one PHP process should be writing to the shm at the same time, so you won't suffer from any lock waiting times.</p>
<p>There exists however another lock that you should prevent from happening : the memory exhausted lock. This is the next chapter</p>
<h3 id="understanding-the-opcache-memory-consumption">Understanding the OPCache memory consumption<a href="#understanding-the-opcache-memory-consumption" class="anchor">#</a></h3>
<p>So I remind you with facts :</p>
<ul><li>OPCache creates one unique segment of shared memory, once for all, at PHP startup (when you start PHP-FPM)</li>
<li>OPCache never frees some shm into this segment, the segment is allocated at startup, then filled-in according to the needs</li>
<li>OPCache locks shm when it writes into it</li>
<li>shm is used for several purposes :
<ol><li>Script's datastructure caching, involving obviously OPCodes caching but not only</li>
<li>Shared interned strings buffer</li>
<li>Cached scripts HashTable</li>
<li>Global OPCache shared memory state</li>
</ol></li>
</ul><p>If you use validation of your scripts, OPCache will check their modification date at every access (not every, check <em>opcache.revalidate_freq</em> INI setting), and will have a hint of wheither the file is fresh or stale. This check is cached : it is <strong>not</strong> costly as opposed to what you could think. OPCache comes into the scene some time after PHP, and PHP has already <code>stat()</code>ed the file : OPCache just reuses this information and does not issue a costly <code>stat()</code> call to the filesystem again for its own use.</p>
<p>If you use timestamp validation, via <em>opcache.validate_timestamps</em> and <em>opcache.revalidate_freq</em>, and your file has effectively changed, then OPCache will simply invalidate it, and flag all of its shm data as invalid. It will not free anything from shm. OPCache flags the shm parts as "wasted". <strong>Only when OPCache runs out of shm on an allocation AND when wasted memory reaches the <em>opcache.max_wasted_percentage</em> INI setting value, OPCache will trigger a full restart, which is something you must absolutely prevent from happening</strong> No other scenario.</p>
<pre><code>/* Calculate the required memory size */
memory_used = zend_accel_script_persist_calc(new_persistent_script, key, key_length TSRMLS_CC);

/* Allocate shared memory */
ZCG(mem) = zend_shared_alloc(memory_used);
if (!ZCG(mem)) {
    zend_accel_schedule_restart_if_necessary(ACCEL_RESTART_OOM TSRMLS_CC);
    zend_shared_alloc_unlock(TSRMLS_C);
    return new_persistent_script;
}</code></pre>
<p><img alt="opcache-wasted-shm" src="../../../img/opcache/opcache-wasted-shm.png"></p>
<p>The picture above details what your shm segment could look like after some time has passed and some scripts have changed. The changed scripts memory has been marked as "wasted", and OPCache will simply now ignore those memory areas, as well as it will recompile your changed scripts and create new memory segment for their informations.</p>
<p>When enough wasted memory is reached, a restart will happen, OPCache will then lock shm, reset the shm segment (empty it entirely), and release the lock. This will let your server in a situation like if it has just started : every PHP worker is going to stress the lock now, because every worker will try to compile some files : your web server will now suffer from a very poor performance because of locks. The more the load, the less performance, this is unfortunately the rule with locks. So your server may really suffer for long seconds now.</p>
<blockquote>
<p><strong>Never run out of shared memory</strong></p>
</blockquote>
<p>More generally, what you should do is disable script modification tracking on production server, that way you are sure the cache will never trigger a restart (this is not entirely true as OPCache may still run out of persisten script key space, we'll see that later). A classic deployment should follow the rules :</p>
<ul><li>take out the server from load (disconnect it from your load balancer)</li>
<li>empty opcache (call <code>opcache_reset()</code>) or directly shut down FPM (better, we'll detail in few minutes)</li>
<li>deploy a new version of your application at once</li>
<li>restart your FPM pool if needed and prime your new cache smoothly by triggering curl request on major application entry points</li>
<li>open back your server to traffic</li>
</ul><p>All this can be done with a 50 line shell script that can be turned very robust playing with <code>lsof</code> and <code>kill</code> in case some hard requests don't seem to finish. Bring your Unix knowledge ;-) </p>
<p>You can even see what happens using one of the numerous GUI frontend for OPCache available anywhere on the web and Github, they all make use of the <code>opcache_get_status()</code> function:</p>
<p><img alt="opcache-frontend" src="../../../img/opcache/opcache-frontend.png"></p>
<p>This is not the full story though, there is another thing to clearly keep in mind : <strong>cache keys</strong>.</p>
<p>When OPCache stores a cached script into SHM, it stores its into a HashTable, to be able to find the script back after. But it has to choose a key to index the HashTable. What index/key does OPCache use to achieve this goal ? This highly depends on both the configuration, and the way your app has been designed.</p>
<p>Normally, OPCache resolves the full path to the script, but take care as it uses <a href="http://jpauli.github.io/2014/06/30/realpath-cache.html">the PHP's realpath cache</a> and you may suffer from it. If you change your documentroot using a symlink, put <em>opcache.revalidate_path</em> to 1 and empty your realpath cache (which may be hard to do as it is bound to the PHP worker process handling the current request).</p>
<p>So OPCache resolves the path to the file, and when resolved, <strong>it uses the realpath string as cache key for the script</strong>, and that's all, assuming you have  <em>opcache.revalidate_path</em> INI setting turned to 1. If not, OPCache will also use the <strong>unresolved path</strong> as a cache key, and that will lead to problems if you were using symlinks, because if you then change the symlink target, OPCache will not notice it, as it will still use the unresolved path as key to find the old targetted script (this is to save a symlink resolution call).</p>
<p>By turning <em>opcache.use_cwd</em> to 1, you tell OPCache to prepend the <code>cwd</code> to every key, in case you use <em>relative paths</em> to include your files, like <code>require_once "./foo.php";</code>. I suggest, if you use relative paths and host several applications on the same PHP instance (which you shouldn't do), to always put <em>opcache.use_cwd</em> to 1. Also, if you happen to play with symlinks, turn <em>opcache.revalidate_path</em> to 1. But even with those settings on, you will suffer from <a href="http://jpauli.github.io/2014/06/30/realpath-cache.html">PHP's realpath cache</a>, and you may change the <em>www</em> symlink to another target, it won't be noticed by OPCache, even if you empty the cache by using <code>opcache_reset()</code>.</p>
<blockquote>
<p>Because of PHP's realpath cache, you may experience problems if using symlinks to handle your documentroot for deployment. Turn <em>opcache.use_cwd</em> and <em>opcache.revalidate_path</em> to 1, but even with those settings, bad symlink resolutions may happen, this is because PHP answers OPCache realpath resolution requests with a wrong answer, comming from its realpath_cache mechanism.</p>
</blockquote>
<p>If you want to be extra safe in your deployment, the first option is to not use symlinks to manage your documentroot.
If not, then use a double FPM pool, and use a FastCGI load balancer to balance between the two pools when deploying. Lighttpd and Nginx have this feature enabled by default as far as I remember :</p>
<ul><li>take out the server from load (disconnect it from your load balancer)</li>
<li>shut down FPM, you will kill PHP (and then OPCache) and will be extra safe especially about PHP's realpath cache, wich may trick you. This latter will be cleared if you shut down FPM. Monitor the eventual workers that may be stuck, and kill them if necessary.</li>
<li>deploy a new version of your application at once</li>
<li>restart your FPM pool. Don't forget to prime your new cache smoothly by triggering curl request on major application entry points before</li>
<li>open back your server to traffic</li>
</ul><p>If you don't want to take your server out of the balancer, what can be done then, is :</p>
<ul><li>Deploy your new code into another directory, as your PHP server has one FPM pool still active and serving production requests</li>
<li>Start another FPM pool, listening on another port, while still having the first FPM pool active and serving production requests</li>
<li>Now you have two FPM pools, one hot and working, one idle, waiting to be bound to requests</li>
<li>Change your documentroot symlink target to target the new deploy path, and immediately after, stop the first FPM pool. If you told your webserver about your two pools, it should notice the first pool is dying, and should load balance traffic to the new pool now, with no traffic interruption nor failing requests. The second pool will then be triggered, will resolve the new docroot symlink (as it is fresh and has a cleared realpath cache), and serve your new content. This clearly works, I used that on production servers many times, a ~80 lines well written shell script can take care of all this job.</li>
</ul><p>So depending on the settings, one unique script may lead to several keys computed by opcache. But the key store is not infinite : it is also allocated into shared memory, and may get full, in which case even if there is still lot of room into the shm, because the persistent script hashtable is full, OPCache will behave like if it had no more memory, and will trigger a restart for next requests. </p>
<blockquote>
<p>You always should monitor the number of keys in the key store, for it never to be full.</p>
</blockquote>
<p>OPCache gives you this information with the use of <code>opcache_get_status()</code>, a function the different GUIs relies on. The <code>num_cached_keys</code> dimension returned by this function gives the info. You should preconfigure the number of keys, as a hint, using <em>opcache.max_accelerated_files</em> INI setting. Take care as the name suggests a number of files, in fact it is the number of keys that OPCache will compute, and as we've seen, one file may lead to several keys beeing computed. Monitor it, and use the right number. Avoid using relative paths in require_once statements, it makes OPCache generate more keys. Using an autoloader is recommanded, as this one, if well configured, will always issue include_once calls with full paths, and not relative ones.</p>
<blockquote>
<p>OPCache preallocates the HashTable to store future persistent scripts when it starts (when PHP starts), and never tries to resize it. If it is full, it will then trigger a restart. This is done for performance reasons.</p>
</blockquote>
<p>So this is why you may see a <em>num_cached_scripts</em> dimension which is different from the <em>num_cached_keys</em> dimension, from OPcache status report. Only the <em>num_cached_keys</em> info is relevant, if it reaches <em>max_cached_keys</em>, you'll be in trouble with a restart pending.</p>
<p>Do not forget that you can understand what happens by lowering OPCache's log level (<em>opcache.log_verbosity_level</em> INI). It tells you if it runs out of memory, and which kind of OOM (OutOfMemory) error it generated : if it is related to the shm beeing full, or if it is the keys Hashtable which is full.</p>
<p><img alt="opcache-log" src="../../../img/opcache/opcache-log.png"></p>
<pre><code>static void zend_accel_add_key(char *key, unsigned int key_length, zend_accel_hash_entry *bucket TSRMLS_DC)
{
    if (!zend_accel_hash_find(&amp;ZCSG(hash), key, key_length + 1)) {
        if (zend_accel_hash_is_full(&amp;ZCSG(hash))) {
            zend_accel_error(ACCEL_LOG_DEBUG, "No more entries in hash table!");
            ZSMMG(memory_exhausted) = 1;
            zend_accel_schedule_restart_if_necessary(ACCEL_RESTART_HASH TSRMLS_CC);
        } else {
            char *new_key = zend_shared_alloc(key_length + 1);
            if (new_key) {
                memcpy(new_key, key, key_length + 1);
                if (zend_accel_hash_update(&amp;ZCSG(hash), new_key, key_length + 1, 1, bucket)) {
                    zend_accel_error(ACCEL_LOG_INFO, "Added key '%s'", new_key);
                }
            } else {
                zend_accel_schedule_restart_if_necessary(ACCEL_RESTART_OOM TSRMLS_CC);
            }
        }
    }
}</code></pre>
<p>So, to conclude about memory usage, here is the picture :</p>
<p><img alt="OPCache-memory-structure" src="../../../img/opcache/OPCache-memory-structure.png"></p>
<p>When you start PHP, you start OPCache, it allocates immediately <em>opcache.memory_consumption</em> Megabytes of shared memory (shm).
It then starts using this free space, and stores into it the interned strings buffer (<em>opcache.interned_strings_buffer</em>). After that, it preallocates the HashTable for future persistent scripts and their keys to be stored. The space used depends on the <em>opcache.max_accelerated_files</em>.</p>
<p>Now, a part of the shm is used by OPCache internals, and the free space left, is dedicated to you : to your scripts datastructures. This (actually free) memory segment will then be filled in, and as your scripts will change and OPCache will recompile them (assuming you told it to), the space will slowly become "wasted"; except if you tell OPCache not to recompile changed scripts (recommanded).</p>
<p>That may look like something like that :</p>
<p><img alt="OPCache-memory-structure-hot" src="../../../img/opcache/OPCache-memory-structure-hot.png"></p>
<p>If persistent scripts HashTable becomes full, or if free SHM runs out : OPCache will trigger a restart (which you'd want to prevent absolutely).</p>
<h3 id="configuring-opcache">Configuring OPCache<a href="#configuring-opcache" class="anchor">#</a></h3>
<p>If you use a framework based application, like a Symfony2 based application, I strongly suggest :</p>
<ul><li>you turn off revalidation mechanism on production (turn <em>opcache.validate_timestamps</em> to 0)</li>
<li>you deploy using a full new runtime of your scripts, this is the case with Symfony2 applications</li>
<li>you size correctly your buffers
<ol><li><em>opcache.memory_consumption</em>, the most important</li>
<li><em>opcache.interned_strings_buffer</em> , monitor your usage, and size accordingly, take care if you tell OPCache to save comments, which you will likely do if you use PHP "annotations" (<em>opcache.save_comments = 1</em>), those are strings, big strings, that will eat your interned strings buffer</li>
<li><em>opcache.max_accelerated_files</em> , numbers of keys to preallocate, once more : monitor and size accordingly</li>
</ol></li>
<li>You turn off <em>opcache.opcache.revalidate_path</em> and <em>opcache.use_cwd</em>. That will save some key space</li>
<li>You turn on <em>opcache.enable_file_override</em> , this will accelerate the autoloader</li>
<li>You fill-in <em>opcache.blacklist_filename</em> list with the script names you are likely to generate during runtime; shouldn't be too many of them anyway</li>
<li>You turn off <em>opcache.consistency_checks</em>, this basically checks a control sum on your scripts, that eats perf</li>
</ul><p>With those settings, your memory should never get wasted, then <em>opcache.max_wasted_percentage</em> is not very useful in this case.
With those settings, you'll need to turn off your main FPM instance when deploying. You may play with several FPM pools to prevent service downtime, like explained earlier.</p>
<p>That should be enough.</p>
<h3 id="opcache-compiler-s-optimizer">OPCache compiler's optimizer<a href="#opcache-compiler-s-optimizer" class="anchor">#</a></h3>
<p>So we talked about caching OPCodes into shm and loading them back later. Just before caching them, OPCache may also run optimizer passes.
To understand the optimizer, you have to have a good knowledge of <a href="http://jpauli.github.io/2015/02/05/zend-vm-executor.html">how the Zend VM Executor works</a>. Also, you may bring your compiler knowledge, if you are very new to such concepts, perhaps starting <a href="https://msdn.microsoft.com/en-us/magazine/dn904673.aspx">reading some articles on the subject</a> may help ? Or at least the mandatory-reading <a href="http://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">Dragon Book</a> ?</p>
<p>Unfortunately, due to PHP's high level of dynamism, you will notice that there is not a lot of room left for optimizing OPCodes. Something that could change in the future, with PHP7.</p>
<p>Basically, the optimizer is given the whole OPArray structure, and may now browse it, find flaws, and fix them. But as we are analyzing OPCodes <strong>at compile time</strong>, we have no clue at all on everything tied to a "PHP variable". Basically, we don't know yet what will be stored in any IS_VAR operand, but only in IS_CONST. PHP7 changed many things into this, and things like type hints can also really help, because we would now know at compile time, the type the PHP variables have.</p>
<p>So, back to PHP5, OPCache optimizer can optimize a lot of things in IS_CONST; We can also replace some OPCodes by others (more optimized at runtime), we also find and trash dead code branches, but we don't yet unroll loops, or process to loop invariant motions. That should come in the future.
We also have other possibilities related to PHP internals : we may change the way classes are bound to optimize a bit the process in some specific cases, but we have absolutely not the possibility to do some cross file optimizations, because OPCache plays with OPArrays coming from file compilation (among other functions' OPArrays), and there is a total isolation of those OPArrays. PHP has never been built on a cross file based VM : the Virtual Machine and the language is file bound : when compiling a file, we have absolutely no information about the files that already got compiled, and those to come next.
We then must try to optimize on a file-by-file basis, and must not assume, for example, that class A will be present in the future, if it is not at the moment.</p>
<blockquote>
<p>The PHP compiler acts on a file basis and has no shared state through file compilations, it doesn't compile a project in its whole, but a file, followed by others.
There is no room for cross file optimizations.</p>
</blockquote>
<p>OPCache optimization passes can be enabled on a case-by-case basis, using the INI setting <em>opcache.optimization_level</em>. It should represent a mask for optimizations you'd like to see enabled, based on their binary values :</p>
<pre><code>/* zend_optimizer.h */
#define ZEND_OPTIMIZER_PASS_1        (1&lt;&lt;0)   /* CSE, STRING construction     */
#define ZEND_OPTIMIZER_PASS_2        (1&lt;&lt;1)   /* Constant conversion and jumps */
#define ZEND_OPTIMIZER_PASS_3        (1&lt;&lt;2)   /* ++, +=, series of jumps      */
#define ZEND_OPTIMIZER_PASS_4        (1&lt;&lt;3)
#define ZEND_OPTIMIZER_PASS_5        (1&lt;&lt;4)   /* CFG based optimization       */
#define ZEND_OPTIMIZER_PASS_6        (1&lt;&lt;5)
#define ZEND_OPTIMIZER_PASS_7        (1&lt;&lt;6)
#define ZEND_OPTIMIZER_PASS_8        (1&lt;&lt;7)   
#define ZEND_OPTIMIZER_PASS_9        (1&lt;&lt;8)   /* TMP VAR usage                */
#define ZEND_OPTIMIZER_PASS_10        (1&lt;&lt;9)   /* NOP removal                 */
#define ZEND_OPTIMIZER_PASS_11        (1&lt;&lt;10)
#define ZEND_OPTIMIZER_PASS_12        (1&lt;&lt;11)
#define ZEND_OPTIMIZER_PASS_13        (1&lt;&lt;12)
#define ZEND_OPTIMIZER_PASS_14        (1&lt;&lt;13)

#define ZEND_OPTIMIZER_ALL_PASSES    0xFFFFFFFF

#define DEFAULT_OPTIMIZATION_LEVEL  "0xFFFFFFFF"</code></pre>
<p>Here we go with examples :</p>
<pre><code>if (false) {
    echo "foo";
} else {
   echo "bar";
}</code></pre>
<p>This leads in classical compilation to :</p>
<p><img alt="OPCache-optimizer-1" src="../../../img/opcache/optimizer/1.png"></p>
<p>And optimized compilation :</p>
<p><img alt="OPCache-optimizer-1-opt" src="../../../img/opcache/optimizer/1-opt.png"></p>
<p>As we can see, the dead code in the <code>if(false)</code> branch has been trashed, the Zend VM executor will then simply have to run a <code>ZEND_ECHO</code> OPcode. We then saved some memory, because we threw away some OPCodes, and we may save a little bit of CPU cycles at runtime as well.</p>
<p>I recall you that we cannot know the content of any variable yet, as we are still at compile time (we are between compilation and execution). A code with an IS_VAR operand instead of IS_CONST, could not have been optimized :</p>
<pre><code>/* That cant be optimized, what's in $a ? */
if ($a) {
    echo "foo";
} else {
   echo "bar";
}</code></pre>
<p>More interestingly, OPCache optimizer may switch your IS_CONST operand types, when it knows runtime will have to transtype them. That effectively saves some CPU cycles at runtime :</p>
<pre><code>$a = 8;
$c = $a + "42";
echo $c;</code></pre>
<p>Classical compilation :</p>
<p><img alt="OPCache-optimizer-2" src="../../../img/opcache/optimizer/2.png"></p>
<p>Optimized compilation :</p>
<p><img alt="OPCache-optimizer-2-opt" src="../../../img/opcache/optimizer/2-opt.png"></p>
<p>This is not easy to spot, but look at the second operand true type of <code>ZEND_ADD</code> operation : it has switched from a string to an int. The optimizer did the job of transtyping the argument type for the math add operation. If it had not : the runtime VM would have done it again, and again, and again as the code is run again, and again, and again. This saves some CPU cycles involved in the transtyping operation.</p>
<p>Here is the OPCache optimizer code that does such a job :</p>
<pre><code>if (ZEND_OPTIMIZER_PASS_2 &amp; OPTIMIZATION_LEVEL) {
    zend_op *opline;
    zend_op *end = op_array-&gt;opcodes + op_array-&gt;last;

    opline = op_array-&gt;opcodes;
    while (opline &lt; end) {
        switch (opline-&gt;opcode) {
            case ZEND_ADD:
            case ZEND_SUB:
            case ZEND_MUL:
            case ZEND_DIV:
                if (ZEND_OP1_TYPE(opline) == IS_CONST) {
                    if (ZEND_OP1_LITERAL(opline).type == IS_STRING) {
                        convert_scalar_to_number(&amp;ZEND_OP1_LITERAL(opline) TSRMLS_CC);
                    }
                }
                /* break missing *intentionally* - the assign_op's may only optimize op2 */
            case ZEND_ASSIGN_ADD:
            case ZEND_ASSIGN_SUB:
            case ZEND_ASSIGN_MUL:
            case ZEND_ASSIGN_DIV:
                if (opline-&gt;extended_value != 0) {
                    /* object tristate op - don't attempt to optimize it! */
                    break;
                }
                if (ZEND_OP2_TYPE(opline) == IS_CONST) {
                    if (ZEND_OP2_LITERAL(opline).type == IS_STRING) {
                        convert_scalar_to_number(&amp;ZEND_OP2_LITERAL(opline) TSRMLS_CC);
                    }
                }
                break;
    /* ... ... */</code></pre>
<p>A little bit more silly, but adding two IS_CONST expression, the result can then be computed at compile time, something the PHP compiler does not do by default, OPCache optimizer is needed :</p>
<pre><code>$a = 4 + "33";
echo $a;</code></pre>
<p>Classical compilation :</p>
<p><img alt="OPCache-optimizer-3" src="../../../img/opcache/optimizer/3.png"></p>
<p>Optimized compilation :</p>
<p><img alt="OPCache-optimizer-3-opt" src="../../../img/opcache/optimizer/3-opt.png"></p>
<p>The optimizer computed the maths for <code>4 + 33</code>, and erased the <code>ZEND_ADD</code> operation to be run by replacing it directly by the result. This saves again some CPU at runtime, as the VM executor now has less job to do.</p>
<p>Now let's dive deeper into OPCodes. Sometimes (rarely), it is possible to substitue a following of OPCodes by other ones, more optimized. Look at that :</p>
<pre><code>$i = "foo";
$i = $i + 42;
echo $i;</code></pre>
<p>Classical compilation :</p>
<p><img alt="OPCache-optimizer-4" src="../../../img/opcache/optimizer/4.png"></p>
<p>Optimized compilation :</p>
<p><img alt="OPCache-optimizer-4-opt" src="../../../img/opcache/optimizer/4-opt.png"></p>
<p>Here, our knowledge of the Zend VM executor leads us to substitue a <code>ZEND_ADD</code> plus a <code>ZEND_ASSIGN</code>, into a <code>ZEND_ASSIGN_ADD</code>, usually involved in statements such as <code>$i+=3;</code>
<code>ZEND_ASSIGN_ADD</code> is more optimized, it is one OPCode instead of two (which usually is better, but not every time)</p>
<p>On the same subject :</p>
<pre><code>$j = 4;
$j++;
echo $j;</code></pre>
<p>Classical compilation :</p>
<p><img alt="OPCache-optimizer-5" src="../../../img/opcache/optimizer/5.png"></p>
<p>Optimized compilation :</p>
<p><img alt="OPCache-optimizer-5-opt" src="../../../img/opcache/optimizer/5-opt.png"></p>
<p>Here, OPCache optimizer replaced the <code>$i++</code> by a <code>++$i</code> statement, because it had the same meaning in this piece of code. <code>ZEND_POST_INC</code> is not very nice OPCode, because it must read the value, return it as-is, but increment a temporary value in memory, whereas <code>ZEND_PRE_INC</code> plays with the value itself, and reads it, increments it and returns it (this is just the PRE vs POST incrementation difference).
Because the intermediate value returned by <code>ZEND_POST_INC</code> is not used in the script above, the compiler must issue a <code>ZEND_FREE</code> OPCode, to free it from memory. OPCache optimizer turns the structure into a <code>ZEND_PRE_INC</code>, and removes the useless <code>ZEND_FREE</code></p>
<p>Last example :</p>
<pre><code>const FOO = "bar";
echo FOO;</code></pre>
<p><img alt="OPCache-optimizer-6" src="../../../img/opcache/optimizer/6.png"></p>
<p>Optimized compilation :</p>
<p><img alt="OPCache-optimizer-6-opt" src="../../../img/opcache/optimizer/6-opt.png"></p>
<p>This is part of temporary variables optimizations, as we can see, here, once again, one OPCode have been trashed, the result of constant reading is directly figured out at compile time, into the optimizer, and the runtime will have less work to do.</p>
<p>I did not show you all the work done by the optimizer. It can also optimize embeded loops by issuing "early returns" for example. Same for embed try catch blocks or switch-breaks. PHP function calls, which is a heavy process into the engine, is also optimized when possible.</p>
<blockquote>
<p>The main difficulty in optimizer passes, is to never change the meaning of the script, and especially its control flow.</p>
</blockquote>
<p>The main difficulty in optimizer passes, is to never change the meaning of the script, and especially its control flow. Bugs were found about this some time ago in OPCache, and it is all but cool when you come to see that PHP executor doesn't behave the way it should, having your little PHP script written under your eyes... In fact, the OPCodes generated have been altered by the optimizer and the engine just runs something which is wrong. Not cool.</p>
<p>Nowadays, OPCache optimizer is pretty stable, I'm still working on other passes I have in mind, mainly for proof of concept purpose, but if results show nice improvement, I open some PR for the code. PHP7 will change many things into that, its compiler is built on top of an AST, which itself allows optimizations to hook as well (something not possible in PHP5). Also, PHP7 introduced new way in OPCodes management, as well as a more "hintable" language : by declaring function return types and eventually function argument types, depending on the context (and many more things), more optimizations can happen, and they can be more accurate, not even talking about JIT.</p>
<p>Also, you may wonder why all this job is not done directly into the PHP compiler. The answer is that we want to keep the compiler as safe as possible : this one generates some OPCodes, which sometimes, not at every compilation of every script, may be not much optimized. Then, an external optimizer like the one in OPCache can fire up and do the job. It is the same for every compiler, they usually compile foolishly the code, and only after, you may activate different optimization passes, but the raw code at the compiler output should be extra safe.</p>
<h3 id="end">End<a href="#end" class="anchor">#</a></h3>
<p>We've seen that OPCache has finally become the standard recommanded PHP OPCode caching solution. We detailed how it works, not that hard to understand, but error prone yet. Nowadays, the PHP5 branch is very mature and stable, and achieves its goal of boosting dramatically the overall performance of the PHP language by both canceling the time needed to compile a script and by optimizing the OPCodes resulting of the compilation. Shared memory is used for every process of a PHP pool to be able to access structures that have been added by others. Interned string buffer is also managed in shared memory, leading to even more memory savings in a PHP pool of workers - typically using PHP-FPM SAPI.</p>
<p>Now there is still some job to achieve to have a stable OPCache extension for PHP7, whose release is planned for end of 2015. The new PHP7 structures and engine will allow future optimizations to be added to OPCache, boosting even more a language that already showed several hundreds of percent boost in raw performance, compared to PHP5, with no OPCache solution at all. Nice future to come.</p>]]></content>
    </entry>
        <entry>
        <title>Getting into the Zend Execution engine</title>
                <id>http://jpauli.github.io//2015/02/05/zend-vm-executor.html</id>
                <updated>2015-02-05T00:00:00+00:00</updated>
        <author>
            <name>Julien Pauli</name>
            <email>jpauli@php.net</email>
        </author>
        <link rel="alternate" type="text/html" href="http://jpauli.github.io//2015/02/05/zend-vm-executor.html"/>
        <content type="html" xml:lang="en"><![CDATA[<h2 id="php-an-interpreted-language">PHP : an interpreted language<a href="#php-an-interpreted-language" class="anchor">#</a></h2>
<p>PHP is often defined as a "scripting language" or an "interpreted language". What's that ?</p>
<p>Well, it is a language that won't turn its instructions (its syntax) directly into native machine language, but into an intermediate form, that obviously won't be directly run by the CPU (as this one wouldn't understand the instructions), but by an intermediate code base, itself being written using native machine instructions this time (we use the C language for that nowadays).</p>
<p>That's basically the definition of a <em>software virtual machine</em>. Quoting Wikipedia :</p>
<blockquote>
<p>(...) process virtual machines are designed to execute a single computer program by providing an abstracted and platform-independent program execution environment.
A process VM, sometimes called an application virtual machine, or Managed Runtime Environment (MRE), runs as a normal application inside a host OS and supports a single process. It is created when that process is started and destroyed when it exits. Its purpose is to provide a platform-independent programming environment that abstracts away details of the underlying hardware or operating system, and allows a program to execute in the same way on any platform.</p>
</blockquote>
<p>So, the PHP language, like any interpreted language, is a program that is designed to run abstract instructions in a cross platform way, abstracting away as much of the underlying OS details as possible.
This is technically speaking. It's functional domain is the web (PHP is aimed to solve Web related problems).</p>
<p>Other programming languages relying on a software virtual machine are (non exhaustive list) : Java, Python, C#, Ruby, Pascal, Lua, Perl, Javascript... (and many more).
Basically, every language that is not directly and fully turned into native machine instructions, makes use of a software virtual machine.
Software virtual machines are however allowed - to boost their own performance - to turn some of (but not all) the language instructions they support to direct host machine instructions : this process is called "JIT compilation". PHP does not make use of JIT compilation at the time the lines you are reading are written, but experimentations have been done and such an idea has always been analyzed/talked about.</p>
<p>We nowadays use software virtual machine because we don't want to write those thousands of C lines of code everytime we want to say "Hello" on the user screen.
Software virtual machines advantages over native platform programming :</p>
<ul><li>Ease of use and speed of development</li>
<li>Very often if not in 100% cases : automatic memory management</li>
<li>Abstracts target data types, no low level maths to figure out, no code to rewrite when switching target hardware, etc.</li>
</ul><p>And we could write some drawbacks :</p>
<ul><li>No accuracy on memory management or more generally of global resources usage (trust the VM or die)</li>
<li>Slower than native code : more CPU cycles needed to achieve the same task (JIT tries to narrow the gap, but will never make it disappear)</li>
<li>May abstract too many things, often the programmer is too far from its hardware, which leads to diffculties in understanding the exact impact of the code, especially when the load raises</li>
</ul><p>The last line of drawbacks is why I write such an article.
The more the time passes, the more I note this fact : less and less people master the exact impact of the code they write onto the hardware and the network, which in my opinion is not a good thing.
This often makes me think about someone connecting two wires together, crossing his fingers for the overall system behind him not to blow up. It's not about mastering the whole chain, which is not humanely possible, but at least know what we talk about.</p>
<p>So, let me try to show you what PHP does with the code you write. And when you'll have that good understanding, you can extract it and apply it to any other "interpreted" programming languages, as those may be designed a little bit differently from PHP, they all share a very huge part of the concepts. Usually, the main differences you'll find studying other interpreted languages is about using JIT or not, parallelism of the VM code (using threads mainly, PHP does not make use of any parallelism technic) and memory pooling / garbage collecting algorithms.</p>
<h2 id="the-zend-software-virtual-machine">The Zend software virtual machine<a href="#the-zend-software-virtual-machine" class="anchor">#</a></h2>
<p>The main virtual machine (Zend Virtual Machine) is divided into two huge parts, which are tied together :</p>
<ul><li>A compile stack : understands and turns the PHP language instructions into an intermediate form of any abstract kind</li>
<li>An execution stack : takes the intermediate form of code instructions and run them through a dedicated engine, itself written in C or assembly</li>
</ul><p>We won't talk about part 1 here, but <strong>concentrate on the Zend Virtual machine executor</strong>, a very interesting piece of software, highly optimized, crossplatform, runtime hookable, technically highly challenging. Several thousands of C lines of code are involved in this component design, which is reworked partly at every new PHP version release.</p>
<p>We'll assume PHP 5.6 for our examples.</p>
<p>I admit that there are so many things to say, that I had difficulties on where to start, what to show you and in which order for this article. This is a pretty uncommon situation I'm not really used to, but I can't shrink this blog subject into several ones, because all the pieces are really tied together.
As it is perfectly valid to try understanding the executor without having any knowledge of the compiler, even if those two pieces are narrow bound together; when it comes to dissect the huge executor subject so that you will fully understand every concept, well, it's not that easy.</p>
<p>So remember, its not bad that you ignore how PHP compiler works, you don't need those details to study the executor part. Perhaps I'll write a further article about the PHP compiler some time in the future ?</p>
<p>Let's go.</p>
<h3 id="opcode">OPCode<a href="#opcode" class="anchor">#</a></h3>
<p>You hear this word very often if you read PHP internals stuff, or my blog posts for example. We must first define an "OPCode".
Quoting Wikipedia :</p>
<blockquote>
<p>Opcodes can also be found in so-called byte codes and other representations intended for a software interpreter rather than a hardware device. These software based instruction sets often employ slightly higher-level data types and operations than most hardware counterparts, but are nevertheless constructed along similar lines.</p>
</blockquote>
<p><em>ByteCode</em> and <em>OPCode</em> are two different words of different meanings, but we usually allow swapping them for the same meaning.</p>
<p>We'll assume that <strong>a Zend VM OPCode is one low level virtual machine operation</strong>.
The Zend virtual machine contains many OPCodes : it is able to do many things. As PHP evolves, more and more OPCodes are added, because PHP is able to do more and more things.
You can list all the OPCodes by displaying the content of the <a href="http://lxr.php.net/xref/PHP_5_6/Zend/zend_vm_opcodes.h">Zend/zend_vm_opcodes.h</a> file of the PHP source.</p>
<p>Usually, an OPCode name is self-describing. Examples :</p>
<ul><li>ZEND_ADD : Perform a math addition of its two operands</li>
<li>ZEND_NEW : Create an object (a PHP object)</li>
<li>ZEND_EXIT : Exit PHP</li>
<li>ZEND_FETCH_DIM_W : Fetch the dimension of one operand for Writting purpose</li>
</ul><p>etc... PHP 5.6 owns 167 OPCodes, and we can therefore say that the PHP 5.6 virtual machine executor is able to compute 167 different kinds of operations.</p>
<p>An OPCode, internally, is reprensented by the <em>zend_op</em> structure:</p>
<pre><code>struct _zend_op {
    opcode_handler_t handler; /* The true C function to run */
    znode_op op1; /* operand 1 */
    znode_op op2; /* operand 2 */
    znode_op result; /* result */
    ulong extended_value; /* additionnal little piece of information */
    uint lineno;
    zend_uchar opcode; /* opcode number */
    zend_uchar op1_type; /* operand 1 type */
    zend_uchar op2_type; /* operand 2 type */
    zend_uchar result_type; /* result type */
};</code></pre>
<p>When you want to understand an OPCode, you have to <em>think about a simple calculator machine</em> (really): it is fed by two operands (op1 and op2), you ask it to do exactly one operation (handler), and it gives you a result (result), eventually owning a deduction because of an overflow in the maths operation (extended_value).</p>
<p>That's all, nothing more to add, that is a really easy to understand concept.</p>
<p>Every Zend VM OPCode works exactly the same way : there is a handler, which is a C function that owns the code to run (like "add", which will basicaly perform a maths "+" operation).
This handler can use 0, 1 or 2 operands : op1 and op2, and when you run it, it computes something giving you a result, and eventually an additionnal single piece of information (extended_value).</p>
<p>Let's now see together what the ZEND_ADD OPCode looks like :</p>
<pre><code>ZEND_VM_HANDLER(1, ZEND_ADD, CONST|TMP|VAR|CV, CONST|TMP|VAR|CV)
{
    USE_OPLINE
    zend_free_op free_op1, free_op2;

    SAVE_OPLINE();
    fast_add_function(&amp;EX_T(opline-&gt;result.var).tmp_var,
        GET_OP1_ZVAL_PTR(BP_VAR_R),
        GET_OP2_ZVAL_PTR(BP_VAR_R) TSRMLS_CC);
    FREE_OP1();
    FREE_OP2();
    CHECK_EXCEPTION();
    ZEND_VM_NEXT_OPCODE();
}</code></pre>
<p>Abstract the lines you can read above, because they are not even C valid syntax (we'll come back to this later). However, they are pretty easy to spot.</p>
<p>Like you can see, <code>fast_add_function()</code> is called in this ZEND_ADD OPCode handler (this is a classical C function stored somewhere), and it is passed the result, op1 and op2.
Thus, the code that performs the math addition is stored into this <code>fast_add_function()</code>, no need to open this latter.</p>
<p>At the end, CHECK_EXCEPTION() is called, and ZEND_VM_NEXT_OPCODE(). Let's detail this latter instruction now.</p>
<h3 id="a-giant-loop">A giant loop<a href="#a-giant-loop" class="anchor">#</a></h3>
<p>When a PHP script is compiled, its PHP syntax is turned into several OPCodes, following each other. This is the compiler role, and we won't detail it here.</p>
<p>That means that a PHP script does several things : We talk about a PHP script being turned to "an OP array", which is an array of several OPCodes.
Each OPCode code is ended by ZEND_VM_NEXT_OPCODE(), which tells the executor to fetch the immediately next OPCode, and run it. And so on.</p>
<p>All this happens in a loop, which is detailed here (a little bit simplified) :</p>
<pre><code>ZEND_API void execute_ex(zend_execute_data *execute_data TSRMLS_DC)
{
    zend_bool original_in_execution;
    original_in_execution = EG(in_execution);
    EG(in_execution) = 1;

zend_vm_enter:
    execute_data = i_create_execute_data_from_op_array(EG(active_op_array), 1 TSRMLS_CC);

    while (1) {  /* infinite dispatch loop */
        int ret;

        if ((ret = execute_data-&gt;opline-&gt;handler(execute_data TSRMLS_CC)) &gt; 0) { /* do the job */
            switch (ret) {
                case 1:
                    EG(in_execution) = original_in_execution;
                    return; /* exit from the infinite loop */
                case 2:
                    goto zend_vm_enter;
                    break;
                case 3:
                    execute_data = EG(current_execute_data);
                    break;
                default:
                    break;
            }
        }

    } /* end of infinite dispatch loop */

    zend_error_noreturn(E_ERROR, "Arrived at end of main loop which shouldn't happen");
}</code></pre>
<p>This is what's called the main <strong>Zend Executor dispatch loop</strong>, a while(true), which executes a handler() function, terminated by an instruction (ZEND_VM_NEXT_OPCODE()) telling to change
the <em>execute_data-&gt;opline</em> to the next one into the OPArray.</p>
<pre><code>#define ZEND_VM_NEXT_OPCODE() \
CHECK_SYMBOL_TABLES() \
ZEND_VM_INC_OPCODE(); \
ZEND_VM_CONTINUE()

#define ZEND_VM_INC_OPCODE() \
OPLINE++

#define OPLINE execute_data-&gt;opline

#define ZEND_VM_CONTINUE()         return 0
#define ZEND_VM_RETURN()           return 1
#define ZEND_VM_ENTER()            return 2
#define ZEND_VM_LEAVE()            return 3</code></pre>
<p>Basically, that's a <em>"do operation 1, do operation 2, do operation 3, ..., return and exit"</em> scenario.
We will see how loops are implemented later, for the moment, just think about a basic series of operations.</p>
<h4 id="quick-example">Quick example<a href="#quick-example" class="anchor">#</a></h4>
<p>Here is an easy example to show the main line :</p>
<pre><code>&lt;?php
$a = 8;
$b = 'foo';
echo $a + $b;</code></pre>
<p>This little simple script gets compiled into this OPArray (generated with the help of <a href="pecl.php.net/package/vld">ext/vld</a>) :</p>
<pre><code>compiled vars:  !0 = $a, !1 = $b
line     #* I O op                           fetch          ext  return  operands
-----------------------------------------------------------------------------------
   2     0  &gt;   ASSIGN                                                   !0, 8
   3     1      ASSIGN                                                   !1, 'foo'
   4     2      ADD                                              ~2      !0, !1
         3      ECHO                                                     ~2
   5     4    &gt; RETURN                                                   1</code></pre>
<p><img alt="opcodes" src="../../../img/zend-vm-executor/opcodes.png"></p>
<p>Everyone is OK with that ? We could interpret it as :</p>
<ul><li>Assign 8 to $a</li>
<li>Assign 'foo' to $b</li>
<li>Add the content of $a and $b into a temp variable "~2"</li>
<li>Echo the temp variable "~2"</li>
<li>Return</li>
</ul><p>You may notice a strange RETURN OPCode, the last one. What's that ? Where does this come from ? Well it is easy.</p>
<p>Remember the giant while() loop ? This one is infinite : while(1), go back to analyze this simple loop, you'll notice that the only way to finish it is that the handler() function
returns 1, getting the code into the case 1 of the switch, which holds the 'return' instruction, effectively exiting from the loop.
The RETURN OPCode does nothing else than returning 1, making the Zend VM Executor dispatch loop end, and return.
So yes : every script will end with a RETURN OPCode, if not : the loop would be executed infinitely, not a very good idea right ?</p>
<p>So the PHP compiler has been designed, so that whatever code it compiles, it will end the resulting OP Array with a RETURN statement.
That is to say that compiling a PHP script which is empty (no code at all), will lead to an OPArray containing one unique OPCode : the ZEND_RETURN OPCode. When it is loaded into the VM execution dispatch loop, this latter executes the only RETURN handler code, making the VM return : your empty PHP script does nothing.</p>
<h3 id="oparray">OPArray<a href="#oparray" class="anchor">#</a></h3>
<p>We have used this "OPArray" word many times, let's now define it. We suggested in our usage of this word, that an OPArray is a simple array containing OPCodes to be run sequencialy.
Something like this :</p>
<p><img alt="oparray" src="../../../img/zend-vm-executor/oparray-1.png"></p>
<p>Well, this is not absolutely true, but it's not far from reality.
Here is an OPArray :</p>
<pre><code>struct _zend_op_array {
    /* Common elements */
    zend_uchar type;
    const char *function_name;
    zend_class_entry *scope;
    zend_uint fn_flags;
    union _zend_function *prototype;
    zend_uint num_args;
    zend_uint required_num_args;
    zend_arg_info *arg_info;
    /* END of common elements */

    zend_uint *refcount;
    zend_op *opcodes;
    zend_uint last;
    zend_compiled_variable *vars;
    int last_var;
    zend_uint T;
    zend_uint nested_calls;
    zend_uint used_stack;
    zend_brk_cont_element *brk_cont_array;
    int last_brk_cont;
    zend_try_catch_element *try_catch_array;
    int last_try_catch;
    zend_bool has_finally_block;
    HashTable *static_variables;
    zend_uint this_var;
    const char *filename;
    zend_uint line_start;
    zend_uint line_end;
    const char *doc_comment;
    zend_uint doc_comment_len;
    zend_uint early_binding;
    zend_literal *literals;
    int last_literal;
    void **run_time_cache;
    int  last_cache_slot;
    void *reserved[ZEND_MAX_RESERVED_RESOURCES];
};</code></pre>
<p>As you can see, this is much more things that just a simple array containing OPCodes. This array containing our OPCodes is effectively stored into the zend_op_array structure : at the <em>opcodes</em> index, here :</p>
<pre><code>struct _zend_op_array {
    /* ... */
    zend_op *opcodes; /* Here is the array of OPCodes */
    /* ... */
}</code></pre>
<p>Remember that when the engine compiles a PHP script, the compiler returns an OPArray like this one, this is its only job.</p>
<p>So, an "OPArray" is not just a classic C array of zend_op (OPCodes), it contains in reality some different statistic informations as well as everything that will help every OPCode to run in the most efficient possible maner : <strong>the executor must be as fast as possible, for the PHP script to take as less time as possible to execute</strong>.</p>
<p>Let's detail some of those OPArray informations (the most important ones) :</p>
<ul><li>The current script filename, the line it starts and ends into the PHP script that's been compiled to this OPArray</li>
<li>Informations about documentation comments : the "/**" in PHP</li>
<li>A refcount, as the OPArray itself may be shared elsewhere</li>
<li>A list of compiled variables. Compiled variables are every PHP variable used ($something)</li>
<li>A list of temporary variables. Temp vars are used to hold temporary results not explicitely used into the PHP script (not accessed by $something, but real intermediate data)</li>
<li>Informations about the try-catch-finally eventually compiled into this OPArray, the executor will need those to perform the right jumps to the right places</li>
<li>Informations about the break-continue language constructs eventually compiled into this OPArray, the executor will need those to perform the right jumps to the right places</li>
<li>A list of static variables used, if any. Static variables are specially handled, because they need to retain there info until the very last moment of PHP's life (simplified)</li>
<li>The literals used. Literals represent every compile-time known value, like when we use the string "foo", or the integer 42</li>
<li>Runtime cache slots : This is a place where the engine will cache things it knows it will need later.</li>
</ul><p>Ok, that seems to be many things into this solo structure right ?</p>
<p>There is something important I didn't tell you : <strong>OPArray structures are used both to compile PHP scripts and PHP user functions</strong> and also everything passed to the <code>eval()</code> PHP language construct.
When you write a function in PHP, its whole body will itself be turned into its own OPArray, owning itself the compiled variables used in the function body, the try-catch-finally info used in the function body, etc...</p>
<p>The OPArray structure is the result that the Zend compiler gives when it compiles both a PHP script or a PHP user function/method. That's why you can read informations that seem to be related only to a PHP function, but not to a PHP script : the PHP documentor comment blocks for example.</p>
<p>Ok, back to the point, let's see what our OPArray looks like when it comes to compile our simple little example :</p>
<pre><code>&lt;?php
$a = 8;
$b = 'foo';
echo $a + $b;</code></pre>
<p><img alt="oparray" src="../../../img/zend-vm-executor/oparray-compiled.png"></p>
<p>As you can see from the picture above, this OPArray now contains everything needed for it to be passed into the executor. Remember that the more we compute now (at compile time, that is : while generating the OPArray), the less the executor will have to compute, and it will be able to concentrate on the "real" job : execute the compiled PHP code. We can see that every literal used has been compiled into the <em>literals</em> array (you may spot the integer 1, which comes from the ZEND_RETURN opcode compilation, this latter returning 1), every compiled variable used has been stored into <em>vars</em>, and the compiled OPCodes are here (at <em>opcodes</em> index)</p>
<p>The other zend_op_array fields are mainly empty (zeroed), because the script we compiled is very tiny : it doesn't make any function call, it doesn't contain any try-catch structure, or any break-continue. It is not the result of the compilation of a PHP function, but a PHP script. The OPArray would have been different in such cases, with many of its other fields filled.</p>
<h3 id="zend-vm-operand-types">Zend VM operand types<a href="#zend-vm-operand-types" class="anchor">#</a></h3>
<p>This is the next concept to understand before analyzing in detail the different OPCode handlers.</p>
<p>We know every OPCode handler can use up to two operands : op1 and op2. Each operand represents an OPCode "parameter". For example, the ZEND_ASSIGN OPCode takes as first parameter the PHP variable in which you want to store a value, and as second operand the value you want to assign to the PHP variable. Its result is not used.</p>
<p>The two operands may be of different types, depending what they represent and how they will be used :</p>
<ul><li>IS_CV      : Compiled Variable : this operand type represents a PHP variable : $something</li>
<li>IS_VAR     : Internal VM usage variable that can be reused through other OPCodes, very similar to a $php_variable, but for internal VM usage only</li>
<li>IS_TMP_VAR : Internal VM usage variable that can not be reused through other OPCodes</li>
<li>IS_CONST   : Represents a constant value, frozen, immutable, read-only</li>
<li>IS_UNUSED  : There is no value : the operand holds nothing of interest, ignore it and don't try to read/fetch it</li>
</ul><p>This type specification is important as <strong>it plays a big role in performance and memory management of the overall executor</strong>.
When an OPCode handler wants to fetch (read) the information stored into one of its operand, it won't run the same code to fetch this info : it will run some specialized fetch code depending on the operand type.</p>
<p>Why ? For example, when an OPCode handler wants to fetch an operand (op1 or op2) of type IS_CV, representing a true PHP $variable, it will at the very first time lookup into the symbol table, storing every possible declared variable. Once the lookup is finished, assuming this one succeeds, as it is a Compiled Variable, it is very very likely that one of the next OPCode to be run in the same OPArray will ask as well to fetch this piece of information. So the first fetch caches the pointer result into the OPArray so that any further fetch of this variable value will be much more quick than the very first one.</p>
<p>This was an explanation for IS_CV, but the same applies for every specialized type : we can optimize every access to every OPCode handler operands if we know information about their type (is it shared ? does it need to be freed ? Is it likely to be reused in few time ? etc...).</p>
<p>Now I'm going to detail when the PHP compiler will use each type, for a very simple addition case :</p>
<pre><code>&lt;?php
$a + $b; // IS_CV + IS_CV
1 + $a;  // IS_CONST + IS_CV
foo() + 3 // IS_VAR + IS_CONST
!$a + 3;  // IS_TMP + IS_CONST (2 opcodes involved here, but only one showed)</code></pre>
<h3 id="opcode-specialized-handlers">OPCode specialized handlers<a href="#opcode-specialized-handlers" class="anchor">#</a></h3>
<p>Now we know that each OPCode handler - accepting up to 2 operands (params) - may fetch those operands value in many different ways depending on their type.
If each OPCode handler would have to make a switch() on its two operands, to run a special fetch code depending on their type, we would highly drop performance, because the CPU would have to branch off routines at each OPCode handler run that could not be optimized, because of the highly changing-dynamic nature of them.</p>
<p>Something like this, will just not work in term of performance (pseudo code simplified) :</p>
<pre><code>int ZEND_ADD(zend_op *op1, zend_op *op2)
{
    void *op1_value;
    void *op2_value;

    switch (op1-&gt;type) {
        case IS_CV:
            op1_value = read_op_as_a_cv(op1);
        break;
        case IS_VAR:
            op1_value = read_op_as_a_var(op1);
        break;
        case IS_CONST:
            op1_value = read_op_as_a_const(op1);
        break;
        case IS_TMP_VAR:
            op1_value = read_op_as_a_tmp(op1);
        break;
        case IS_UNUSED:
            op1_value = NULL;
        break;
    }
    /* ... same thing to do for op2 .../

    /* do something with op1_value and op2_value (perform a math addition ?) */
}</code></pre>
<p>Remember, we are designing an OPCode handler, <strong>which could be called thousands of time in a PHP script</strong>. If for each call, we must analyze the
op1 and op2 type, just to run a different fetch/read code, that would not be very nice in term of performance (not dramatic, but still).</p>
<p>A pretty nice solution instead have been developped.</p>
<p>Remember the ZEND_ADD OPCode definition from the source code ? :</p>
<pre><code>ZEND_VM_HANDLER(1, ZEND_ADD, CONST|TMP|VAR|CV, CONST|TMP|VAR|CV)
{
    USE_OPLINE
    zend_free_op free_op1, free_op2;

    SAVE_OPLINE();
    fast_add_function(&amp;EX_T(opline-&gt;result.var).tmp_var,
        GET_OP1_ZVAL_PTR(BP_VAR_R),
        GET_OP2_ZVAL_PTR(BP_VAR_R) TSRMLS_CC);
    FREE_OP1();
    FREE_OP2();
    CHECK_EXCEPTION();
    ZEND_VM_NEXT_OPCODE();
}</code></pre>
<p>Look at the signature of this strange function that is not even some C valid syntax (and thus cant be compiled as-is by a C compiler).</p>
<pre><code>ZEND_VM_HANDLER(1, ZEND_ADD, CONST|TMP|VAR|CV, CONST|TMP|VAR|CV)</code></pre>
<p>This tells that the OPCode handler ZEND_ADD, may accept an op1 of type CONST or TMP or VAR or CV. Same for op2.</p>
<p>Now, here is the magical stuff : the file this code is written in, <a href="http://lxr.php.net/xref/PHP_5_6/Zend/zend_vm_def.h">zend_vm_def.h</a> , is just a template, that is passed into a processor, which will produce some C valid code (this time) for every handler, <strong>for every combinaison of every operand type</strong>.</p>
<p>Maths ? 5 different types for op1 multiplied by 5 different types for op2 : ZEND_ADD will be declined as 25 different sepcialized handler functions, and those ones will be written into a file that will itself be compiled as part of the PHP source code.</p>
<p>This file is named <a href="http://lxr.php.net/xref/PHP_5_6/Zend/zend_vm_execute.h">zend_vm_execute.h</a>, and be carefull as you may have guessed : <strong>it is horribly huge</strong>.</p>
<p>Maths ? We support 167 OPCodes as of PHP5.6 , imagine all those 167 OPCode handlers accept the full 5 possible combinaisons for both their op1 and op2 ...
That gives 4175 C functions to store into this file.</p>
<p>In fact, every OPCode handler will not accept the 5 different possible types of operands, and will lead to less specialized declinations.
For example :</p>
<pre><code>ZEND_VM_HANDLER(84, ZEND_FETCH_DIM_W, VAR|CV, CONST|TMP|VAR|UNUSED|CV)</code></pre>
<p>ZEND_FETCH_DIM_W (fetch a composite entity (array/object) dimension for writing) accepts as op1 only 2 kind : IS_VAR or IS_CV.</p>
<p>But <em>zend_vm_execute.h</em> still counts about <em>45.000</em> lines of C code, get prepared when you want to open this file, it may take more time than usual.</p>
<p>So to sum up :</p>
<ul><li><em>zend_vm_def.h</em> is not valid C file. It describes every OPCode handler flavour (using a custom syntax not far from C), depending on both their op1 and op2 possible types, with a maximum of 5 different type for each operand</li>
<li><em>zend_vm_def.h</em> is passed to a <a href="http://lxr.php.net/xref/PHP_5_6/Zend/zend_vm_gen.php">PHP script called zend_vm_gen.php</a>, stored into the PHP source code, and this file will analyze the special syntax of <em>zend_vm_def.h</em>, using many regular expression matching, and will produce at the end, the final <em>zend_vm_execute.h</em> file you need.</li>
<li><em>zend_vm_def.h</em> is then not part of the PHP compilation process (this file is obviously excluded when it comes to compile PHP)</li>
<li><em>zend_vm_execute.h</em> is the result of the parsing of <em>zend_vm_def.h</em>, and holds valid C syntax, it represents the middle heart of the PHP VM executor : every OPCode handler specialization function is stored into it, this file is absolutely critical.</li>
<li>When you compile PHP from sources, we provide a default <em>zend_vm_execute.h</em>, but if you want to hack, and for example add a new OPCode or modify an existing OPCode behavior, you'll have to hack <em>zend_vm_def.h</em>, and regenerate <em>zend_vm_execute.h</em> from it.</li>
</ul><blockquote>
<p>The funny fact : PHP Virtual Machine Executor is generated using the PHP language itself, aha !</p>
</blockquote>
<p>Here is an example :</p>
<p>We define in <em>zend_vm_def.h</em> the ZEND_ADD OPCode, as this :</p>
<pre><code>ZEND_VM_HANDLER(1, ZEND_ADD, CONST|TMP|VAR|CV, CONST|TMP|VAR|CV)</code></pre>
<p>Passing <em>zend_vm_def.h</em> to the <em>zend_vm_gen.php</em> script, will result into a new <em>zend_vm_execute.h</em> file, which will contain the specialized handlers for this OPCode, and those look like this :</p>
<pre><code>static int ZEND_FASTCALL  ZEND_ADD_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS) { /* handler code */ }
static int ZEND_FASTCALL  ZEND_ADD_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS) { /* handler code */ }
static int ZEND_FASTCALL  ZEND_ADD_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS) { /* handler code */ }
static int ZEND_FASTCALL  ZEND_ADD_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS) { /* handler code */ }
static int ZEND_FASTCALL  ZEND_ADD_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS) { /* handler code */ }
static int ZEND_FASTCALL  ZEND_ADD_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)  { /* handler code */ }

/* etc... I won't write here the 25 declinations ! */</code></pre>
<p>So, the specialized handler will be run depending on the op1 and op2 types, for example :</p>
<pre><code>&lt;?php
$a + 2;  /* IS_CV + IS_CONST */

/* ZEND_ADD_SPEC_CV_CONST_HANDLER() will be run in the VM */</code></pre>
<p>The function name is built dynamically, following this simple model : <em>ZEND_{OPCODE-NAME}_SPEC_{OP1-TYPE}_{OP2-TYPE}_HANDLER()</em></p>
<p>You may wonder then : but if we must choose which specialized function to run for each op1 and op2 types, won't we end up having a huge switch to make such a choice, cancelling the need to have specialized handlers ?</p>
<p>The answer is no : <em>this is resolved at compile time</em> , and as you use an OPCode cache, you won't suffer from the compile time at all.</p>
<p>When the PHP compiler generates OPCodes from the source PHP code, it knows for each of them the type of their respective op1 and op2 (as it is a compiler, it is its role). So the PHP compiler generates an OPArray directly storing the right specialized handler : the execution step has absolutely no choice, no switch() to do : it will be fast, using directly the right specialized handler for each OPCode to run.
If now you change your source code, well, you have to recompile it to generate a new OPArray, this is what OPCode cache solution do.</p>
<p>Ok now, why not see the difference between those handlers ?</p>
<p>Not surprisingly, the only thing that changes in each declination of a same handler, is the way op1 and op2 are fetched. Look :</p>
<pre><code>static int ZEND_FASTCALL  ZEND_ADD_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS) /* CONST_CONST */
{
    USE_OPLINE
    SAVE_OPLINE();
    fast_add_function(&amp;EX_T(opline-&gt;result.var).tmp_var,
        opline-&gt;op1.zv, /* fetch op1 value */
        opline-&gt;op2.zv TSRMLS_CC); /* fetch op2 value */
    CHECK_EXCEPTION();
    ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS) /* CV_CV */
{
    USE_OPLINE
    SAVE_OPLINE();
    fast_add_function(&amp;EX_T(opline-&gt;result.var).tmp_var,
        _get_zval_ptr_cv_BP_VAR_R(execute_data, opline-&gt;op1.var TSRMLS_CC), /* fetch op1 value */
        _get_zval_ptr_cv_BP_VAR_R(execute_data, opline-&gt;op2.var TSRMLS_CC) TSRMLS_CC); /* fetch op2 value */
    CHECK_EXCEPTION();
    ZEND_VM_NEXT_OPCODE();
}</code></pre>
<p>In the CONST_CONST handler (both op1 and op2 are CONST vars), we read them directly using the operand zval value. There is nothing to do such as incrementing or decrementing a counter, freeing the operand value : the value is immutable : simply read it, and we're done.</p>
<p>However, for the CV_CV handler (both op1 and op2 are CV, compiled variables), we must access the value, increment its refcount (because we're gonna use it now) and cache the access for an eventual further read : <code>_get_zval_ptr_cv_BP_VAR_R()</code> does that.
And as it is a "R" fetch : for reading, if the variable doesn't exist, this function will generate a notice : undefined variable. Things would have been different for a "W" access, where if the variable doesn't exist, well, we just need to create it without any warning or notice, isn't that how PHP works ? ;-)</p>
<h3 id="additionnal-informations">Additionnal informations<a href="#additionnal-informations" class="anchor">#</a></h3>
<h4 id="compiler-optimizations">Compiler optimizations<a href="#compiler-optimizations" class="anchor">#</a></h4>
<p>The <em>zend_vm_gen.php</em> may sometimes generate some strange code in <em>zend_vm_execute.h</em>. For example :</p>
<pre><code>static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
    USE_OPLINE

    array_init(&amp;EX_T(opline-&gt;result.var).tmp_var);
    if (IS_CONST == IS_UNUSED) {
        ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CONST != IS_UNUSED
    } else {
        return ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
    }
}</code></pre>
<p>You may read silly statements : <em>if (IS_CONST == IS_UNUSED)</em> for example, or again : <em>#if 0 || IS_CONST != IS_UNUSED</em></p>
<p>This is because the original zend_vm_def.h template code that's been passed for generation of this speciliazed handler, have been written
in such a way, have a look at it :</p>
<pre><code>ZEND_VM_HANDLER(71, ZEND_INIT_ARRAY, CONST|TMP|VAR|UNUSED|CV, CONST|TMP|VAR|UNUSED|CV)
{
    USE_OPLINE

    array_init(&amp;EX_T(opline-&gt;result.var).tmp_var);
    if (OP1_TYPE == IS_UNUSED) {
        ZEND_VM_NEXT_OPCODE();
#if !defined(ZEND_VM_SPEC) || OP1_TYPE != IS_UNUSED
    } else {
        ZEND_VM_DISPATCH_TO_HANDLER(ZEND_ADD_ARRAY_ELEMENT);
#endif
    }
}</code></pre>
<p>When the generator generated code for each specializer, it replaced the <em>OP1_TYPE</em> statement in the code above by each type, generating strange statements, such as <em>if (IS_CONST == IS_UNUSED)</em></p>
<p>But remember, the generated code in <em>zend_vm_execute.h</em> is compiled by a C compiler, and this one will optimize those useless statement by just making them dissapear, resulting in each OPCode handler being highly optimized when turned to machine code by the C compiler , like this :</p>
<pre><code>static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
    array_init(&amp;EX_T(opline-&gt;result.var).tmp_var);
}</code></pre>
<h4 id="zend-vm-executor-generation-customization">Zend VM executor generation customization<a href="#zend-vm-executor-generation-customization" class="anchor">#</a></h4>
<p>The script that generates the VM executor is <em>zend_vm_gen.php</em>, and this one accepts parameters, that means that you can change your PHP current executor code by generating another one. For example, when you pass <em>--without-specializer</em> to this script, it generates a VM executor with no specializers. That means that each OPCode handler will have only one declination (whatever its op1 and op2 types are), and this one will effectively do a big switch() on each operand op1/op2 type when trying to fetch its value :</p>
<pre><code>static int ZEND_FASTCALL  ZEND_ADD_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
    USE_OPLINE
    zend_free_op free_op1, free_op2;

    SAVE_OPLINE();
    fast_add_function(&amp;EX_T(opline-&gt;result.var).tmp_var,
        get_zval_ptr(opline-&gt;op1_type, &amp;opline-&gt;op1, execute_data, &amp;free_op1, BP_VAR_R),
        get_zval_ptr(opline-&gt;op2_type, &amp;opline-&gt;op2, execute_data, &amp;free_op2, BP_VAR_R) TSRMLS_CC);
    FREE_OP(free_op1);
    FREE_OP(free_op2);
    CHECK_EXCEPTION();
    ZEND_VM_NEXT_OPCODE();
}

static inline zval *_get_zval_ptr(int op_type, const znode_op *node, const zend_execute_data *execute_data, zend_free_op *should_free, int type TSRMLS_DC)
{
/*    should_free-&gt;is_var = 0; */
    switch (op_type) {
        case IS_CONST:
            should_free-&gt;var = 0;
            return node-&gt;zv;
            break;
        case IS_TMP_VAR:
            should_free-&gt;var = TMP_FREE(&amp;EX_T(node-&gt;var).tmp_var);
            return &amp;EX_T(node-&gt;var).tmp_var;
            break;
        case IS_VAR:
            return _get_zval_ptr_var(node-&gt;var, execute_data, should_free TSRMLS_CC);
            break;
        case IS_UNUSED:
            should_free-&gt;var = 0;
            return NULL;
            break;
        case IS_CV:
            should_free-&gt;var = 0;
            return _get_zval_ptr_cv(node-&gt;var, type TSRMLS_CC);
            break;
        EMPTY_SWITCH_DEFAULT_CASE()
    }
    return NULL;
}</code></pre>
<p>Why do that ? For debugging and understanding purposes. The <em>zend_vm_execute.h</em> file resulting, with no specializer at all, is 10 times smaller in number of lines that the one with each specializer.
However, when you run some PHP code against this VM executor, it shows something like 10 to 15% performance drop compared to the one with specializers.</p>
<blockquote>
<p>Zend VM executor specializers have been added to PHP 5.1 (2005)</p>
</blockquote>
<p>Another switch is <em>--with-vm-kind=CALL|SWITCH|GOTO</em>.  CALL being the default value.</p>
<p>Remember the main executor while(1) loop we talked about when we introduced the VM ? I refresh your mind rewriting it here (simplified) :</p>
<pre><code>ZEND_API void execute_ex(zend_execute_data *execute_data TSRMLS_DC)
{
    /* ... simplified ... */
    while (1) {
        int ret;

        if ((ret = execute_data-&gt;opline-&gt;handler(execute_data TSRMLS_CC)) &gt; 0) {
            switch (ret) {
                case 1:
                    EG(in_execution) = original_in_execution;
                    return;
                case 2:
                    goto zend_vm_enter;
                    break;
                case 3:
                    execute_data = EG(current_execute_data);
                    break;
                default:
                    break;
            }
        }
    }
    zend_error_noreturn(E_ERROR, "Arrived at end of main loop which shouldn't happen");
}</code></pre>
<p>This is the CALL strategy, it increments a pointer in execute_data-&gt;opline at the end of each OPCode handler, and goes back to the next iteration of the while(1). This is how we go from one OPcode to the next one, until the ZEND_RETURN one.</p>
<p>There exists other strategies to achieve the same goal. Why not use a C goto ? Or a giant C switch ?</p>
<p>This is <em>--with-vm-kind</em> role : it generates 3 different executor control flow strategies. Let's see the C goto one :</p>
<pre><code>ZEND_API void execute_ex(zend_execute_data *execute_data TSRMLS_DC)
{
    /* ... simplified ... */

    while (1) {
        goto *(void**)(execute_data-&gt;opline-&gt;handler);
    }
}</code></pre>
<p>You see that the while(1) is still here, but in the while this time, we goto a function pointer. So for one OPCode handler to give hand to the next one, we will have this time to increment a pointer and use a goto as well :</p>
<pre><code>#define ZEND_VM_INC_OPCODE() execute_data-&gt;opline++
#define ZEND_VM_CONTINUE() goto *(void**)(OPLINE-&gt;handler) /* here is the goto */
#define ZEND_VM_NEXT_OPCODE() \
CHECK_SYMBOL_TABLES() \
ZEND_VM_INC_OPCODE(); \
ZEND_VM_CONTINUE()</code></pre>
<p>CALL is the default strategy for the Zend Executor dispatch loop, because its the one that gives the more performance on an average of target platforms and C compilers. However, depending on your platform and C compiler specific feature, you may find better performance for other implementations, like the goto one, which can be written using specific assembly instructions on some CPU families.</p>
<h4 id="executor-jumps">Executor jumps<a href="#executor-jumps" class="anchor">#</a></h4>
<p>What happens when you use an <em>if</em> statement in PHP ? It is easy : instead of using ZEND_VM_NEXT_OPCODE() and linearly running each OPCode one after one - which prevents us from taking control over the executor path, and thus to implement ifs or loops - we just <strong>jump</strong> to a specific OPCode.</p>
<pre><code>&lt;?php
$a = 8;
if ($a == 9) {
    echo "foo";
} else {
    echo "bar";
}

compiled vars:  !0 = $a
line     #* I O op                           fetch          ext  return  operands
-----------------------------------------------------------------------------------
   3     0  &gt;   ASSIGN                                                   !0, 8
   5     1      IS_EQUAL                                         ~1      !0, 9
         2    &gt; JMPZ                                                     ~1, -&gt;5
   6     3  &gt;   ECHO                                                     'foo'
   7     4    &gt; JMP                                                      -&gt;6
   8     5  &gt;   ECHO                                                     'bar'
  10     6  &gt; &gt; RETURN                                                   1</code></pre>
<p>Notice those ZEND_JMP and ZEND_JMPZ OPCodes ? They just change the control flow :</p>
<pre><code>static int ZEND_FASTCALL  ZEND_JMP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
    USE_OPLINE
    ZEND_VM_SET_OPCODE(opline-&gt;op1.jmp_addr);
    ZEND_VM_CONTINUE();
}

#define ZEND_VM_SET_OPCODE(new_op) \
CHECK_SYMBOL_TABLES() \
execute_data-&gt;opline = new_op</code></pre>
<p>ZEND_VM_SET_OPCODE tells the executor main loop not to basically increment the opline to go and run the immediately next OPCode, but instead to jump the opline to the jump address (jmp_addr) stored into operand op1 of the ZEND_JMP OPCode handler.
This jump address value has been calculated at compile time.</p>
<h2 id="performance-tips">Performance tips<a href="#performance-tips" class="anchor">#</a></h2>
<p>I dont really like this, but I will show you how to optimize your code, based on generated OPcodes.</p>
<p>I don't like this because when people read that, they tend to apply the rules foolishly, without even understanding them, and they don't realize that this won't magically boost their 1200SQL-query-per-page app :-p. Let things into their context please.</p>
<p>However, if you run your code into loops, with thousands of iteration, you will see a difference.</p>
<h3 id="echo-a-concatenation">echo a concatenation<a href="#echo-a-concatenation" class="anchor">#</a></h3>
<p>We can read so many codes like this nowadays :</p>
<pre><code>&lt;?php

$foo = 'foo';
$bar = 'bar';

echo $foo . $bar;</code></pre>
<p>Here is the resulting OPArray :</p>
<pre><code>compiled vars:  !0 = $foo, !1 = $bar
line     #* I O op                           fetch          ext  return  operands
-----------------------------------------------------------------------------------
   3     0  &gt;   ASSIGN                                                   !0, 'foo'
   4     1      ASSIGN                                                   !1, 'bar'
   6     2      CONCAT                                           ~2      !0, !1
         3      ECHO                                                     ~2
   7     4    &gt; RETURN                                                   1</code></pre>
<p>Interesting enough : the engine will concat (ZEND_CONCAT) both $a and $b value into a temporary variable (~2 in the output above), to finally echo it and trash it away.</p>
<p>That means that the engine will have to both create some space for a string into memory, and perform a complex operation : a concatenation - just to echo that and then free the memory back. That seems a little bit too much for such an operation no ?</p>
<p>Why not turn your code to something much like this ? :</p>
<pre><code>&lt;?php

$foo = 'foo';
$bar = 'bar';

echo $foo , $bar;

compiled vars:  !0 = $foo, !1 = $bar
line     #* I O op                           fetch          ext  return  operands
-----------------------------------------------------------------------------------
   3     0  &gt;   ASSIGN                                                   !0, 'foo'
   4     1      ASSIGN                                                   !1, 'bar'
   6     2      ECHO                                                     !0
         3      ECHO                                                     !1
   7     4    &gt; RETURN                                                   1</code></pre>
<p>You see the difference ? Using a comma in echo in perfectly valid, the Zend compiler accepts as many parameters to the "echo" statement as possible (comma separated), and just generates one ZEND_ECHO OPCode for each of them. This is much lighter.</p>
<p>There is both no need to create a temporary buffer into memory, nor to perform a concatenation.</p>
<p>Here is a the ZEND_CONCAT OPCode detail :</p>
<pre><code>ZEND_VM_HANDLER(8, ZEND_CONCAT, CONST|TMP|VAR|CV, CONST|TMP|VAR|CV)
{
    USE_OPLINE
    zend_free_op free_op1, free_op2;

    SAVE_OPLINE();
    concat_function(&amp;EX_T(opline-&gt;result.var).tmp_var,
        GET_OP1_ZVAL_PTR(BP_VAR_R),
        GET_OP2_ZVAL_PTR(BP_VAR_R) TSRMLS_CC);
    FREE_OP1();
    FREE_OP2();
    CHECK_EXCEPTION();
    ZEND_VM_NEXT_OPCODE();
}</code></pre>
<p>And here <a href="http://lxr.php.net/xref/PHP_5_6/Zend/zend_operators.c#1422">is the code for concat_function()</a>. It must :</p>
<ul><li>Check operand one for it to be a string, if not, convert it to string (heavy process)</li>
<li>Check operand two for it to be a string, if not, convert it to string (heavy process)</li>
<li>Allocate a buffer, size it, copy the concat result inside and return it</li>
</ul><p>Here is the code that effectively concats (from <code>concat_function()</code>) :</p>
<pre><code>int length = Z_STRLEN_P(op1) + Z_STRLEN_P(op2);
char *buf = (char *) emalloc(length + 1);

memcpy(buf, Z_STRVAL_P(op1), Z_STRLEN_P(op1));
memcpy(buf + Z_STRLEN_P(op1), Z_STRVAL_P(op2), Z_STRLEN_P(op2));
buf[length] = 0;
ZVAL_STRINGL(result, buf, length, 0);</code></pre>
<p>There is nothing easier to write.</p>
<p>If we provided both two strings, there still needs to access the main memory (code above). This leads to many CPU instructions, and usually (unfortunately), those string data won't be in CPU caches (L1/L2/L3), so the CPU will have to fetch those data from the main memory line. That will cost some nano-seconds (usually dozens), this is pretty light yes, but if the "echo" code concatenating were to be written into a while loop with thousands of iterations, here again, nano-seconds will turn to micro-seconds : just for that single echo line. I personnaly find this silly and would prefer using my CPU time for other things ;-)</p>
<h3 id="define-and-const">define() and const<a href="#define-and-const" class="anchor">#</a></h3>
<p>PHP 5.3 introduced the <code>const</code> keyword, and it has an important impact on execution time.</p>
<p>Simply said :</p>
<ul><li><code>define()</code> is a function call that will suffer from the overhead of a function call into the executor</li>
<li><code>const</code> is a keyword that won't generate a function call OPCode, thus is lighter than <code>define()</code></li>
</ul><p>Now you got it : never use <code>define()</code> to define compile-time known constants (basically, every constant you'll happen to manipulate).</p>
<pre><code>&lt;?php
define('FOO', 'foo');
echo FOO;

line     #* I O op                           fetch          ext  return  operands
-----------------------------------------------------------------------------------
   3     0  &gt;   SEND_VAL                                                 'FOO'
         1      SEND_VAL                                                 'foo'
         2      DO_FCALL                                      2          'define'
   5     3      FETCH_CONSTANT                                   ~1      'FOO'
         4      ECHO                                                     ~1
   6     5    &gt; RETURN                                                   1</code></pre>
<p>That is awfull in term of performance.</p>
<p>I didnt detail how function calls work into the executor in this blog post, because this is terribly complex, and would require the writting of hundreds of additional blog lines.
However, <a href="http://jpauli.github.io/2015/01/22/on-php-funct">I already blogged on the heaviness of function calls into the engine</a>.</p>
<p><code>define()</code> will lead to function call, that will register the constant into the engine, and then the ZEND_FETCH_CONSTANT OPCode will simply read the value.</p>
<p>Look at the following involving <code>const</code> this time :</p>
<pre><code>&lt;?php

const FOO = 'foo';
echo FOO;

line     #* I O op                           fetch          ext  return  operands
-----------------------------------------------------------------------------------
   3     0  &gt;   DECLARE_CONST                                            'FOO', 'foo'
   5     1      FETCH_CONSTANT                                   ~0      'FOO'
         2      ECHO                                                     ~0
   6     3    &gt; RETURN                                                   1</code></pre>
<p>All the function call (for <code>define()</code>) OPCodes have disappeared, and have been replaced by a pretty lighter DECLARE_CONST</p>
<p>There are however little glitches - which are logical, but still - about <code>const</code> and <code>define()</code> :</p>
<ul><li><code>const</code> can't declare conditionnal constants</li>
<li><code>const</code> (DECLARE_CONST) can't obviously use other operand types than IS_CONST</li>
</ul><p>That means that you can't do tings like that with <code>const</code>, but you may do with <code>define()</code> :</p>
<pre><code>&lt;?php

if (foo()) {
    const FOO = 'foo'; /* A compiler rule disallows that */
}</code></pre>
<p>Nor you may write :</p>
<pre><code>&lt;?php
$a = 'FOO';

const $a = 'foo';</code></pre>
<p>If the <code>const</code> structure is more optimized in term of performance, it has some drawbacks about the dynamism of your code.</p>
<h3 id="dynamic-function-calls">dynamic function calls<a href="#dynamic-function-calls" class="anchor">#</a></h3>
<p>No, I won't detail function calls into the engine executor, because they are very very complex to understand. But here, I will show you, without much details, things you should prevent in term of performance.</p>
<p>Prevent calling a function which name is dynamic ( != IS_CONST). When you make a function call, the OPCodes generated by the compiler are very different weither at the time you make the call, the compiler can know the function name, and know that your function exists (or not).</p>
<p>Have a look :</p>
<pre><code>&lt;?php

function foo() { }
foo();

line     #* I O op                           fetch          ext  return  operands
-----------------------------------------------------------------------------------
   3     0  &gt;   NOP                                                      
   5     1      DO_FCALL                                      0          'foo'
   6     2    &gt; RETURN                                                   1</code></pre>
<p>NOP stands for "No Operation". The compiler generated it because of its long history :-). NOP is really 0 second to run, ignore it (OPCache optimizer trashes all of them).</p>
<p>There is here just a DO_FCALL OPCode, that will call to run the function foo()'s OPCode. All right, nothing more to add.</p>
<p>Let's now see a dynamic function call :</p>
<pre><code>&lt;?php

function foo() { }
$a = 'foo';
$a();

line     #* I O op                           fetch          ext  return  operands
-----------------------------------------------------------------------------------
   3     0  &gt;   NOP                                                      
   6     1      ASSIGN                                                   !0, 'foo'
   7     2      INIT_FCALL_BY_NAME                                       !0
         3      DO_FCALL_BY_NAME                              0          
   9     4    &gt; RETURN                                                   1</code></pre>
<p>Ouch. You see that there are now 2 OPCodes about the function call, instead of one, that starts smelling bad for overall performances (but let's see what those OPCode handlers do before concluding).
What you should know, is that the extra INIT_FCALL_BY_NAME is here because the compiler, at its compile time, did not know what function you want it to call, because this time it is into a variable (dynamic function call).</p>
<blockquote>
<p>Remember that the compiler cannot interpret variables, the compiler doesn't know yet what is stored into your variables. Your PHP variables are compiled as CV, they are dynamic by definition, and may retain any kind of information (they could why not hold NULL or even be "undefined variables", who knows at compile time ?). So in this case, <strong>the compiler has no other choice than delaying at runtime the function preparation code and the tables lookup</strong>, which is bad for performance, because something that could be done at compile time, is now delayed at runtime.</p>
</blockquote>
<p>Look at this piece of code from INIT_FCALL_BY_NAME_SPEC_CV_HANDLER (our use case), which I recall, is run because we used a dynamic function call, instead of a compile-time-known function call :</p>
<pre><code>static int ZEND_FASTCALL  ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{

    USE_OPLINE
    zval *function_name;
    call_slot *call = EX(call_slots) + opline-&gt;result.num;

    char *function_name_strval, *lcname;
    int function_name_strlen;
    function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline-&gt;op2.var TSRMLS_CC);

    if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) { /* Are we a string ? */
        function_name_strval = Z_STRVAL_P(function_name);
        function_name_strlen = Z_STRLEN_P(function_name);
        if (function_name_strval[0] == '\\') {
            function_name_strlen -= 1;
            lcname = zend_str_tolower_dup(function_name_strval + 1, function_name_strlen);
        } else {
            lcname = zend_str_tolower_dup(function_name_strval, function_name_strlen);
        }
        if (UNEXPECTED(zend_hash_find(EG(function_table), lcname, function_name_strlen+1, (void **) &amp;call-&gt;fbc) == FAILURE)) {
            zend_error_noreturn(E_ERROR, "Call to undefined function %s()", function_name_strval);
        }
        efree(lcname);

        call-&gt;object = NULL;
        call-&gt;called_scope = NULL;
        call-&gt;num_additional_args = 0;
        call-&gt;is_ctor_call = 0;
        EX(call) = call;

        CHECK_EXCEPTION();
        ZEND_VM_NEXT_OPCODE();
    } else if (IS_CV != IS_CONST &amp;&amp; IS_CV != IS_TMP_VAR &amp;&amp;
        EXPECTED(Z_TYPE_P(function_name) == IS_OBJECT) &amp;&amp;    /* Are we an object (closure) ? */

        /* code simplified and not showed here */

    } else if (IS_CV != IS_CONST &amp;&amp;
            EXPECTED(Z_TYPE_P(function_name) == IS_ARRAY) &amp;&amp;
            zend_hash_num_elements(Z_ARRVAL_P(function_name)) == 2) {  /* Are we an array ? */

    /* code simplified and not showed here */

    }
        if (UNEXPECTED(call-&gt;fbc == NULL)) {
            zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce-&gt;name, Z_STRVAL_PP(method));
        }

        call-&gt;num_additional_args = 0;
        call-&gt;is_ctor_call = 0;
        EX(call) = call;

        CHECK_EXCEPTION();
        ZEND_VM_NEXT_OPCODE();
    } else {
        if (UNEXPECTED(EG(exception) != NULL)) {
            HANDLE_EXCEPTION();
        }
        zend_error_noreturn(E_ERROR, "Function name must be a string");
        ZEND_VM_NEXT_OPCODE(); /* Never reached */
    }

}</code></pre>
<p>And all this analysis code <strong>cannot be cached</strong>, because at the next time you run it (assuming that), well, your <code>$variable_that_is_a_function_name</code> could have change its type, could have disappeared, etc.</p>
<p>More generally speaking, what you have to remember is just trully common sense : <strong>the more you use dynamic features of the PHP language, the more work the executor will have to perform, and the more the overall performances of the language will drop</strong>.</p>
<p>The exact same thing happens for methods, with just one little difference, which is so important for performances : the class may not exist at runtime, and may trigger the autoload, which is a performance chasm in itself. Usage of an OPCode cache really lowers this negative impact.</p>
<h3 id="delayed-class-binding">Delayed class binding<a href="#delayed-class-binding" class="anchor">#</a></h3>
<p>This is the icing on the cake part : classes and inheritance.</p>
<p>Here again, simple words : When class A extends B, you'd better for performances have delcared B before, if not : that will be naughty at runtime.</p>
<p>Let's demonstrates :</p>
<pre><code>&lt;?php

class Bar { }
class Foo extends Bar { }

compiled vars:  none
line     #* I O op                           fetch          ext  return  operands
-----------------------------------------------------------------------------------
   3     0  &gt;   NOP                                                      
   5     1      NOP                                                      
         2      NOP                                                      
   6     3    &gt; RETURN                                                   1</code></pre>
<p>No, there is no error : If you do things the right way, in the right order, <strong>the compiler can take care of all the heavy stuff about class declaration</strong>. You see what the executor has to run here ? NOP, and NOP, and NOP again : nothing (OPCache optimizer will even discard those super light NOPs).</p>
<p>The compiler has done the job (and <strong>declaring a class is really a heavy task for performances</strong>), and once again, because you use an OPCode cache solution, you don't suffer from the compiler time at all.</p>
<p>So, declaring classes in PHP is very light in term of execution, until you move the order of declarations :</p>
<pre><code>&lt;?php
class Foo extends Bar { }
class Bar { }

compiled vars:  none
line     #* I O op                           fetch          ext  return  operands
-----------------------------------------------------------------------------------
   3     0  &gt;   FETCH_CLASS                                   4  :0      'Bar'
         1      DECLARE_INHERITED_CLASS                                  '%00foo%2Ftmp%2Ffoo.php0x7f198b0c401d', 'foo'
   5     2      NOP                                                      
   6     3    &gt; RETURN                                                   1</code></pre>
<p>We declared Foo as extending Bar, but at the time the declaration is read by the compiler, this one doesn't know anything about Bar. So how could it prepare the Foo class into memory for it to be fully ready for the executor to run ? It just can't : that is exactly what a compiler is, and in less dynamic languages, this code would have lead to a "Parse error : class not found" error, end of story. But PHP is more dynamic than this.</p>
<p>The compiler here once again has to delay the class declaration at runtime (something PHP allows), and believe me that class declaration is heavy for the engine, what is heavy is resolving the inheritence tree and add all the functions of all the parents to the actual class, something usually taking some compiler time, but not in our case : it will eat runtime, over, and over , and over again, for a class that will likely never change. What a silly code writing in a performance point of view.</p>
<p>Here, like always, we suffer from the very dynamic nature of PHP, allowing to use an object of a class that it has even not compiled yet ! (autoloaded ?). This is flexible, this is easy to program, but your machine will pay the price of your laziness, as often. Until you use and OPCode cache, particularly OPCache, which optimizes very nicely such cases (and I still have some PR to improve even more this specific case).</p>
<blockquote>
<p>Note that this process also happens for both traits binding, and interface implementations, as internally, classes/traits/interfaces are exactly the same structure and share many processes.</p>
</blockquote>
<p>Still not convinced ?</p>
<pre><code>&lt;?php

class Foo { }

compiled vars:  none
line     #* I O op                           fetch          ext  return  operands
-----------------------------------------------------------------------------------
   3     0  &gt;   NOP                                                      
   4     1    &gt; RETURN                                                   1</code></pre>
<p>Nothing to do at runtime, like we already did demonstrate. Let's add a little bit of dynamism into that :</p>
<pre><code>&lt;?php
if ($a) {
    class Foo  { }
}

compiled vars:  !0 = $a
line     #* I O op                           fetch          ext  return  operands
-----------------------------------------------------------------------------------
   3     0  &gt; &gt; JMPZ                                                     !0, -&gt;3
   4     1  &gt;   DECLARE_CLASS                                    $0      '%00foo%2Ftmp%2Ffoo.php0x7fcef3f9701d', 'foo'
   5     2    &gt; JMP                                                      -&gt;3
   6     3  &gt; &gt; RETURN                                                   1</code></pre>
<p>You pay the price of your dynamism : the class has now to be fully declared and resolved at runtime (ZEND_DECLARE_CLASS OPCode), everytime you run the code. Naughty you !</p>
<h2 id="conclusions">Conclusions<a href="#conclusions" class="anchor">#</a></h2>
<p>This article demonstrated some deep hidden parts of the Zend virtual machine : the executor code. This is the part of PHP source code that makes the "real" job : it executes each single task (each OPCode) the PHP script has been translated to. <strong>This is the most performance critical part of PHP's source code, so it has been designed with perf in mind first</strong>.</p>
<p>That's why when you read this code and you are not really used to software virtual machine design or even low level programming, you may sometimes wonder why things have been written in such a way, that seems so complex to you. The only answer is performance. The C programming language is the only one, to my own knowledge, that allows that many thin level of optimizations, as it is directly turned into target machine assembly instructions, and its compilers are nowadays very mature, as most of them are about 40 years old.</p>
<p>Remember that the PHP virtual machine, as well as its whole source code in fact, <strong>has been worked, hacked, debugged and optimized for nearly 20 years now</strong>, so believe me, if things are done the way they are, it's not random decisions at all.
It even happens we dive one layer lower, and read the assembly code that's been generated by different C compilers when compiling the executor, and then hack the C code to make the compiler generate even more optimized code (the C compiler can usually be told many tweaks). Also, some critical parts of the Zend virtual machine are written directly in assembly (uncommon, but still happens).</p>
<p>Finally, you can play with that yourself : you must design a zend_extension. A PHP extension can also do many things, but when it comes to play with the executor and the OPArrays, it is better to do that in a zend_extension, because those have much more power than classical PHP extensions.
For exemple OPCache is a zend_extension, because it plays heavilly with the OPCodes in the OPArray, mainly to both optimize them (finding unreachable statement etc... using what's called compiler passes) and cache them to be able to reuse them at the next request, preventing the so heavy compiler to fire up.</p>
<p><a href="https://blackfire.io/">The Blackfire profiler</a> extension code I work on in my daily job, will soon be able to warn you about such idiot statement in term of performance, and many more I could not show you here ;-)</p>]]></content>
    </entry>
        <entry>
        <title>On PHP function calls</title>
                <id>http://jpauli.github.io//2015/01/22/on-php-function-calls.html</id>
                <updated>2015-01-22T00:00:00+00:00</updated>
        <author>
            <name>Julien Pauli</name>
            <email>jpauli@php.net</email>
        </author>
        <link rel="alternate" type="text/html" href="http://jpauli.github.io//2015/01/22/on-php-function-calls.html"/>
        <content type="html" xml:lang="en"><![CDATA[<h2 id="introducting-the-facts">Introducting the facts<a href="#introducting-the-facts" class="anchor">#</a></h2>
<p>This blog post is a technical explanation of a PHP optimization found with <a href="https://blackfire.io/">Blackfire profiler</a> into a PHP script.
The related post is located here : <a href="http://blog.blackfire.io/owncloud.html"><a href="http://blog.blackfire.io/owncloud.html">http://blog.blackfire.io/owncloud.html</a></p>
<p>Basically, it concludes with :</p>
<pre><code>if (strlen($name) &gt; 49) {
...
}</code></pre>
<p>Beeing about 20% slower than</p>
<pre><code>if (isset($name[49])) {
...
}</code></pre>
<p>Which is perfectly normal.</p>
<p>Hang on. You were going to stop reading here, to go browse your codebase and replace <code>strlen()</code> calls by <code>isset()</code> calls. So that's why I stopped you.
If you read carefully <a href="http://blog.blackfire.io/owncloud.html">the original blog post</a>, this performance result boost of about 20% is obtained because <code>strlen()</code> was used in a loop
of about 60 to 80K iterations (60,000 to 80,000).</p>
<h2 id="why-such-a-result">Why such a result ?<a href="#why-such-a-result" class="anchor">#</a></h2>
<p>It's not the way <code>strlen()</code> computes the length that's in cause. Because the length of every PHP string is always known when <code>strlen()</code> is called. A big part of such lengths are even computed at compile time, when possible.
PHP encapsulates the length of the string into the C structure carrying a PHP string, when it creates such string into memory. So <code>strlen()</code> just reads that little info, and returns it to you as-is.
In fact, <code>strlen()</code> is probably the fastest PHP function that exists. It just does nothing in term of computation. Here is its source code:</p>
<pre><code>ZEND_FUNCTION(strlen)
{
    char *s1;
    int s1_len;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &amp;s1, &amp;s1_len) == FAILURE) {
        return;
    }

    RETVAL_LONG(s1_len);
}</code></pre>
<p>Knowing that <code>isset()</code> is not a function, the ~20% perf penalty of <code>strlen()</code> over <code>isset()</code> is mainly brought by the overhead of a function call in the Zend Engine.</p>
<p>There is another thing to say as well : comparing the result of <code>strlen()</code> with something, adds an extra OPCode, whereas using just an <code>isset()</code>, represents one unique OPCode.</p>
<p>Here is the <em>if(strlen())</em> construct disassembled :</p>
<pre><code>line     #* I O op                           fetch          ext  return  operands
-----------------------------------------------------------------------------------
   3     0  &gt;   SEND_VAR                                                 !0
         1      DO_FCALL                                      1  $0      'strlen'
         2      IS_SMALLER                                       ~1      42, $0
         3    &gt; JMPZ                                                     ~1, -&gt;5
   5     4  &gt; &gt; JMP                                                      -&gt;5
   6     5  &gt; &gt; RETURN                                                   1</code></pre>
<p>And here is the semanticaly equivalent <em>if(isset())</em> structure disassembled :</p>
<pre><code>line     #* I O op                           fetch          ext  return  operands
-----------------------------------------------------------------------------------
   3     0  &gt;   ISSET_ISEMPTY_DIM_OBJ                       33554432  ~0      !0, 42
         1    &gt; JMPZ                                                  ~0, -&gt;3
   5     2  &gt; &gt; JMP                                                       -&gt;3
   6     3  &gt; &gt; RETURN                                                     1</code></pre>
<p>As you can see, there is no function call involved into the <code>isset()</code> code (<strong>DO_FCALL</strong>), as well as there is no <strong>IS_SMALLER</strong> OPCode (just ignore the RETURN statements).
<code>isset()</code> will directly return a boolean for evaluation, whereas <code>strlen()</code> will return a temporary variable, passed to <strong>IS_SMALLER</strong> OPCode, and only this OPCode result will be evaluated by the <code>if()</code>.
That's two OPCodes for the <code>strlen()</code> code structure and only one for the <code>isset()</code> one, which lets us smell that the <code>isset()</code> structure will also be faster because of this fact. (computing two operations is usually slower that computing just one).</p>
<p>Let's now analyze how function calls work in PHP, and how they are different from <code>isset()</code>.</p>
<h2 id="php-function-calls-in-deep">PHP function calls in deep<a href="#php-function-calls-in-deep" class="anchor">#</a></h2>
<p>Let me warn you : function calls are complex in PHP. If you want to continue reading this part, you'd better fasten your seat belt ;-)
In PHP's design and source code, the most complex VM (VM = Virtual Machine = PHP execution stage code) part to analyze is all that's related to function calls.
I will try to sumarize things here, so that you get enough info to understand, without all the full details related to function calls. You still can fetch them by analyzing the source code.</p>
<p>Here, we will talk about <em>runtime</em> of a function call. You should know that the <em>compile time</em> PHP function related operations are also heavy to run for the machine (I mean, really heavy), but as you use an OPCode cache, you don't suffer from anything related to compile time.
So here, we assume the script is compiled, and we'll analyze what happens at <em>runtime</em> only.</p>
<p>Let's just dump the OPCode of an internal function call (<code>strlen()</code>, here) :</p>
<pre><code>strlen($a);

line     #* I O op                           fetch          ext  return  operands
-----------------------------------------------------------------------------------
3     0  &gt;   SEND_VAR                                                 !0
      1      DO_FCALL                                      1          'strlen'</code></pre>
<p>To understand function calls, one should know those points :</p>
<ul><li>Function calls and method calls are exactly the same</li>
<li>User functions calls and internal functions calls are differently handled</li>
</ul><p>That's why I talked about an "internal" function call in my last statement, because I show an example of a call to an internal PHP function, that is a PHP function that's designed in C, here : PHP's <code>strlen()</code>. If we were dumping the OPCode of a "user" PHP function - that is a function that a programmer wrote using the PHP language - OPCode could have been different, but they could have been exactly the same as well.</p>
<p>This is because PHP doesn't generate the same OPCode weither at compile time it knows the function, or not.
Obviously, internal PHP functions are known at compile time (because they are discovered before the compiler even starts), but that is not necessary true for user functions, which can be called without having been declared before, but after.
Also, when talking about the execution, internal PHP functions are more efficient than user PHP functions, as well as internal benefit from more validation mechanisms than user functions.</p>
<p>Let's continue with the internal functions examples, and the <code>strlen()</code> one just above.
On the OPCode shown above, we can see that a function call is not managed using just one OPCode. In fact, there is a first thing you should remember when talking about functions : they own a stack.
Like in C, or in every language, when you want to call a function, you first have to build what's called a stack frame, and push onto this stack frame the arguments for the function.
Then, you call the function, and this one will most likely pop those arguments from the stack, to use them.
Once the function call is done, you have to destroy the stack frame you allocated to it.</p>
<p>This is the main rule of doing things, but PHP optimizes the stack frame creation and deletion and delay those operations so that they don't get called at every function call.</p>
<p><strong>SEND_VAR</strong> is an opcode that is responsible of pushing args onto the stack frame. The compiler inevitably generates such an OPCode before a function call. And there will be as many of them as there are variables to pass to the function. See :</p>
<pre><code>$a = '/';
setcookie('foo', 'bar', 128, $a);

line     #* I O op                           fetch          ext  return  operands
-----------------------------------------------------------------------------------
   3     0  &gt;   ASSIGN                                                   !0, '%2F'
   4     1      SEND_VAL                                                 'foo'
         2      SEND_VAL                                                 'bar'
         3      SEND_VAL                                                 128
         4      SEND_VAR                                                 !0
         5      DO_FCALL                                      4          'setcookie'</code></pre>
<p>This shows another OPCode : <strong>SEND_VAL</strong>. In fact, there exists 4 opcodes to send something on the function stack :</p>
<ul><li><strong>SEND_VAL</strong> : sends a compile-time constant value (a string, an int, etc...)</li>
<li><strong>SEND_VAR</strong> : sends a PHP variable ($a)</li>
<li><strong>SEND_REF</strong> : sends a PHP variable beeing a reference, to a function accepting its arg by reference</li>
<li><strong>SEND_VAR_NO_REF</strong>: Optimized handler used in case of nested function calls</li>
</ul><p>We'll just foresee <strong>SEND_VAR</strong>. What does <strong>SEND_VAR</strong> do ?</p>
<pre><code>ZEND_VM_HELPER(zend_send_by_var_helper, VAR|CV, ANY)
{
    USE_OPLINE
    zval *varptr;
    zend_free_op free_op1;
    varptr = GET_OP1_ZVAL_PTR(BP_VAR_R);

    if (varptr == &amp;EG(uninitialized_zval)) {
        ALLOC_ZVAL(varptr);
        INIT_ZVAL(*varptr);
        Z_SET_REFCOUNT_P(varptr, 0);
    } else if (PZVAL_IS_REF(varptr)) {
        zval *original_var = varptr;

        ALLOC_ZVAL(varptr);
        ZVAL_COPY_VALUE(varptr, original_var);
        Z_UNSET_ISREF_P(varptr);
        Z_SET_REFCOUNT_P(varptr, 0);
        zval_copy_ctor(varptr);
    }
    Z_ADDREF_P(varptr);
    zend_vm_stack_push(varptr TSRMLS_CC);
    FREE_OP1();  /* for string offsets */

    CHECK_EXCEPTION();
    ZEND_VM_NEXT_OPCODE();
}</code></pre>
<p>It checks if your variable is a reference or not. If it is, it separates it, creating a reference mismatch, and that's bad. <a href="http://jpauli.github.io/2014/06/27/references-mismatch.html">I explain
that in this article</a>.
Then it adds a refcount to the variable, and pushes it onto the VM stack :</p>
<pre><code>Z_ADDREF_P(varptr);
zend_vm_stack_push(varptr TSRMLS_CC);</code></pre>
<p>Yes, everytime you call a function, you increment the refcount of every stack argument variable by one : because the function stack itself will reference the variable, not yet the function code, just the stack at the moment.</p>
<p>Pushing the variable onto the stack is pretty light, but the stack consumes some memory. It is allocated at execution time, but its size is computed at compile time.</p>
<p>After pushing the args onto the stack, we run <strong>DO_FCALL</strong>, and here, you'll see how many tons of code and checks are performed, allowing us to assume PHP function calls are a "slow" statement :</p>
<pre><code>ZEND_VM_HANDLER(60, ZEND_DO_FCALL, CONST, ANY)
{
    USE_OPLINE
    zend_free_op free_op1;
    zval *fname = GET_OP1_ZVAL_PTR(BP_VAR_R);
    call_slot *call = EX(call_slots) + opline-&gt;op2.num;

    if (CACHED_PTR(opline-&gt;op1.literal-&gt;cache_slot)) {
        EX(function_state).function = CACHED_PTR(opline-&gt;op1.literal-&gt;cache_slot);
    } else if (UNEXPECTED(zend_hash_quick_find(EG(function_table), Z_STRVAL_P(fname), Z_STRLEN_P(fname)+1, Z_HASH_P(fname), (void **) &amp;EX(function_state).function)==FAILURE)) {
        SAVE_OPLINE();
        zend_error_noreturn(E_ERROR, "Call to undefined function %s()", fname-&gt;value.str.val);
    } else {
        CACHE_PTR(opline-&gt;op1.literal-&gt;cache_slot, EX(function_state).function);
    }
    call-&gt;fbc = EX(function_state).function;
    call-&gt;object = NULL;
    call-&gt;called_scope = NULL;
    call-&gt;is_ctor_call = 0;
    EX(call) = call;

    FREE_OP1();

    ZEND_VM_DISPATCH_TO_HELPER(zend_do_fcall_common_helper);
}</code></pre>
<p>As you can see, here, we perform some little checks. And many caches are used. For example, the function handler pointer is looked up at the
very first call, then it is cached into the main VM frame, so that any further call will use the cached pointer.
Many cache tricks are used into the Zend VM, for it to be as efficient as possible.</p>
<p>After that, we call <strong>zend_do_fcall_common_helper()</strong>.
I can't copy the code of this function here, as it is so huge.
I will show you what operations are done into it. Basically, many checks are done, and they all are done now : at runtime, because once more of the heavilly dynamic nature of PHP.
PHP can define new functions at runtime, and PHP can autoload files, defining classes and functions at runtime, so PHP must perform a lot of its checks at runtime, and this is bad for performance, but that's the design of a dynamic language, those are othogonal concepts.</p>
<pre><code>if (UNEXPECTED((fbc-&gt;common.fn_flags &amp; (ZEND_ACC_ABSTRACT|ZEND_ACC_DEPRECATED)) != 0)) {
        if (UNEXPECTED((fbc-&gt;common.fn_flags &amp; ZEND_ACC_ABSTRACT) != 0)) {
            zend_error_noreturn(E_ERROR, "Cannot call abstract method %s::%s()", fbc-&gt;common.scope-&gt;name, fbc-&gt;common.function_name);
            CHECK_EXCEPTION();
            ZEND_VM_NEXT_OPCODE(); /* Never reached */
        }
        if (UNEXPECTED((fbc-&gt;common.fn_flags &amp; ZEND_ACC_DEPRECATED) != 0)) {
            zend_error(E_DEPRECATED, "Function %s%s%s() is deprecated",
                fbc-&gt;common.scope ? fbc-&gt;common.scope-&gt;name : "",
                fbc-&gt;common.scope ? "::" : "",
                fbc-&gt;common.function_name);
        }
    }
    if (fbc-&gt;common.scope &amp;&amp;
        !(fbc-&gt;common.fn_flags &amp; ZEND_ACC_STATIC) &amp;&amp;
        !EX(object)) {

        if (fbc-&gt;common.fn_flags &amp; ZEND_ACC_ALLOW_STATIC) {
            /* FIXME: output identifiers properly */
            zend_error(E_STRICT, "Non-static method %s::%s() should not be called statically", fbc-&gt;common.scope-&gt;name, fbc-&gt;common.function_name);
        } else {
            /* FIXME: output identifiers properly */
            /* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
            zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically", fbc-&gt;common.scope-&gt;name, fbc-&gt;common.function_name);
        }
    }</code></pre>
<p>See all those checks ? Let's continue, because it's far from beeing finished :</p>
<pre><code>if (fbc-&gt;type == ZEND_USER_FUNCTION || fbc-&gt;common.scope) {
    should_change_scope = 1;
    EX(current_this) = EG(This);
    EX(current_scope) = EG(scope);
    EX(current_called_scope) = EG(called_scope);
    EG(This) = EX(object);
    EG(scope) = (fbc-&gt;type == ZEND_USER_FUNCTION || !EX(object)) ? fbc-&gt;common.scope : NULL;
    EG(called_scope) = EX(call)-&gt;called_scope;
}</code></pre>
<p>You know that each function body has its own variable scope. Well it's not magical : the engine switches the scope tables before calling the function code, so that if this one asks for a variable, it will be looked for into the right table.
And as functions and methods are all the same, you can read some instructions about binding the <code>$this</code> pointer for a method.
Let's keep going.</p>
<pre><code>if (fbc-&gt;type == ZEND_INTERNAL_FUNCTION) {</code></pre>
<p>I told you, internal functions (those designed in C) take a different execution path from user functions. Usually, internal function execution path is more optimized and shorter than user function one, because for internal functions, in C, we can tell the engine internal info about our function, something user designed functions cant.</p>
<pre><code>fbc-&gt;internal_function.handler(opline-&gt;extended_value, ret-&gt;var.ptr, (fbc-&gt;common.fn_flags &amp; ZEND_ACC_RETURN_REFERENCE) ? &amp;ret-&gt;var.ptr : NULL, EX(object), RETURN_VALUE_USED(opline) TSRMLS_CC);</code></pre>
<p>This line above is the line that calls the internal function handler. For our <code>strlen()</code> example, this above line call the <code>strlen()</code> source code :</p>
<pre><code>/* PHP's strlen() source code */
ZEND_FUNCTION(strlen)
{
    char *s1;
    int s1_len;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &amp;s1, &amp;s1_len) == FAILURE) {
        return;
    }

    RETVAL_LONG(s1_len);
}</code></pre>
<p>And what does <code>strlen()</code> ? It pops the argument stack using <code>zend_parse_parameters()</code>.
And this zend_parse_parameters() function is "slow", because it has to pop the stack and transform the argument to a type which is expected by the function : for <code>strlen()</code> : a string.
So whatever the programmer passed onto the stack to <code>strlen()</code>, this one could need to convert the argument to a string, which is not a light process in term of performance.
<a href="http://lxr.php.net/xref/PHP_5_5/Zend/zend_API.c#729">Read the source of zend_parse_parameters()</a> to have an idea on how many operations we ask our CPU to do, when poping the arguments from a function stack frame.</p>
<p>Let's continue into the execution, we just executed the function body code, now, let's cleanup things, starting by restoring the scope :</p>
<pre><code>if (should_change_scope) {
        if (EG(This)) {
            if (UNEXPECTED(EG(exception) != NULL) &amp;&amp; EX(call)-&gt;is_ctor_call) {
                if (EX(call)-&gt;is_ctor_result_used) {
                    Z_DELREF_P(EG(This));
                }
                if (Z_REFCOUNT_P(EG(This)) == 1) {
                    zend_object_store_ctor_failed(EG(This) TSRMLS_CC);
                }
            }
            zval_ptr_dtor(&amp;EG(This));
        }
        EG(This) = EX(current_this);
        EG(scope) = EX(current_scope);
        EG(called_scope) = EX(current_called_scope);
    }</code></pre>
<p>And clearing the stack :</p>
<pre><code>zend_vm_stack_clear_multiple(1 TSRMLS_CC);</code></pre>
<p>Finally, if an exception has been thrown during this function execution, we must change the VM path to run the catch block (simplified) :</p>
<pre><code>if (UNEXPECTED(EG(exception) != NULL)) {
        zend_throw_exception_internal(NULL TSRMLS_CC);
        if (RETURN_VALUE_USED(opline) &amp;&amp; EX_T(opline-&gt;result.var).var.ptr) {
            zval_ptr_dtor(&amp;EX_T(opline-&gt;result.var).var.ptr);
        }
        HANDLE_EXCEPTION();
    }</code></pre>
<h3 id="a-conclusion-on-php-function-calls">A conclusion on PHP function calls ?<a href="#a-conclusion-on-php-function-calls" class="anchor">#</a></h3>
<p>Now, can you imagine the time your machine spends for calling a very-tiny-and-simple <code>strlen()</code> function ?
Now multiply this time, because <code>strlen()</code>is called into a loop, with 25,000 iterations, slowly, micro/milli seconds turn to seconds...
Keep in mind that I just showed you the hot path of instructions beeing run at every PHP function call. Many other things happen as well next to those mandatory steps.
Also keep in mind that here, because <code>strlen()</code> "useful work" is just one line, the overhead of the engine preparing the function call is larger than the useful function code itself, but that is generaly not the case of a big average of function calls, where the own code of the function itself will consume hopefuly more performance than the noisy surrounding engine code.</p>
<p>You may complain about this. You have this right, but please, don't come to me complaining without proposing a valid technical solution to improve this, knowing that if you break compatibility, you'll have to show strong arguments about this ;-)</p>
<p>The PHP-function-call-related part of the code has been reworked into PHP7 (among many things), and in PHP7, function calls are faster than this. As you can imagine by reading this : there is lot of room for optimization yet into PHP source code, and we, as contributors, try to find ways to optimize things at every new PHP version.</p>
<p>Not only talking about PHP7, the PHP-function-call-related code has been optimized in every version of PHP, from 5.3 to 5.4, and especially from 5.4 to 5.5, where we changed the way the stack frame is computed and created, for example (without breaking compatibility).
It is always interesting to read the readme about internals change of each PHP version. <a href="https://github.com/php/php-src/blob/PHP-5.5/UPGRADING.INTERNALS#L24">Here is the one for PHP5.5</a> talking about changes into the executor and into how function calls are performed, compared to PHP54.</p>
<p>As a conclusion, remember that this is not a blame to PHP. The PHP source code has been worked for twenty years now, by many different very talented brains, so believe me : it has been thought, worked and optimized many times as of nowadays.
The proof is that you use PHP, you have some PHP code in production, and it just works and perform very well, with a nice overall performance factor in the very large majority of use cases. Am I wrong ?</p>
<h3 id="what-about-isset">What about isset() ?<a href="#what-about-isset" class="anchor">#</a></h3>
<p><code>isset()</code> is not a function. Parenthesis don't automatically mean "function call". <code>isset()</code> is compiled into a special Zend VM OPcode (<strong>ISSET_ISEMPTY</strong>), which will not trigger a function call and suffer from function call overhead we have detailed in the last chapter.</p>
<p>As <code>isset()</code> can take several parameter types, its Zend VM code is a little bit long, but just isolating the parameter-is-a-string-offset part, it leads to this :</p>
<pre><code>ZEND_VM_HELPER_EX(zend_isset_isempty_dim_prop_obj_handler, VAR|UNUSED|CV, CONST|TMP|VAR|CV, int prop_dim)
{
    USE_OPLINE zend_free_op free_op1, free_op2; zval *container; zval **value = NULL; int result = 0; ulong hval; zval *offset;

    SAVE_OPLINE();
    container = GET_OP1_OBJ_ZVAL_PTR(BP_VAR_IS);
    offset = GET_OP2_ZVAL_PTR(BP_VAR_R);

    /* ... code pruned ... */
    } else if (Z_TYPE_P(container) == IS_STRING &amp;&amp; !prop_dim) { /* string offsets */
        zval tmp;
        /* ... code pruned ...&nbsp;*/
        if (Z_TYPE_P(offset) == IS_LONG) { /* we passed an integer as offset */
            if (opline-&gt;extended_value &amp; ZEND_ISSET) {
                if (offset-&gt;value.lval &gt;= 0 &amp;&amp; offset-&gt;value.lval &lt; Z_STRLEN_P(container)) {
                    result = 1;
                }
            } else /* if (opline-&gt;extended_value &amp; ZEND_ISEMPTY) */ {
                if (offset-&gt;value.lval &gt;= 0 &amp;&amp; offset-&gt;value.lval &lt; Z_STRLEN_P(container) &amp;&amp; Z_STRVAL_P(container)[offset-&gt;value.lval] != '0') {
                    result = 1;
                }
            }
        }
        FREE_OP2();
    } else {
        FREE_OP2();
    }

    Z_TYPE(EX_T(opline-&gt;result.var).tmp_var) = IS_BOOL;
    if (opline-&gt;extended_value &amp; ZEND_ISSET) {
        Z_LVAL(EX_T(opline-&gt;result.var).tmp_var) = result;
    } else {
        Z_LVAL(EX_T(opline-&gt;result.var).tmp_var) = !result;
    }

    FREE_OP1_VAR_PTR();

    CHECK_EXCEPTION();
    ZEND_VM_NEXT_OPCODE();
}</code></pre>
<p>Appart from many decision points (many ifs structures), the real hot computing algorithm here can be summed up in one line :</p>
<pre><code>if (offset-&gt;value.lval &gt;= 0 &amp;&amp; offset-&gt;value.lval &lt; Z_STRLEN_P(container))</code></pre>
<p>If the offset is positive (you did not mean <code>isset($a[-42])</code>), and it is stricly less than the length of the string,
result will be passed 1, and then the resulting operation will be the boolean TRUE.
Don't worry about the length computation : <code>Z_STRLEN_P(container)</code> will not compute anything. Remember that PHP already knows the length
of your string, <code>Z_STRLEN_P(container)</code> just read that value in memory : very few CPU cycles are needed for that.</p>
<p>Now I think you understand that there are much much more CPU instructions involved in the PHP function call of <code>strlen()</code> than in the
use of <code>isset()</code> in the case of a string offset. You see how <code>isset()</code> is light ? Don't be scared by many if statements, they are not the heaviest parts of the C code and can be optimized in some ways by the C compiler.
The <code>isset()</code> handler code doesn't lookup hashtables, doesn't perform any complex check, doesn't push any pointer to any stack frame, to pop them back later, eventually transforming the data...
The code is way lighter than the overall code of a function call, with many less memory accesses (this is the most important part to notice). And in this particular case of a string : it leads to a huge improvement if you were iterating this code over and over again into a loop.
Of course, if you just run one iteration of comparison between <code>strlen()</code> and <code>isset()</code>, you will find the performance benefit really low, about 5ms difference, something like that. But multiplied by 50,000 iterations...</p>
<p>Notice as well, <a href="http://lxr.php.net/xref/PHP_5_5/Zend/zend_vm_def.h#4445">by reading the whole isset() source code</a>, that it is shared with the <code>empty()</code> code.
<code>empty()</code> on a string offset will differ from the same <code>isset()</code> statement by just additionnaly reading if the first character of the
string is not the '0' character.
<code>empty()</code> and <code>isset()</code> lead to the exact same code beeing run, with just one little tiny diff somewhere, so <code>empty()</code> will have the exact same performance impact that <code>isset()</code> (assuming you use both with the same parameter)</p>
<h2 id="what-can-opcache-do-for-us">What can OPCache do for us ?<a href="#what-can-opcache-do-for-us" class="anchor">#</a></h2>
<p>Short answer : Nothing.</p>
<p>OPCache optimizes your code. I talked about this many times in worldwide conferences, you may fetch my slides at <a href="http://fr.slideshare.net/jpauli/yoopee-cache-op-cache-internals"><a href="http://fr.slideshare.net/jpauli/yoopee-cache-op-cache-internals">http://fr.slideshare.net/jpauli/yoopee-cache-op-cache-internals</a> for example.</p>
<p>We've been asked on github if we could add an optimization pass that would switch <code>strlen()</code> to <code>isset()</code> : That's not possible.</p>
<p>Remember that OPCache optimization passes act on the OPArray before storing it into shared memory. <em>This happens at compile time and not
at runtime</em>. But at compile time, how can we know that the variable you pass to <code>strlen()</code> is a string ? We can't. That's the PHP problem,
and that's a part of how HHVM/Hack solved it. If we could type our variables in PHP, that is, supporting strong typing, then we could optimize
much more things in compiler passes (as well as into the VM).
Because of the dynamic nature of PHP, nearly nothing is known at compile time. The only thing OPCache can optimize are static, compile-time-known things.
For example, this can be optimized by OPCache :</p>
<pre><code>if (strlen("foo") &gt; 8) {
 /* do domething */
} else {
 /* do something else */
}</code></pre>
<p>At compile time, we know here that "foo"'s string length is not above 8, and we can trash all the if() opcodes as well as the "true" part of
the if, and just run the "else" part.
But here :</p>
<pre><code>if (strlen($a) &gt; 8) {
 /* do domething */
} else {
 /* do something else */
}</code></pre>
<p>What is in $a ? Does even $a exist here ? Is it a string ?
At the time the optimizer shows in, it just can't answer those questions, that is the VM executor role. At compile time, we end up handling abstract structure with no real type yet, type and related memory usage will be known/allocated at runtime only.</p>
<p>OPCache optimizer already optimizes many things, but by the heavilly dynamic nature of the PHP language, we can't optimize everything, at least not as much as in Java's compilers, or even C's compilers.</p>
<p>That's why when I hear proposal to add strong typing to the language, I like it, because it will boost the performance.
But PHP will never be a strongly typed language ;-)</p>
<p>Also, proposal such as adding a read-only hint to class property declaration :</p>
<pre><code>class Foo {
    public read-only $a = "foo";
}</code></pre>
<p>Not talking about the functionnality itself, my mind is tied to performance : such proposals are really nice in term of performance optimization, because here, when we compile such class, we know the value of $a, and we know it can't
change, so we can store its value somewhere, use a cached pointer, and strongly optimize every access to such a variable into weither
PHP compiler, or OPCache optimization passes.</p>
<p>This case really looks like managing a constant, but I think you understood the base line here : the more informations you can give to the compiler about the type and the usage of your variables or functions, the more it will be able to optimize the OPCode for the VM and the structures used, to get closer to what the CPU will need. A good tradeoff between those two concepts is called "JIT" compilation, a subject I won't talk about in this article.</p>
<h2 id="optimization-tips-and-conclusion">Optimization tips and conclusion<a href="#optimization-tips-and-conclusion" class="anchor">#</a></h2>
<p>The first tip I would like to share with you, is to not blindly change your code, everywhere you have a good feeling of it.
Profile. Profile, and see the results.
With profilers such as <a href="https://blackfire.io/">Blackfire</a>, you can immeditely see the hot path of your script, because it automaticaly trashes the irrelevant
information that usually catch your eyes when you read a profile.
You then know <em>where</em> to start working, because your work costs money, and for it to be worth it, it has to be optimized as well.
That's a nice balance between the money you'll cost optimizing a script, and the money you'll save because your cloud will be smaller
and will cost you less.</p>
<p>The second tip is that PHP is fast, believe me.
For what you ask it to do, the way it does the job and the tools it represents to you : it is fast, efficient, reliable.
There is not that much room to optimize PHP scripts, at least not as if you were using lower level language like C.
The main trick is to optimize what is repeated : loops. If you use a profiler showing you the hot path of you script,
you'll happen to find that it is likely to be located into loops.
That's the same when we, as contributors, optimize PHP itself : we won't bother optimizing a part of code a few users will trigger, but better
optimize the hot path : variable accesses, engine function calls, etc... Because in here, the very little micro-second earned
will translate to final milli-seconds or even seconds, as such code is run tons of times (usually involving in loops).
Except <code>foreach()</code>, in PHP, loops are the same and lead to the same OPCode. Turning a PHP's <code>while</code> loop into a <code>for</code> loop is
both useless and silly. Once more : profiling will tell you that.</p>
<p>So, about function calls, well... A language needs function calls ;-)
However, there are little tricks that can be used to prevent some function calls, because the information is available elsewhere.
Like :</p>
<pre><code>php_version() =&gt; use the PHP_VERSION constant
php_uname() =&gt; use the PHP_OS constant
php_sapi_name() =&gt; use the PHP_SAPI constant
time() =&gt; read $_SERVER['REQUEST_TIME']
session_id() =&gt; use the SID constant</code></pre>
<p>The above examples are sometimes not 100% equivalent, and I let you read the documentation to find the differences.</p>
<p>Ah ho yes, let me tell it because we still see such things nowadays (uncommonly) : prevent silly things, like :</p>
<pre><code>function foo() {
    bar();
}</code></pre>
<p>Or even worse :</p>
<pre><code>function foo() {
    call_user_func_array('bar', func_get_args());
}</code></pre>
<p>Basically, don't stop working, don't stop using PHP, don't optimize something "because you heard that", "because someone told you that", and don't design your application by performance, but keep doing it by features.</p>
<p>However, profile your script, often, and verify every assumptions by yourself, do not blindly apply some performance patch assuming that...? Check by yourself.</p>
<p>We, at Blackfire engineer team, spend many time finding interesting metrics to show our PHP users. We use our deep knowledge of the PHP
engine to gather many items showing you what's happening into the deepness of your PHP scripts.
Even if the GUI doesn't show it yet, Blackfire probe extension measures many things, like when the garbage collector has been triggered, what it does, how many objects you created/destroyed in your functions, how many reference mismatch you performed when calling your functions, and even deeper metrics, such as session serialization time, <code>foreach()</code> bad behaviors (there are many things to say about foreach())... basicaly, everything that may help a developer find performance spots, and how to fix them.</p>
<p>Also, don't forget that you will at some point hit the limits of the language. Then it will probably be time to switch it.
PHP is not the right language to build an ORM, to make a video game, to create an HTTP server, to batch process some text based files or to create a parser of any kind.
It can do it, but it can't do it efficiently, under a high load. You'll hit a limit that is really close compared to
the one a better suitable language for such tasks will show, aka Java, Go or probably the most efficient language in the world nowadays, should you really well use it : C/C++ (Both Java and Go are also written in C/C++).</p>]]></content>
    </entry>
        <entry>
        <title>PHP output buffer in deep</title>
                <id>http://jpauli.github.io//2014/12/19/php-output-buffer-in-deep.html</id>
                <updated>2014-12-19T00:00:00+00:00</updated>
        <author>
            <name>Julien Pauli</name>
            <email>jpauli@php.net</email>
        </author>
        <link rel="alternate" type="text/html" href="http://jpauli.github.io//2014/12/19/php-output-buffer-in-deep.html"/>
        <content type="html" xml:lang="en"><![CDATA[<h2 id="first-words">First words<a href="#first-words" class="anchor">#</a></h2>
<p>Everybody is aware of the "output buffering" layer in PHP. This blog post is about how it works, how it's been
implemented in PHP source code, and how to interact with it from PHP. This layer is not complex, but often misunderstood,
or at least, not fully mastered by PHP developers.
Let's try to fix that together. We'll talk about PHP &gt;=5.4, should you know that many things have changed starting 5.4
about the OB layer, in fact, it has been completely rewritten and broke compatibility in some ways with PHP 5.3 (documented).</p>
<h2 id="what-is-the-output-buffer">What is the output buffer ?<a href="#what-is-the-output-buffer" class="anchor">#</a></h2>
<p>PHP's output stream contains bytes, usually text that the developer asks PHP to display, often using <code>echo</code> statements or <code>printf()</code>.
The first thing you should know is that any function outputing something will use the output buffer, this, from PHP land. When you 
live into the extension land, you may access functions that writes directly into SAPI preventing any OB layer above.
The C API is documented into <a href="http://lxr.php.net/xref/PHP_5_5/main/php_output.h">main/php_output.h</a> and as usual gives us many informations,
such as the default buffer size f.e.</p>
<p>The second thing to know is that the output buffer layer is one layer among others (there is not just one solo layer
buffering your output).
And the last thing to remember is that the output buffer layer behaves differently in accordance with the SAPI you are using
(web or cli).
Let's first draw the main picture that explains everything</p>
<p><img alt="PHP ob layers" src="../../../img/ob/ob_main.png"></p>
<p>Like you can see, we can distinguish between 3 logical layers of buffer for the output management into PHP.
2 of them belong to the famous "output buffering", and one last lives into the SAPI.
Those are the PHP layers, when the flow of output bytes leaves PHP to enter the bottom layer in the main architecture,
here again, buffers may appear (terminal buffer, fast-cgi buffer, web server buffer, OS buffers, TCP/IP stack buffers and
we'll stop here).
Don't forget this, beside the fact that we'll only talk about the PHP part in this article, many other pieces of software in
the whole stack may retain information before passing them to the below layer before hitting the end user.</p>
<p>One particular note about the CLI SAPI, so that's done. CLI disables any default PHP output buffer, by forcing the INI setting
<em>output_buffering</em> to 0. So, by default, until you play manually with ob_() functions, in CLI, when you output something, it
directly hits the SAPI layer. Moreover, in CLI, <em>implicit_flush</em> is also hardcoded to the value 1.
<em>Implicit_flush</em> setting is always misunderstood, in fact
<a href="http://lxr.php.net/xref/PHP_5_5/main/output.c#1095">the source code is really eloquent about it</a> : when <em>implicit_flush</em> is turned
on, the SAPI layer buffer is asked to be flushed anytime it is written to.
To conclude : anytime you write any output with the CLI SAPI, it will be asked to be immediately thrown to the bottom layer, which
is the stdout pipe <a href="http://lxr.php.net/xref/PHP_5_5/sapi/cli/php_cli.c#273">beeing write()en</a> and then 
<a href="http://lxr.php.net/xref/PHP_5_5/sapi/cli/php_cli.c#328">fflush()ed</a>. Easy.</p>
<h2 id="default-php-output-buffer-layer">Default PHP output buffer layer<a href="#default-php-output-buffer-layer" class="anchor">#</a></h2>
<p>So far so good, if you use a SAPI different from CLI, for example PHP-FPM, you'll be able to play with those 3 buffer-related INI settings :</p>
<ul><li>output_buffering</li>
<li>implicit_flush</li>
<li>output_handler</li>
</ul><p>Before understanding those, you should note that using <code>ini_set()</code> with them will have no effect, as their effect is analyzed at PHP startup, that is before
PHP may run any script. So when it meets an <code>ini_set()</code> about one of those 3 settings, it effectively changes the value, but this new value won't be used anywhere
as it is too late : the output buffer layer is already started and active.
Change those by editing php.ini or using the <em>-d</em> switch to the PHP binary.</p>
<p>Ok, so by default, the php.ini shipped with the actual PHP distribution gives <em>output_buffering</em> the value of "4096" (bytes). If you don't use any php.ini 
(or start PHP with the <em>-n</em> switch), the default will be <em>"0"</em>, aka disabled.
If you hardcode the value to <em>"On"</em>, then the <a href="http://lxr.php.net/xref/PHP_5_5/main/php_output.h#91">default output buffer size</a> will be used
(16Kb).
As you may have guessed, having a buffer for any output, in web environment, is a good thing for performance. The default 4Kb is a good setting,
this means you may write up to 4096 ASCII characters until PHP actually communicates with the below SAPI layer.
And in a web context, telling a socket to send bytes on a byte-by-byte basis is not very nice in term of performance. It is way better for your
server machine to send the content all at once, or big-chunks-by-big-chunks. The less often the layers communicate, the better for performance.
You should always keep an output buffer. PHP will send it at the end of the request, you don't have to do anything.</p>
<p>You already know about <em>implicit_flush</em> as we talked about it in the previous chapter regarding CLI. For any other SAPI, implicit flush is by default
set to <em>off</em>, which is a good value, as flushing the SAPI just after having written into it is probably not the behavior you expect. For the FastCGI
protocol, flushing is about ending and sending a FastCGI packet after every write, it may however be better to fullfill the FastCGI buffers before sending
FastCGI packets.
If you want to manually flush the SAPI buffers, use PHP's <code>flush()</code> function.
If you want it to be flushed after any write, use <em>implicit_flush</em> INI setting or call the PHP function <code>ob_implicit_flush()</code> once.</p>
<p>The <em>output_handler</em> is a callback that may be applied to the content of the buffer, before it gets flushed. There exists many callbacks, provided by
PHP extensions (user may also write callbacks, we'll talk about this in the next chapter).</p>
<ul><li>ob_gzhandler : output compression using ext/zlib</li>
<li>mb_output_handler : character encoding translation using ext/mbstring</li>
<li>ob_iconv_handler : character encoding translation using ext/iconv</li>
<li>ob_tidyhandler : HTML output tidying using ext/tidy</li>
<li>ob_[inflate/deflate]_handler : output compression using ext/http</li>
<li>ob_etaghandler : HTTP etag automatic generation using ext/http</li>
</ul><p>The callback you'll choose (only one possible) will be sent the buffer content and will perform some transformations about it, something which is very
nice. Remember that if you want to be able to see anything that PHP is to write back to the webserver and then to the user, use an output buffer callback,
that's the way to do such things.
Also remember that by "output" , we mean any headers and body. HTTP headers are also part of the OB layer.</p>
<h3 id="headers-and-body">Headers and body<a href="#headers-and-body" class="anchor">#</a></h3>
<p>At the time you use an output buffer (weither a user one, or the default PHP one), you may send HTTP headers and content the way you want.
You know that any protocol require to send headers before body (thus the term "header"), but when you use an ouput buffer layer, PHP will take care of
this for you.
Any PHP function playing with output headers (<code>header()</code>, <code>setcookie()</code>, <code>session_start()</code>) will in fact use the internal
<a href="http://lxr.php.net/xref/PHP_5_5/main/SAPI.c#667">sapi_header_op()</a> function which just fills in the headers buffer.
When you then write output, using say printf(), it writes into the output buffer (assuming one).
When the output buffer is to be sent, PHP starts sending the headers first, and then the body. PHP takes care of everything for you.
If you dont like this behavior, you have no other choice than disabling any output buffer layer.</p>
<h2 id="user-output-buffers">User output buffers<a href="#user-output-buffers" class="anchor">#</a></h2>
<p>Let's show some examples of how this works and what you can do.
Remember that if you want to play with the dafult PHP output buffer layer, you may then not used CLI, as it disables such a layer.
Here is an example playing with PHP default output buffer layer, using PHP internal webserver SAPI:</p>
<pre><code>/* launched via php -doutput_buffering=32 -dimplicit_flush=1 -S127.0.0.1:8080 -t/var/www */

echo str_repeat('a', 31);
sleep(3);
echo 'b';
sleep(3);
echo 'c';</code></pre>
<p>So we start PHP with a default output buffering layer of 32 bytes, and we immediately write 31 bytes to it before sleeping. Here, as expected,
nothing is sent yet, blank screen.
Then the sleep finishes and we write one more byte, fulfilling the buffer wich then immediately flushes itself into the SAPI layer buffer, itself
flushing immediately to the output, as we put implicit_flush to 1. The string 'aaaaaaaaaa{31times}b' then appears on the screen, and we start another
sleep. After this last sleep, the empty 31-byte-size buffer is filled-in with only one byte, but PHP then ends, and flushes back this buffer immediately.
The 'c' character appears.</p>
<p>We just showed how <strong>the default PHP buffer</strong> works, without calling any ob related functions yet. Keep in mind that this default buffer is here,
it is present (in non-CLI mode) and you may not forget about it.</p>
<p>We may now start user buffers, calling <code>ob_start()</code>, and we may stack as many buffers as we want (until we run out of memory).
Every buffer will stack onto the preceding one, and will flush itself into the immediately next one, eventually fulfilling it and make it overflow, etc...</p>
<pre><code>ob_start(function($ctc) { static $a = 0; return $a++ . '- ' . $ctc . "\n";}, 10);
ob_start(function($ctc) { return ucfirst($ctc); }, 3);

echo "fo";
sleep(2);
echo 'o';
sleep(2);
echo "barbazz";
sleep(2);
echo "hello";

/* 0- FooBarbazz\n 1- Hello\n */</code></pre>
<h2 id="output-buffering-internals">Output buffering internals<a href="#output-buffering-internals" class="anchor">#</a></h2>
<p>Since 5.4, the entire output buffering layer has been rewritten (by Michael Wallner). The code was a mess before, and many things were hard to do and buggy.
Read on <a href="http://marc.info/?l=php-internals&amp;m=114104110826804&amp;w=2"><a href="http://marc.info/?l=php-internals&amp;m=114104110826804&amp;w=2">http://marc.info/?l=php-internals&amp;m=114104110826804&amp;w=2</a> for more informations.
PHP 5.4 starts with a new code base, which is much more clean and designed, offers new features and has little breaks against 5.3. Nice !</p>
<p>One of the nicest feature added then is the possibility for extensions to declare their output buffer callback as conflicting with another one provided
by another extension. Before that, it was impossible -when designing an extension playing with the output buffer- to fully master the impact knowing
other extensions could declare callbacks as well.</p>
<p>Here is a quick-and-dirty little example showing how to register a callback that <code>strtoupper()</code> its content.</p>
<pre><code>#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "php.h"
#include "php_ini.h"
#include "main/php_output.h"
#include "php_myext.h"

static int myext_output_handler(void **nothing, php_output_context *output_context)
{
    char *dup = NULL;

    dup = estrndup(output_context-&gt;in.data, output_context-&gt;in.used);
    php_strtoupper(dup, output_context-&gt;in.used);

    output_context-&gt;out.data = dup;
    output_context-&gt;out.used = output_context-&gt;in.used;
    output_context-&gt;out.free = 1;

    return SUCCESS;
}

PHP_RINIT_FUNCTION(myext)
{
    php_output_handler *handler;

    handler = php_output_handler_create_internal("myext handler", sizeof("myext handler") -1, myext_output_handler, /* PHP_OUTPUT_HANDLER_DEFAULT_SIZE */ 128, PHP_OUTPUT_HANDLER_STDFLAGS);

    php_output_handler_start(handler);

    return SUCCESS;
}

zend_module_entry myext_module_entry = {
    STANDARD_MODULE_HEADER,
    "myext",
    NULL, /* Function entries */
    NULL,
    NULL, /* Module shutdown */
    PHP_RINIT(myext), /* Request init */
    NULL, /* Request shutdown */
    NULL, /* Module information */
    "0.1", /* Replace with version number for your extension */
    STANDARD_MODULE_PROPERTIES
};

#ifdef COMPILE_DL_MYEXT
ZEND_GET_MODULE(myext)
#endif</code></pre>
<h2 id="gotchas">Gotchas<a href="#gotchas" class="anchor">#</a></h2>
<p>The gotchas are mainly documented. Some are logical, some are hidden.
The logical, obvious ones are that you should not call any buffer functions from whithin an output buffer callback, nor should you write some output from there.</p>
<p>The less obvious ones are that some PHP functions use internally the output buffer for themselves, stacking another buffer, filling it then flushing or returning it.
Examples of such functions are <code>print_r()</code>, <code>highlight_file()</code> and <code>SoapServer::handle()</code>.
You should not use such functions from within an output buffer callback. The behavior may be undefined, or at least not what you'd expect.</p>
<h2 id="ending">Ending<a href="#ending" class="anchor">#</a></h2>
<p>The output layer is a layer of nets, catching any output "leak" that may come from PHP, and saving it in a sized buffer. When the buffer is full, it is flushed (written)
into the bottom layer if any, or at least into the bottom logical layer : the SAPI buffer.
End users have control over the number of buffers, their size and the operation that may be permitted on each layer of buffer (cleanable, flushable or removable).
This is very flexible and for example, allows library/framework designers to gain full control of their own output flow by catching it and treating it into a global buffer.
By output, we suppose any output stream bytes and any output HTTP headers , PHP taking care of sending them in the right order.</p>
<p>The output buffer also provides by default one buffer, controlled by 3 INI settings, that is designed to prevent smalls regulars writes from hitting the SAPI layer too often, and thus the
network too often, which is poor for performances.
PHP extensions may also declare callbacks to be run on every buffer, for example to perform data compression, string substitution, HTTP headers management and many other things.</p>]]></content>
    </entry>
        <entry>
        <title>PHP and MySQL communication, mysqlnd</title>
                <id>http://jpauli.github.io//2014/07/21/php-and-mysql-communication-mysqlnd.html</id>
                <updated>2014-07-21T00:00:00+00:00</updated>
        <author>
            <name>Julien Pauli</name>
            <email>jpauli@php.net</email>
        </author>
        <link rel="alternate" type="text/html" href="http://jpauli.github.io//2014/07/21/php-and-mysql-communication-mysqlnd.html"/>
        <content type="html" xml:lang="en"><![CDATA[<h2 id="introduction">Introduction<a href="#introduction" class="anchor">#</a></h2>
<p>Appeared with PHP5.3, mysqlnd is an unknown part of PHP. Yet, this extension is a must-have if your system relies heavily on the MySQL database server. We'll see what mysqlnd is, what it brings to PHP
and how to use it.</p>
<h2 id="foresee">Foresee<a href="#foresee" class="anchor">#</a></h2>
<p>PHP communicates with MySQL through a connector. 2 of them exist : libmysql or mysqlnd. libmysql is licenced by Oracle, while mysqlnd is under the PHP licence. Both code bases are mostly maintained by Oracle employees.
If a user wants to communicate with MySQL using the PHP language, this latter publishes 3 APIs in this goal : ext/mysql, ext/mysqli and ext/pdo_mysql.</p>
<p><img alt="libmysql" src="../../../img/php-mysql-com/php-arch-libmysql.png"><img alt="mysqlnd" src="../../../img/php-mysql-com/php-arch-mysqlnd.png"></p>
<h3 id="connectors">Connectors<a href="#connectors" class="anchor">#</a></h3>
<h4 id="libmysql">libmysql<a href="#libmysql" class="anchor">#</a></h4>
<p>Historicaly, PHP needed the MySQL server C connector to be able to talk with it. This connector is also known as "libmysql", and may be installed on your system with a command like <code>apt-get install libmysql</code>. This connector implements the MySQL communication API, let's see an example :</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;mysql/mysql.h&gt;
#include "mysql_example.h" /* Pour MYSQL_HOST, MYSQL_USER, MYSQL_PASS */

int main(int argv, char *argc[])
{
    MYSQL_RES *results = NULL; MYSQL_ROW row; MYSQL *db = NULL;

    db = (MYSQL *)malloc(sizeof(MYSQL));
    mysql_init(db);
    mysql_options(db, MYSQL_INIT_COMMAND, "SET NAMES UTF8;");
    if(!mysql_real_connect(db, MYSQL_HOST, MYSQL_USER, MYSQL_PASS, NULL, 0, NULL, 0)) {
        fprintf(stderr, "Failed to connect to host %s (%s)", MYSQL_HOST, mysql_error(db));
        exit(EXIT_FAILURE);
    }

    mysql_set_character_set(db, "utf8");
    mysql_select_db(db, "my_database");
    mysql_query(db , "SELECT user_id AS id FROM users WHERE user_description='member' LIMIT 10000");
    results = mysql_use_result(db);

    while(row = mysql_fetch_row(results)) {
        printf("%s\n", row[0]);
    }

    mysql_free_result(results);
    exit(EXIT_SUCCESS);
}</code></pre>
<p>You can run this code by linking your binary with libmysql, GCC's switch "-lmysql".
The libmysql documentation is detailed, and online, at <a href="http://dev.mysql.com/doc/refman/5.0/en/c-api.html"><a href="http://dev.mysql.com/doc/refman/5.0/en/c-api.html">http://dev.mysql.com/doc/refman/5.0/en/c-api.html</a></p>
<p>As you could have noticed, the PHP extensions "mysql" and "mysqli" borrow this C API to publish it to PHP land. This is one of the PHP way of doing things : when an extension creator embeds a C API
into PHP's source to publish it to PHP user land, usually he gives it the same API as the C one, this way when you know one of them, you are not lost getting hands into the second one.</p>
<p>libmysql however could bring some problems to your architecture :</p>
<ul><li>The licencing is complex. For example, if you wish to build a closed-source commercial product on top of libmysql, you'll need to pay for a licence. <a href="http://www.mysql.com/about/legal/licensing/oem/">Details about libmysql licencing here</a>.</li>
<li>Updating libmysql involves updating the MySQL server in certain distros, which sometimes is not what you want in your upgrading strategies.</li>
</ul><h4 id="mysqlnd">mysqlnd<a href="#mysqlnd" class="anchor">#</a></h4>
<p>As of PHP5.3, the PHP developers rewrote entirely the libmysql source code, into a PHP extension named "mysqlnd". mysql native driver. This connector is licenced under the PHP licence, which is more appropriate than the Oracle's licences as all stay under the same PHP licence.</p>
<p>Also, rewriting the code of a library that was not part of PHP (libmysql) was also the way to improve many things in the MySQL-PHP communication. We'll detail how mysqlnd can improve your application performance drastically, especially if this one runs big select queries (batch scripts are the appropriate use case here).</p>
<p>Just keep in mind that mysqlnd is a PHP extension that does not publish any class or function to PHP (this in not totally right, we'll get back to that point later on), it however can serve as a big basis for other PHP extensions mysql,mysqli and pdo_mysql to rely on when communicating with MySQL servers.</p>
<p>mysqlnd is to be activated at compile time in PHP 5.3 (--with-pdo-mysql=mysqlnd switch, for pdo_mysql example), and it is proposed <em>as the default connector</em> starting from PHP 5.4.</p>
<h3 id="extensions">Extensions<a href="#extensions" class="anchor">#</a></h3>
<p>PHP publishes 3 extensions for the PHP user to talk to MySQL servers.</p>
<h4 id="mysql">mysql<a href="#mysql" class="anchor">#</a></h4>
<p>This very old extension was the first one published. It was contributed by the MySQL authors back before year 2000. It publishes the <em>mysql_</em> functions in PHP by adopting the underlying C API.
This extension borrows the MySQL server 3.23 API, so for today, it is not to be used as it is too old. It's still here for compatibility purposes, throws E_DEPRECATED errors in latest PHP versions and is meant to die sooner or later. Please, don't use it for your recent projects.</p>
<h4 id="mysqli">mysqli<a href="#mysqli" class="anchor">#</a></h4>
<p>mysqli is written with an end "i" which stands for "improved". This extension appeared in PHP5.0, and is meant to replace the old ext/mysql API, because it is internally based or more recent MySQL server API : 4.1 or later. It then supports stored procedure, secured authentification protocol, prepared statements and much more.
It also publishes an object oriented API to the PHP user, together with a procedural API.</p>
<p>PHP contributors designed this extension so that it has a very common API shared with ext/mysql, and migrations from ext/mysql to ext/mysqli should really be painless.</p>
<p>We'll detail ext/mysqli API in a few moment to introduce not well understood but critical concepts such as buffered/unbuffered queries and prepared statements.</p>
<h4 id="pdo">PDO<a href="#pdo" class="anchor">#</a></h4>
<p>PDO is different from mysql/mysqli because it has been designed to support other RDBMS than MySQL. In this fact, this extension is imperfect and tries to guess many things from the user, which could lead to strange behaviors. Let me explain.</p>
<p>PDO ships with an SQL parser which is to emulate prepared statements if the underlying RDBMS doesn't support them. The problem is that this layer behaves differently from the RDBMS' one, when present.
If you take the MySQL case, the PDO emulation layer is active by default when you prepare a query, and this one will never hit MySQL prepared statement layer which is probably not what you want. In fact, PDO's code will parse and build your query, never communicating with MySQL about this (by default). This is weird. Turn this emulation layer off as soon as you can :</p>
<pre><code>/* Disable PDO prepared statements emulation */
$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, 0);

/* This is exactly the same, take care, we really pass 0 here and not 1 */
$pdo-&gt;setAttribute(PDO::MYSQL_ATTR_DIRECT_QUERY, 0);</code></pre>
<p>When the emulation layer is disabled, you rely with a true prepared statement. When it is enabled, PDO will take care of constructing the query for you, and will send a traditionnal normal query to the RDBMS. This has lots of drawbacks and can lead to strange behaviors. As PDO doesn't know anything about tables' columns, its emulation layer will quote every parameter when bound to an emulated prepared statement, even the parameter of integer type, which don't need such quoting. This leads to errors :</p>
<pre><code>$stmt = $pdo-&gt;prepare("SELECT user_id FROM users LIMIT :limit");
$stmt-&gt;bindValue('limit', 10);
$stmt-&gt;execute();

$result = $stmt-&gt;fetch();
var_dump($result);

/*
PHP Fatal error:  Uncaught exception 'PDOException' with message 'SQLSTATE[42000]: Syntax error or access violation: 1064 You have an error in your SQL syntax;
check the manual that corresponds to your MySQL server version for the right syntax to use near ''10'' 
*/</code></pre>
<p>We see from this error message that PDO escaped my 'limit' parameter quoting it wrongly, as it is an integer and doesn't need that.
Let's try again with no emulation layer, relying only on the RDBMS layer (MySQL here):</p>
<pre><code>$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, 0); /* Disable prepared statement emulation layer */
$stmt = $pdo-&gt;prepare("SELECT user_id FROM users LIMIT :limit"); /* A true prepare() will be sent to the RDBMS, it has to support it */
$stmt-&gt;bindValue('limit', 10);
$stmt-&gt;execute();

$result = $stmt-&gt;fetch();
var_dump($result);
/*
array(4) {
  ["user_id"]=&gt;
  string(7) "18"
  [0]=&gt;
  string(7) "18"
}
*/</code></pre>
<p>Things now work.
If you would want to still use the emulation layer, you'd then need to precise to PDO that your parameter is of type integer, like this :</p>
<pre><code> /* Tells the PDO prepared statement emulation layer that this column is of type integer (SQL type) */
$stmt-&gt;bindValue('limit', 10, PDO::PARAM_INT);</code></pre>
<p>And here you don't have the whole story.</p>
<p>Whereas we explicitely disabled the prepared statement emulation layer in PDO, this one is still a little active. The layer is still triggered for parameter parsing. You know about the two parameter syntax : anonymous parameters, implemented as "?" in your query for placeholders, or the named parameters, as ":myparam". Those two syntaxes are not supported by every RDBMS, and guess what ? MySQL doesn't support the named parameters one, only the question-mark-based one.
However, our preceding query still completed fine... This is because the PDO query analyzer is still active, even with prepared statement emulation layer tured off. It stepped in and replaced every named parameter by an anonymous one, because it asked the RDBMS (MySQL here) about its capabilities to support those syntaxes, and MySQL answered it did not support the named parameters syntax. PDO then replaced every ":myparamname" by a "?".
Tricky isn't it ?</p>
<p>By trying to satisfy every soul on earth, PDO created an API that is full of trade-offs. It is in fact well designed, and eases the PHP developers life in a huge majority of cases, but hidding complexity is a double-edged sword. If you hit the bogus case, your are then in trouble if you don't know what happens in the lower layers.</p>
<h2 id="zoom-on-the-mysqli-extension">Zoom on the mysqli extension<a href="#zoom-on-the-mysqli-extension" class="anchor">#</a></h2>
<p>mysqli is a nice extension, really. Nowadays, everybody uses PDO, the main argument about this is if you were to switch from one RDBMS to an other, this would ease many things. I don't know you, but I've never met such a situation. If you use MySQL RDBMS, and you are pretty unlikely to change (in production), which usually is the case : don't use PDO, you'll lose many things and suffer from one more layer of abstraction which can't offer everything the RDBMS can offer. Have a look at mysqli API and notice how rich it is :</p>
<p><img alt="mysqli" src="../../../img/php-mysql-com/mysqli-api.jpg"></p>
<p>First of all, mysqli has always been blamed for not generating exceptions but PHP errors. This is wrong.</p>
<pre><code>&lt;?php
mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);

try {
    $db = mysqli_connect('myserver', 'myuser', 'secret', 'unknown_database');
} catch (mysqli_sql_exception $e) {
    exit($e-&gt;getMessage());
}
try {
    mysqli_query($db, "SELECT foo FROM bar");
    /* ... */
} catch(mysqli_sql_exception $e) { }</code></pre>
<p>You see ?</p>
<p>mysqli can even tell you when you miss an index :</p>
<pre><code>&lt;?php
mysqli_report(MYSQLI_REPORT_INDEX);
$db = mysqli_connect('myserver', 'myuser', 'secret', 'my_database');

mysqli_query($db, "SELECT photo FROM Users WHERE source ='web' LIMIT 1000");

/* PHP Warning:  mysqli_query(): (00000/0): No index used in query/prepared statement ... */</code></pre>
<p>MySQL communicates many things with its client (PHP in our case). For more information, you should read the <a href="http://dev.mysql.com/doc/internals/en/client-server-protocol.html">MySQL client/server protocol documentation</a></p>
<p>Second thing : mysqli provides a function to change the character set : <code>mysqli_set_character_name()</code>. You should never use "SET NAMES" query, because the escaping strategies won't use it.
You can read more info about this at <a href="http://php.net/mysqlinfo.concepts.charset.php"><a href="http://php.net/mysqlinfo.concepts.charset.php">http://php.net/mysqlinfo.concepts.charset.php</a></a> or <a href="http://dev.mysql.com/doc/refman/5.7/en/charset-connection.html"><a href="http://dev.mysql.com/doc/refman/5.7/en/charset-connection.html">http://dev.mysql.com/doc/refman/5.7/en/charset-connection.html</a></p>
<p>Now, let's talk about buffered queries, which is a very obscur part.
When you query MySQL for results, so usually when you use SELECT queries, a resultset will be created and results will be in. Buffered resultsets is the concept about where to store the resultset ? Should it be stored into the client memory (buffered query), or stay on the MySQL side (unbuffered query) ? That's all.</p>
<p>Please, note that we are talking about direct queries and not prepared statements, which are not the same at all. We'll give a word about prepared statements later on.</p>
<p>By default, every direct query issued from mysqli to MySQL is buffered, this means that at the time you issue a <code>mysqli_query()</code> call, all the resultset is transmitted over the wire, back to PHP memory, and freed from the MySQL side. As the resultset resides on the PHP part, you can count it : <code>mysqli_num_rows()</code>, you can seek into it at any place : <code>mysqli_data_seek()</code> and you can issue another query() while the resultset is not freed yet. Let's show an example :</p>
<pre><code>$mysqli = mysqli_connect(/*...*/);

/* By default, the resultset will be buffered into the client : PHP */
$result = mysqli_query($mysqli, "SELECT id, nom, email FROM members");
$line1 = mysqli_fetch_row($result);
mysqli_data_seek($result, mysqli_num_rows($result)); /* Let's jump to the last result */
$last_result = mysqli_fetch_row($result); /* Let's fetch that last result */

/* Should we not need this resultset anymore, let's free it, which will free memory :*/
mysqli_free_result($result);</code></pre>
<p>This is classical and default case. Remember that the whole resultset is immediately transmitted by MySQL to PHP, so if you expect it to be big, like if you selected very large blob columns or a lot of results, PHP's memory footprint will increase proportionally. However, you will not be able to see this memory footprint using <code>memory_get_usage()</code> nor will it be accounted into <em>memory_limit</em> until you use mysqlnd as low level connector. We'll detail this later.</p>
<p>If you'd like to issue the same request using non buffered result set, you'll use the <em>MYSQLI_USE_RESULT</em> flag. But be carefull, if you use a non buffered resultset, this means that the resultset will be allocated on the MySQL side (into the MySQL process memory) for your connection, and MySQL can only store one resultset by connection, which means you won't be able to re-issue another direct query on this connection until you freed the resultset. Also, as the resultset is not stored on the PHP side, it is not possible you seek into it, nor you count how many results are in :</p>
<pre><code>$mysqli = mysqli_connect(/*...*/);

/* The resultset will be allocated on the MySQL side this time */
$result = mysqli_query($mysqli, "SELECT id, email FROM members", MYSQLI_USE_RESULT);

$line1 = mysqli_fetch_row($result); /* This may trigger the network to fetch a result from the resultset */

/* This leads to an error, you cant seek a resultset which is not "yours",
it is still located into MySQL memory */
mysqli_data_seek($result, mysqli_num_rows($result));

/* This leads to an error, you can't issue another unbuffered query if you did not
free the last resultset */
$result2 = mysqli_query($mysqli, "SELECT name FROM membres", MYSQLI_USE_RESULT);</code></pre>
<p><code>mysqli_free_result()</code> frees the resultset, should it be stored on the PHP side or MySQL side.
By default, any direct query is issued in buffered mode because the MySQL server has other things to do than allocating memory to store every of its clients' resultsets.</p>
<p>Now, let's talk about prepared statements.</p>
<p>Prepared statements are very different from traditionnal direct queries :</p>
<ul><li>Prepared statements don't use the same underlying protocol as direct queries. The protocol is called the binary protocol, it is very optimized and offers many things such as true data type bindings.</li>
<li>Prepared statements resultsets are not buffered by default. This is the opposite as direct queries resultsets.</li>
</ul><p>Let's start by dumping the protocol for a direct query :</p>
<pre><code>$m = mysqli_connect(/* params */);
$q = mysqli_query($m, 'SELECT * FROM Users LIMIT 1');
while($r = mysqli_fetch_row($q)) {
    /* do something */
}
mysqli_free_result($r);</code></pre>
<p><img alt="mysql text protocol" src="../../../img/php-mysql-com/mysql-simple-dump.png"></p>
<p>As you can see on the picture, this is a textual protocol, this means that the data that MySQL sends back to PHP is only text. You asked for an integer column in your query ? you'll be given some text. Ouch ! That first means that MySQL has some additionnal work to do to turn the data types from its columns into texts. And that also means that on the PHP side, you'll only be able to retrieve PHP strings, even if your asked columns store different types.</p>
<p>Here we go for the same query as prepared statement :</p>
<pre><code>$m = mysqli_connect(/* params */);
$ps = mysqli_prepare($m, 'SELECT * FROM Users LIMIT 1');
mysqli_stmt_execute($ps);
while(mysqli_stmt_fetch($ps)) {
    /*  */
}
mysqli_stmt_close($ps);</code></pre>
<p><img alt="mysql binary protocol" src="../../../img/php-mysql-com/mysql-ps-dump.png"></p>
<p>The protocol image shows that this time, there are more communications. Every bind (not done on our example) and every fetch will trigger MySQL to receive or transmit data on the wire.
However, we can't see that on the picture but the protocol used was binary, that means that every column type is respected and transmetted as-is : an integer will be sent as an integer, and not a string
anymore. Should you remember your type sizes, transmitting for example a TINYINT 200 will weigh one byte on the network whereas it would have used 4 bytes if turned to text. The binary protocol is then lighter from this point of view, but there are also more network interchange for signaling.</p>
<pre><code>$m = mysqli_connect(/* params */);
$ps = mysqli_prepare($m, 'SELECT id FROM Users LIMIT 10'); /* 'id 'column is of type INTEGER */
mysqli_stmt_execute($ps);
mysqli_stmt_bind_result($ps, $id); /* let's bind the result column on $id */
while(mysqli_stmt_fetch($ps)) {
    var_dump($id);
}
/*
int(62)
int(64)
*/</code></pre>
<p>The example above shows clearly that PHP recovers integers, not strings any more.</p>
<p>It is however possible to keep types using the text protocol. This will need the client (PHP) to transtype the received strings ito the right expected types, and as you'd have guessed, only mysqlnd can do that, libmysql will be no help :</p>
<pre><code>$m = mysqli_connect(/* */);
$q = mysqli_query($m, 'SELECT id FROM users LIMIT 10';

while($r = mysqli_fetch_row($q)) {
    var_dump($r[0]);
}
/*
string(2) "62"
string(2) "64"
*/

$m = mysqli_connect(/* */);
mysqli_options($m, MYSQLI_OPT_INT_AND_FLOAT_NATIVE, true); /* This is only available using mysqlnd */
$q = mysqli_query($m, 'SELECT id FROM users LIMIT 10');

while($r = mysqli_fetch_row($q)) {
    var_dump($r[0]);
}
/*
int(62)
int(64)
*/</code></pre>
<p>If we talk about the resultset of a prepared statement, it is not buffered by default, every fetch() operation will trigger a network communication. You may however buffer those resultsets, using <code>mysqli_stmt_store_result()</code>.</p>
<pre><code>$m = mysqli_connect(/* */);
$ps = mysqli_prepare($m, 'SELECT id, name FROM Users LIMIT 1000');
mysqli_stmt_execute($ps);
mysqli_stmt_bind_result($ps, $id, $name);

/* Store every result into PHP in one call */
mysqli_stmt_store_result($ps);

while(mysqli_stmt_fetch($ps)) {
    /* do something with $id and $name */
}
mysqli_stmt_close($ps);</code></pre>
<p>We've seen we still can buffer the resultset if we want to, but with prepared statements it is necessary to bind every result column to a PHP variable to be able to read some useful data.
Once more, if you use mysqlnd, you'll have access to <code>mysqli_stmt_get_result()</code>, which will turn a prepared statement resultset into a mysqli_result, and you'll be back using a direct-query-like API, but with prepared statements :</p>
<pre><code>$m = mysqli_connect(/* params */);
$ps = mysqli_prepare($m, 'SELECT id, name FROM Users LIMIT 1000');
mysqli_stmt_execute($ps);

/* Turn the result set into a mysqli_result */
$r = mysqli_stmt_get_result($ps); /* Only available under mysqlnd */

while($result = mysqli_fetch_row($r)) { /* direct query API */
    /* do something */
}
mysqli_free_result($r);
mysqli_stmt_close($ps);</code></pre>
<h2 id="zoom-on-mysqlnd">Zoom on mysqlnd<a href="#zoom-on-mysqlnd" class="anchor">#</a></h2>
<p>We've seen so far that mysqlnd acts as a hidden extension which adds many features to the existing APIs, especially mysqli (this is true for PDO as well but lesser).
Let's now detail other parts of mysqlnd.</p>
<h3 id="memory-savings">Memory savings<a href="#memory-savings" class="anchor">#</a></h3>
<p>To understand this part, we need to recall some points :</p>
<ul><li>A buffered query fetches all the results from MySQL to PHP memory</li>
<li>The buffered result set is created by the library which is used to communicate, weither libmysql or mysqlnd</li>
<li>A resultset is not directly usable from PHP land, it has to be turned into a PHP structure such as an array, this operation is called a "fetch"</li>
</ul><p>Here we go.</p>
<p>Doing this is silly, and wastes a huge part of memory :</p>
<pre><code>$db  = mysqli_connect(/* */);
$result = mysqli_query($db, "SELECT very_huge_blob_column, lots, of, columns FROM foobar"); /* big query generating a huge heavy resultset */

while($results[] = mysqli_fetch_row($result)) { }
mysqli_free_result($result); /* This step is often forgotten, which is even worse! */
foreach($results as $foo) { /* do something */ }</code></pre>
<p>Let's prove what we say :</p>
<pre><code>function memory_usage()
{
    $pid = getmypid();
    $r = explode(':',shell_exec("grep VmData /proc/$pid/status"));
    return '-&gt;'.trim($r[1])."\n";
}
$db = mysqli_connect(/* */);

echo "initial memory " . memory_usage();
$result = mysqli_query($db,"SELECT very_huge_blob_column FROM foobar");
echo "resultSet stored " . memory_usage();
while($results[] = mysqli_fetch_row($result)) { }
echo "query result saved " . memory_usage();
mysqli_free_result($result);
echo "resultSet freed " . memory_usage();
unset($results);
echo "saved result freed " . memory_usage();
unset($db);
echo "Db closed " . memory_usage();</code></pre>
<p>With libmysql, here are the numbers :</p>
<pre><code>&gt; phplibmysql/bin/php poc_mysqli.php
initial memory -&gt;3348 kB
resultSet stored -&gt;72724 kB
query result saved -&gt;149012 kB
resultSet freed -&gt;81156 kB
saved result freed -&gt;25348 kB
Db closed -&gt;24260 kB</code></pre>
<p>As you can see, as soon as the <code>mysqli_query()</code> is executed, all the resultset is transmitted into PHP's memory. On this example, the memory raises from 3Mb to 70Mb ! (this is a true, real life example).
This is normal behavior as by default, direct queries are in buffered mode. What is important to understand here is that the resultset memory buffer <strong>has been allocated by the communication library : libmysql</strong>. And when it comes to turn this resultset to something PHP can use, fetch it into an array, <strong>the entire data into the resultset will be duplicated in memory</strong>, resulting in an enormous waste.</p>
<p>As the resultset buffer is allocated by libmysql, it wont show into <code>memory_get_usage()</code>, but you'll need to monitor your process heap to see that (like its done in the example using <em>/proc</em>).</p>
<p>So transforming the whole data from a resultset into a PHP variable blows up the memory. At this stage, libmysql buffer is still allocated and the data is fully duplicated into buckets of a PHP array, thus we are consuming now about 140Mb. Let's convince ourselves about those allocation by running valgrind memory analyzer with massif :</p>
<pre><code>99.92% (257,473,815B) (heap allocation functions) malloc/new/new[], --alloc-fns, etc.
-&gt;52.90% (136,314,880B) 0x69A01E: _zend_mm_alloc_int (zend_alloc.c:1908)
| -&gt;52.60% (135,528,448B) 0x69A1DE: _estrndup (zend_alloc.c:2503)
| | -&gt;52.60% (135,528,448B) 0x533BCE: php_mysqli_fetch_into_hash (mysqli.c:1191)
| |   -&gt;52.60% (135,528,448B) 0x53F2E1: zif_mysqli_fetch_row (mysqli_nonapi.c:352)
| |     -&gt;52.60% (135,528,448B) 0x70186A: zend_do_fcall_common_helper_SPEC (zend_vm_execute.h:320)
| |       -&gt;52.60% (135,528,448B) 0x6D9D96: execute (zend_vm_execute.h:107)
| |         -&gt;52.60% (135,528,448B) 0x6B4B98: zend_execute_scripts (zend.c:1236)
| |           -&gt;52.60% (135,528,448B) 0x663D0C: php_execute_script (main.c:2308)
| |             -&gt;52.60% (135,528,448B) 0x73BCDC: main (php_cli.c:1184)
| |               
| -&gt;00.31% (786,432B) in 1+ places, all below ms_print's threshold (01.00%)
| 
-&gt;45.85% (118,130,675B) 0x52DD010: my_malloc (my_malloc.c:37)
| -&gt;45.84% (118,112,344B) 0x52E0583: alloc_root (my_alloc.c:219)
| | -&gt;45.83% (118,096,024B) 0x5307A40: cli_read_rows (client.c:1418)
| | | -&gt;45.83% (118,096,024B) 0x5305955: mysql_store_result (client.c:2957)
| | |   -&gt;45.83% (118,096,024B) 0x53EF09: zif_mysqli_query (mysqli_nonapi.c:540)
| | |     -&gt;45.83% (118,096,024B) 0x70186A: zend_do_fcall_common_helper_SPEC (zend_vm_execute.h:320)
| | |       -&gt;45.83% (118,096,024B) 0x6D9D96: execute (zend_vm_execute.h:107)
| | |         -&gt;45.83% (118,096,024B) 0x6B4B98: zend_execute_scripts (zend.c:1236)
| | |           -&gt;45.83% (118,096,024B) 0x663D0C: php_execute_script (main.c:2308)
| | |             -&gt;45.83% (118,096,024B) 0x73BCDC: main (php_cli.c:1184)</code></pre>
<p>my_malloc() is libmysql's allocator on top of malloc.</p>
<p>To free the resultset libmysql's keeping warm, you must call <code>mysqli_free_result()</code>. We can see that we fall back to about 70Mb after this call, and then, when we finally free the PHP array containing a copy of the resultset, we drop back to initial memory usage (on average, some cache systems may trigger, this is not leaked memory).</p>
<p>This duplication from libmysql's buffer to PHP memory can be prevented using mysqlnd. mysqlnd will benefit from the copy on write behavior of PHP zvals to save those copies. Let's show that :</p>
<pre><code>&gt; phpmysqlnd/bin/php poc_mysqli.php
initial memory -&gt;3208 kB
resultSet stored -&gt;70452 kB
query result saved -&gt;71220 kB
resultSet freed -&gt;81148 kB
saved result freed -&gt;19196 kB
Db closed -&gt;19196 kB</code></pre>
<p>As you can see, when the buffered resultset is fetched into a PHP array, the memory does not move. Far from beeing multiplied by two hun ?
Only at the time you'll start writing into this array (should you write into it), thus modifying the fetched results, PHP will duplicate the result on a case by case basis, which is really cool for memory usage. If you stay with a read-only approach, then you'll save lots of memory.
Also, mysqlnd used the PHP memory allocator to store the resultset into its own buffer, the memory usage is shared with PHP, and <code>memory_get_usage()</code> will show this memory and you could also hit the <em>memory_limit</em> PHP setting.</p>
<p>Knowing that apps mainly SELECT data, then fetches them to usually display them (read only), it is a pure waste to still use libmysql as low level communication for such use cases.
And I don't talk about batch scripts, written in PHP, treating lots of data from MySQL, and from where people often complain about memory usage... It's not PHP's fault you know ;-)</p>
<p>Another approach would also be to prevent any "fetch all" operation. PDO's got such an API : <code>$stmt-&gt;fetchAll()</code>, which transforms all the resultset into a PHP variable. It is way better for memory usage to seek into the resultset and consume the actual data, then loop to the next one, than looping once and turning any row into a PHP array bucket. <em>PDOStatement</em> even implements <em>Traversable</em>, and is then usable using foreach, same for mysqli_result.</p>
<h3 id="statistics">Statistics<a href="#statistics" class="anchor">#</a></h3>
<p>As mysqlnd act between any PHP Mysql layer, and the MySQL server, it sees everything : every single byte exchanged between both parts is seen, and can be counted to collect very useful statistics.
Let's have a look at some of them :</p>
<p><img alt="mysqlnd statistics" src="../../../img/php-mysql-com/mysqlnd-stats-phpinfo.png"></p>
<p>Here are some useful questions mysqlnd can answer very easily without requiring monitoring plugins, which are always heavy to setup and live on server side :</p>
<ul><li>How many MySQL active connections do I have ?</li>
<li>How many MySQL connection errors PHP met so far ?</li>
<li>How many queries have been prepared, but not executed (which is a waste of performance) ?</li>
<li>How many queries have been prepared, but used only once (prepared statements are useful if you reuse them, if not, its often a waste of bandwidth)</li>
<li>How many queries have queried for columns but have not fetched them (waste of bandwidth and memory )?</li>
<li>How many MySQL slow queries happened so far ?</li>
<li>How many queries not using an index ?</li>
</ul><p>mysqlnd can answer all those questions. Let's see :</p>
<pre><code>$db = mysqli_connect(/* */);

$result = mysqli_query($db,"SELECT user_id, email FROM users LIMIT 5");
mysqli_data_seek($result, 5);
$data = mysqli_fetch_row($result);
do_something($data);
mysqli_free_result($result);
var_dump(mysqli_get_connection_stats($db)); /* only available under mysqlnd */

/*
["buffered_sets"]=&gt;
  string(1) "1"
["rows_fetched_from_server_normal"]=&gt;
  string(1) "5"
["rows_buffered_from_client_normal"]=&gt;
  string(1) "5"
["rows_fetched_from_client_normal_buffered"]=&gt;
  string(1) "1"
["connect_success"]=&gt;
  string(1) "1"
["connect_failure"]=&gt;
  string(1) "0"
["connection_reused"]=&gt;
  string(1) "0"
["reconnect"]=&gt;
  string(1) "0"
["active_connections"]=&gt;
  string(1) "1"
*/</code></pre>
<p>The above code queries for 5 results, seeks into the resultset directly to the 5th, fetches it, uses it and frees all the resultset. Why so query for 5 results and only use one ?
We can see from the statistics array that <em>rows_fetched_from_server_normal</em> shows we queried 5 results and MySQL sent us 5 of them, they were all here, but <em>rows_fetched_from_client_normal_buffered</em> shows we only effectively fetched one result from the stored resultset. We then wasted bandwidth, MySQL CPU and PHP memory.</p>
<p>Let's extend MySQLi class to have a simple log about this waste :</p>
<pre><code>class JPMysqli extends Mysqli
{
    public function __destruct()
    {
        $stats = $this-&gt;get_connection_stats();
        $this-&gt;close();
        if($diff = $stats["rows_fetched_from_server_normal"] - ($stats["rows_fetched_from_client_normal_unbuffered"] + $stats["rows_fetched_from_client_normal_buffered"])) {
            trigger_error("You didn't use *$diff* selected results", E_USER_NOTICE);
        }
    }
}

$db = new JPMysqli(/* */);

$result = mysqli_query($db,"SELECT user_id, email FROM users LIMIT 5");
mysqli_data_seek($result, 5);
$data = mysqli_fetch_row($result);
do_something($data);
exit();
/*
Notice : "You didn't use *4* selected results"
*/</code></pre>
<p>Nice, knowing that this particular behavior is really common is userland. So many applications run queries selecting tons of result, but only effectively using part of them.</p>
<p>If you are using Symfony2 applications, you may use <a href="https://packagist.org/packages/js/mysqlnd-bundle"><a href="https://packagist.org/packages/js/mysqlnd-bundle">https://packagist.org/packages/js/mysqlnd-bundle</a></a> or <a href="https://packagist.org/packages/js/mysqlnd-analytics"><a href="https://packagist.org/packages/js/mysqlnd-analytics">https://packagist.org/packages/js/mysqlnd-analytics</a></p>
<h3 id="plugins">Plugins<a href="#plugins" class="anchor">#</a></h3>
<p>mysqlnd is a so nice extension... It is even extensible !
This means that it's been thought to be extensible without further changing its source code. mysqlnd is plugable, and one may activate other PHP extensions which are in fact plugins for mysqlnd which will add new features.
Plugins may be developed in C and some already exist :</p>
<p>mysqlnd_qc : Query cache. This plugin allow you to cache SQL query resultsets into different backend and reuse them later. Why the hell do people reinvent such a system in PHP land ?</p>
<p>mysqlnd_ms : Master Slave balancer which is able to select the right server depending on the query sent. This is totally transparent to userland. Why the hell do people reinvent such a system in PHP land ?</p>
<p>mysqlnd_uh : UserHandler Hooks : Write your own plugin using PHP (and not C). Branch on different hooks into the low level mysqlnd layer, and implement whatever you want : SQL injection protections, load balancers, loggers, etc...</p>
<h2 id="conclusion">Conclusion<a href="#conclusion" class="anchor">#</a></h2>
<p>So, I hope you know have a better understanding on how PHP communicates with MySQL servers. I also hope you noticed how mysqlnd can help you implementing so many ideas, and how its licence allows you to do the same things you'd do using just PHP and the PHP licence.</p>
<p>Special thanks to Ulf Wendel, Andrey Hristov, Georg Richter and Johannes Schl&uuml;ter ; main mysqlnd creators.</p>]]></content>
    </entry>
        <entry>
        <title>PHP memory and Zend Memory Manager</title>
                <id>http://jpauli.github.io//2014/07/02/php-memory.html</id>
                <updated>2014-07-02T00:00:00+00:00</updated>
        <author>
            <name>Julien Pauli</name>
            <email>jpauli@php.net</email>
        </author>
        <link rel="alternate" type="text/html" href="http://jpauli.github.io//2014/07/02/php-memory.html"/>
        <content type="html" xml:lang="en"><![CDATA[<h2 id="introduction">Introduction<a href="#introduction" class="anchor">#</a></h2>
<p>This blog post is gonna introduce you the dynamic memory management layer PHP relies on : Zend Memory Manager (ZendMM). We'll detail why we need such a layer, what it does, how to customize it, how to interact with it from PHP land.</p>
<h2 id="recall-on-c-memory-management">Recall on C memory management<a href="#recall-on-c-memory-management" class="anchor">#</a></h2>
<p>C has several allocation storage classes :</p>
<ul><li>automatic allocation ;</li>
<li>static allocation ;</li>
<li>dynamic allocation.</li>
</ul><p>Auto allocation is about function received arguments, or any variable declared into a function body. The compiler has all informations it needs to figure out how many bytes to allocate, and it will automatically free the memory by itself, when the container becomes out of scope. You cannot get your hands on such automatic feature, especially you can't reallocate this memory zone (because you'd need more memory that the compiler computed for you, or less).</p>
<p>Static allocation is about global or static variables. Like with automatic allocation, the compiler allocates memory depending on variable type, but this time it will never free it until the program ends. Here again, you cannot get into that process to customize it.</p>
<p>Finally dynamic allocation is where the programmer (you) will declare himself how much bytes of memory he needs. You can reallocate the memory, meaning you can enlarge it, or shrink it, whenever you want. This is necessary as many things in a program lifetime are not known at compile time, and evolve within the program lifetime. So you can do whatever you want with dynamic allocation, but there is a duty you have to accept : free the memory zone whenever you don't need it anymore, because absolutely noone will do it for you. If you forget, you create what's called a <em>memory leak</em>, that means you allocated some memory for your program, but you never released it back to the OS so that it may use it for any other program which may need it. That's bad.</p>
<p><img alt="OS memory" src="../../../img/php-memory/os-memory.png"></p>
<p>Here is an example :</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* Static allocation, global variable
   the compiler takes care of everything, but won't free
   this bloc of memory */
int myint;

char *myfunction(int i)
{
    /* Static allocation, static variable
   the compiler takes care of everything, but won't free
   this bloc of memory */
    static char *my_static = "Foo";

    if (myint == i) {
        my_static = "Bar";
    }
    return my_static;
}

int main(int argc, char *argv[])
{
    /* Automatic allocation, the compiler takes care of allocation
    and will free this memory bloc when the function will end */
    int *p_int;
    int i;

    myint = 18;

    /* Dynamic allocation. The programmer asks himself to allocate
       10*sizeof(int) bytes in memory, he will have to free it by himself */
    p_int = (int *)malloc(10 * sizeof(int));

    for (i=0; i&lt;10; i++) {
        *(p_int + i) = i*myint;
        myfunction(*p_int);
    }

    /* Free of dynamic memory bloc. Forgetting this stage creates a real
      memory leak */
    free(p_int);

    return 0;
}</code></pre>
<blockquote>
<p>We stop here. Just note that depending on the allocation class, the memory area will differ.
An automatic allocation is done on the stack, a dymanic allocation on the heap and a static is done in the BSS or Data segment of your ELF binary.</p>
</blockquote>
<p>Dynamic allocation is really frequently used. PHP uses it as well. It is available through libc's <code>malloc()</code> and <code>free()</code> functions.
As PHP is a long-living process, often a daemon (FastCGI or into Apache using mod_php), any leak will hurt not only PHP, but the whole machine.
As PHP is designed into hundreds of thousands of lines of C code, generating a leak is really really easy. There must be a solution to prevent leaks, and PHP's got a layer that is dedicated in
dynamic memory management and leak tracking : Zend Memory Manager (ZendMM).</p>
<h2 id="dynamic-memory-allocation-problems-regarding-php">Dynamic memory allocation problems regarding PHP<a href="#dynamic-memory-allocation-problems-regarding-php" class="anchor">#</a></h2>
<h3 id="os-differences">OS differences<a href="#os-differences" class="anchor">#</a></h3>
<p>Libc's is a wrapper over the Kernel services, and the Kernel is really different according to OS. Windows and Linux for example, are really different. Unix flavours as well.</p>
<p><img alt="ZendMM" src="../../../img/php-memory/zendMM.png"></p>
<h3 id="heap-fragmentation">Heap fragmentation<a href="#heap-fragmentation" class="anchor">#</a></h3>
<p>To understand heap fragmentation, you should write your own memory manager in C. This is an exercize you usually have to deal with in your studies.
<code>malloc()</code> manages a heap that it cuts into blocs. When you free a bloc, you create a hole in the heap. As any bloc in the heap is managed into binary trees or linked lists, the more holes you
create, the more CPU cycles will be needed for the next <code>malloc()</code> call to succeed. It also happens that a call to <code>free()</code> triggers a heap compacting algorithm, which is usually very CPU intensive as well.
Those are well known problems, and any "serious" software have dealed with them by creating a (usually very complex and big) layer over malloc/free duo, and the program asks for dynamic memory
using this specific layer.</p>
<blockquote>
<p>As an example, you may read the <a href="http://apr.apache.org/docs/apr/0.9/group__apr__pools.html">Apache server's dynamic memory library</a>. Big projects such as Firefox or MySQL have even more complex and exciting layers.</p>
</blockquote>
<p>Zend Memory Manager is PHP's dynamic allocation layer. It's been designed to offer good performances to PHP, by managing an internal heap over the process heap.
For more information about malloc/free internals, you may start your readings by <a href="http://phrack.org/issues/57/9.html">Once uppon a free()</a> or <a href="http://www.gnu.org/software/libc/manual/html_node/Unconstrained-Allocation.html">the Glibc manual</a></p>
<h3 id="managing-memory-leaks">Managing memory leaks<a href="#managing-memory-leaks" class="anchor">#</a></h3>
<p>Ah... memory leaks... a whole story every programmer knows about. Fortunately, there exists tools to track them, and they work pretty nicely. valgrind, mtrace, ccmalloc, electric fence...
Let's see how valgrind does the job :</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define MYSTRING "Hello, world ; I'm gonna leak some memory"

int main(int argc, char *argv[])
{
    char *p_char = (char *)malloc(sizeof(MYSTRING));
    char string[] = MYSTRING;
    memcpy(p_char, string, sizeof(string));
    return 0;
}

$ valgrind --tool=memcheck --leak-check=full ./leak
==9488== Memcheck, a memory error detector
==9488== Copyright (C) 2002-2010, and GNU GPL'd, by Julian Seward et al.
==9488== Using Valgrind-3.6.0.SVN-Debian and LibVEX; rerun with -h for copyright info
==9488== Command: ./leak
==9488== 
==9488== 
==9488== HEAP SUMMARY:
==9488==     in use at exit: 42 bytes in 1 blocks
==9488==   total heap usage: 1 allocs, 0 frees, 42 bytes allocated
==9488== 
==9488== 42 bytes in 1 blocks are definitely lost in loss record 1 of 1
==9488==    at 0x4C2815C: malloc (vg_replace_malloc.c:236)
==9488==    by 0x4005DB: main (leak.c:8)
==9488== 
==9488== LEAK SUMMARY:
==9488==    definitely lost: 42 bytes in 1 blocks
==9488==    indirectly lost: 0 bytes in 0 blocks
==9488==      possibly lost: 0 bytes in 0 blocks
==9488==    still reachable: 0 bytes in 0 blocks
==9488==         suppressed: 0 bytes in 0 blocks
==9488== 
==9488== For counts of detected and suppressed errors, rerun with: -v
==9488== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 4 from 4)</code></pre>
<p>Valgrind is a very powerful tool. It tracks leaks, but also invalid accesses, which may be dangerous about program security (nul pointer dereference, write out of alloc'ed bounds, memory leaks, overlaping zones, etc...).</p>
<p>Whatever tool you use, the tool helps you track the problem but won't make it disappear magically. This is your work guy.
As the program gets bigger, it becomes more and more difficult to track the leaks. A solution is to rely on a layer that embeds some checks about leaks or security. Zend Memory Manger does that for PHP, and trully helps a lot designing extensions or patching PHP itself.</p>
<p>Here is a quick example of ZendMM usage :</p>
<pre><code>PHP_FUNCTION(make_leak)
{
    void *leak = emalloc(200); /* emalloc is ZendMM's "malloc" */
    RETURN_NULL(); /* return, forgeting to free the previously allocated buffer */
}

$&gt; php /tmp/leak_check.php

[Thu Apr  7 17:48:07 2011]  Script:  '/tmp/leak_check.php'
/usr/local/src/php/ext/leak/leak.c(172) :  Freeing 0x01DBB2E0 (200 bytes), script=/tmp/leak_check.php
=== Total 1 memory leaks detected ===</code></pre>
<p>You can easilly see the stderr output : it tells you're leaking some memory, and it tells you in which place in your code (in the example : leak.c line 172).
What you have to do is to use ZendMM specific alloc functions in place of the default libc's ones. Easy to do. ZendMM will then track any allocation you ask for, and checks that you effectively free them.
It will also implement guards (known as <em>canaries</em>) to inform you if you write past the allocated blocks, which is a very nice feature to count on as well because forgetting a +1 or -1 in an allocation is really frequent, particularly in PHP.</p>
<blockquote>
<p>Reminder : ZendMM only complains about leaks and overlaps if PHP's been built in debug mode (--enable-debug), so this is not the case for any "traditionnal" PHP build.</p>
</blockquote>
<h2 id="introduction-to-zend-memory-manager">Introduction to Zend Memory Manager<a href="#introduction-to-zend-memory-manager" class="anchor">#</a></h2>
<h3 id="goals">Goals<a href="#goals" class="anchor">#</a></h3>
<ul><li>Prevent heap fragmentation by reimplementing a custom heap onto the process' heap. Segmentation, pools and alignment features are in ;</li>
<li>scream at your face about memory leaks or overlaps, very usefull when designing PHP extensions ;</li>
<li>Automatically free leaked memory at request shutdown ;</li>
<li>Monitor and limit memory usage into all PHP (memory_limit) ;</li>
<li>Allow to choose the low level allocation stack (depends on OS) ;</li>
<li>Allow beeing disabled, so that any memory check tool like valgrind is not hindered by ZendMM.</li>
</ul><p>Zend Memory Manager appeared in PHP4 and has been fully redesigned in PHP5.2.</p>
<h3 id="configuration">Configuration<a href="#configuration" class="anchor">#</a></h3>
<p>Zend Memory Manager (ZendMM) is enabled by default, and can be disabled (it will still be here, but skirted). It will however change its behavior depending on your compilation options.
A debug PHP build will have a ZendMM telling you about leaks on stderr, if <em>report_memleaks=1</em> in php.ini.</p>
<p><img alt="ZendMM-phpinfo" src="../../../img/php-memory/zendMM-phpinfo.png"></p>
<p>Then comes four env variables to set up ZendMM at runtime : <strong>USE_ZEND_ALLOC</strong>, <strong>ZEND_MM_MEM_TYPE</strong>, <strong>ZEND_MM_SEG_SIZE</strong> and <strong>ZEND_MM_COMPACT</strong>.
If <strong>USE_ZEND_ALLOC</strong> is set to 0, ZendMM is diabled and any call to its functions will be proxied to the OS's low level call, usually malloc/free. <code>phpinfo()</code> will then tell you Zend Memory Manager is disabled.</p>
<p><strong>ZEND_MM_MEM_TYPE</strong> defines the low level implementation ZendMM should rely on. Default is "malloc", but you can choose between "mmap_anon" - "mmap_zero" - or "win32".</p>
<p><strong>ZEND_MM_SEG_SIZE</strong> defines the allocation step. Its like Kernel's PAGESIZE, the minimum allocation unit to use. Default is 256Kb which is a good value. More on that later.</p>
<pre><code>$ USE_ZEND_ALLOC=0 valgrind --tool=memcheck php /tmp/small.php 
==6861== Memcheck, a memory error detector
==6861== Copyright (C) 2002-2010, and GNU GPL'd, by Julian Seward et al.
==6861== Using Valgrind-3.6.0.SVN-Debian and LibVEX; rerun with -h for copyright info
==6861== Command: ./php /tmp/small.php
==6861== 

==6861== HEAP SUMMARY:
==6861==     in use at exit: 0 bytes in 0 blocks
==6861==   total heap usage: 9,697 allocs, 9,697 frees, 2,686,147 bytes allocated
==6861== 
==6861== All heap blocks were freed -- no leaks are possible
==6861== 
==6861== For counts of detected and suppressed errors, rerun with: -v
==6861== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 4 from 4)

$ valgrind --tool=memcheck ./php /tmp/small.php
==6866== Memcheck, a memory error detector
==6866== Copyright (C) 2002-2010, and GNU GPL'd, by Julian Seward et al.
==6866== Using Valgrind-3.6.0.SVN-Debian and LibVEX; rerun with -h for copyright info
==6866== Command: ./php /tmp/small.php
==6866== 

==6866== HEAP SUMMARY:
==6866==     in use at exit: 0 bytes in 0 blocks
==6866==   total heap usage: 7,854 allocs, 7,854 frees, 2,547,726 bytes allocated
==6866== 
==6866== All heap blocks were freed -- no leaks are possible
==6866== 
==6866== For counts of detected and suppressed errors, rerun with: -v
==6866== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 4 from 4)</code></pre>
<blockquote>
<p>Reminder : PHP memory consumption depends on the run script, and also on PHP extensions which can allocate many memory.</p>
<p>Note : PHP memory consumption is weaker when ZendMM is enabled, and you don't see it but can benchmark it : PHP is faster when ZendMM is enabled. This is obvious, as ZendMM has been designed to fit PHP's memory needs : it preallocates known-size blocs and manages internal lists about them more efficiently than malloc would do. It also prevents many <code>malloc()</code> calls, as the valgrind print above shows.</p>
</blockquote>
<pre><code>$&gt; ZEND_MM_SEG_SIZE=8k php /tmp/my_script.php</code></pre>
<p>Here, ZendMM will ask the underneath layer for 8Kb allocs.</p>
<p><strong>ZEND_MM_MEM_TYPE</strong> lets you choose the underneath layer to use. Libc's <code>malloc()</code> is used by default.</p>
<p><strong>ZEND_MM_COMPACT</strong> tells ZendMM the size from which it must compact the internal heap. This feature is not enabled under Unix OSes.</p>
<h2 id="how-does-zendmm-work">How does ZendMM work ?<a href="#how-does-zendmm-work" class="anchor">#</a></h2>
<p>ZendMM is an allocator, so its operation is close to any memory allocator. Here are its structures :</p>
<ul><li>zend_mm_heap : the heap ;</li>
<li>zend_mm_mem_handlers : the bottom allocators available handlers (malloc, mmap_anon, win32...) ;</li>
<li>zend_mm_segment : memory segments. Linked list ;</li>
<li>zend_mm_block / zend_mm_free_block : memory blocs (usefull blocs), pluggued into segments.</li>
</ul><p>I wont detail too much ZendMM as it may become very complex if you are not comfortable with memory allocators, and such details are useless here.</p>
<h3 id="noticeable-structures">Noticeable structures<a href="#noticeable-structures" class="anchor">#</a></h3>
<p>zend_mm_mem_handlers is the low-level allocator to be used by ZendMM, it is then full of function pointers. malloc-based allocator is defined into the <strong>ZEND_MM_MEM_MALLOC_DSC</strong> macro.</p>
<pre><code>typedef struct _zend_mm_mem_handlers {
    const char *name;
    zend_mm_storage* (*init)(void *params);
    void (*dtor)(zend_mm_storage *storage);
    void (*compact)(zend_mm_storage *storage);
    zend_mm_segment* (*_alloc)(zend_mm_storage *storage, size_t size);
    zend_mm_segment* (*_realloc)(zend_mm_storage *storage, zend_mm_segment *ptr, size_t size);
    void (*_free)(zend_mm_storage *storage, zend_mm_segment *ptr);
} zend_mm_mem_handlers;

#define ZEND_MM_MEM_MALLOC_DSC {"malloc", zend_mm_mem_dummy_init, zend_mm_mem_dummy_dtor, zend_mm_mem_dummy_compact, zend_mm_mem_malloc_alloc,
zend_mm_mem_malloc_realloc, zend_mm_mem_malloc_free}</code></pre>
<p>zend_mm_segment is a memory segment (the base unit ZendMM will use when allocating from the OS). It's size may be changed using the <strong>ZEND_MM_SEG_SIZE</strong> env. The allocator will use this size to allocate a buffer, place a zend_mm_segment as head and return the leaving buffer which will be itself cut into blocs linked with each other.</p>
<pre><code>typedef struct _zend_mm_segment {
    size_t    size;
    struct _zend_mm_segment *next_segment;
} zend_mm_segment;

typedef struct _zend_mm_free_block {
    zend_mm_block_info info;
#if ZEND_DEBUG
    unsigned int magic;
# ifdef ZTS
    THREAD_T thread_id;
# endif
#endif
    struct _zend_mm_free_block *prev_free_block;
    struct _zend_mm_free_block *next_free_block;

    struct _zend_mm_free_block **parent;
    struct _zend_mm_free_block *child[2];
} zend_mm_free_block;</code></pre>
<p>zend_mm_heap is the shared heap. It's shared as a global variable into PHP, but you will usually never use it directly (except if you design extensions that plays with PHP memory in any way).</p>
<pre><code>struct _zend_mm_heap {
    int                 use_zend_alloc;
    void               *(*_malloc)(size_t);
    void                (*_free)(void*);
    void               *(*_realloc)(void*, size_t);
    size_t              free_bitmap;
    size_t              large_free_bitmap;
    size_t              block_size;
    size_t              compact_size;
    zend_mm_segment    *segments_list;
    zend_mm_storage    *storage;
    size_t              real_size;
    size_t              real_peak;
    size_t              limit;
    size_t              size;
    size_t              peak;
    size_t              reserve_size;
    void               *reserve;
    int                 overflow;
    int                 internal;
#if ZEND_MM_CACHE
    unsigned int        cached;
    zend_mm_free_block *cache[ZEND_MM_NUM_BUCKETS];
#endif
    zend_mm_free_block *free_buckets[ZEND_MM_NUM_BUCKETS*2];
    zend_mm_free_block *large_free_buckets[ZEND_MM_NUM_BUCKETS];
    zend_mm_free_block *rest_buckets[2];
#if ZEND_MM_CACHE_STAT
    struct {
        int count;
        int max_count;
        int hit;
        int miss;
    } cache_stat[ZEND_MM_NUM_BUCKETS+1];
#endif
};</code></pre>
<p>As you can see, compiling PHP with the debug flag enables many things into those low level structures.</p>
<h3 id="published-functions">Published functions<a href="#published-functions" class="anchor">#</a></h3>
<p>ZendMM is mainly used when designing PHP internals (extensions or core development). For this goal, it publishes some functions the developer must use instead of traditionnal libc functions.
Those published functions are very intuitive and easy to use, let's have a look:</p>
<pre><code>void *emalloc(size_t size);
void *pemalloc(size_t size, char persistent)
void *ecalloc(size_t size);
void *pecmalloc(size_t size, char persistent)
void *erealloc(void *ptr, size_t size);
void *perealloc(void *ptr, size_t size, char persistent)
void *estrdup(void *ptr)
void *pestrdup(void *ptr, char persistent)    void *strdup(void *ptr)
void efree(void *ptr)
void pefree(void *ptr, char persistent)    void free(void *ptr)</code></pre>
<p>As you can see, they share the same API as malloc/free/strdup etc... from libc. A quick word on "p" functions. "p" stands for "persitent", this means that the allocation will persist through requests.
In reality, those "persitent" functions directly proxy to the bottom layer (malloc/free), one should use them for every allocation that is not request bound, meaning that ZendMM won't warn you about possible leaks for them, simply because they can't really leak and will anyway be cleaned when PHP shuts down.</p>
<h3 id="from-php-land">From PHP land<a href="#from-php-land" class="anchor">#</a></h3>
<p>PHP allows you, as a PHP developer, to interact with it. Functions <code>memory_get_usage()</code> and <code>memory_get_peak_usage()</code> are published, as well as the ini setting <em>memory_limit</em>.
As most of dynamic allocation request from PHP go through the ZendMM layer, it is very easy for it to count the number of bytes asked so far, and bail out in case of reaching a limit : the <em>memory_limit</em>.</p>
<pre><code>zend_mm_safe_error(heap, "Allowed memory size of %ld bytes exhausted (tried to allocate %ld bytes)", heap-&gt;limit, size);</code></pre>
<p>To know PHP dynamic memory usage at a given moment, <code>memory_get_usage()</code> may be used. This function returns the size used into the allocated segments. This means that it is less than the real usage of PHP.
To know the real usage, aka the memory to fit the segments in it, pass 1 to the function : <code>memory_get_usage(1)</code>;</p>
<pre><code>&lt;?php
ini_set('memory_limit', -1); // unlimited memory

function show_memory($real = false) {
    printf("%.2f Kb\n", memory_get_usage($real) / 1024);
}

show_memory();
show_memory(1);

$a = str_repeat('a', 1024*1024*10); // 10Mb

echo "\n";

show_memory();
show_memory(1);

$&gt; php /tmp/mem.php
621.62Kb
768.00 Kb

10861.83 Kb
11264.00 Kb</code></pre>
<p><code>memory_get_peak_usage()</code> returns the peak ZendMM recorded in its life.</p>
<blockquote>
<p>Important : Nothing forces the C developers to use ZendMM. Anyone developing an extension (for example) could absolutely not use ZendMM and rely directly on malloc/free, thus allocating dynamic memory that will not be seen by ZendMM and <code>memory_get_usage()</code>, <em>memory_limit</em> etc... Here, you may use your OS to monitor this. Obviously, C developers know that and heavily rely on ZendMM, but still.
Also, note that PHP's source code itself uses ZendMM, but sometimes, somewhere, no. Some parts of code use persistent allocs or directly malloc/free.</p>
<p>That's why <code>memory_get_usage()</code> give an average information, often accurate, but not 100% accurate on a byte-basis. Use your OS for that.</p>
</blockquote>
<h3 id="tuning">Tuning<a href="#tuning" class="anchor">#</a></h3>
<h4 id="zend-mm-seg-size-sizing-zendmm-heap-allocations">ZEND_MM_SEG_SIZE, sizing ZendMM heap allocations<a href="#zend-mm-seg-size-sizing-zendmm-heap-allocations" class="anchor">#</a></h4>
<p>To understand segments and why this is important, imagine a PHP with 256Kb segment size (default). If it has to consume say 320Kb, ZendMM will allocate onto its heap 2 segments, thus using from the OS 512Kb, filled at 320Kb. This is a cursor, and this is where ZendMM gives performances : it allocates more than what is really used, thus it allocates less often, it then prevents the process heap from fragmentation.</p>
<pre><code>// /tmp/mem.php is the code shown in the above example

$&gt; ZEND_MM_SEG_SIZE=1048576 php /tmp/mem.php 
625.67 Kb
1024.00 Kb

10865.88 Kb
12288.00 Kb</code></pre>
<p>It is clear here. PHP consumes 625.67Kb, ZendMM allocated 1Mb segments, so one segment to fit the usage. The real usage is then 1Mb, and the usage is only 625.67Kb.
We then create a 10Mb string, so the memory consumption raises to 10865.88Kb and the real reaches 12288Kb : 12 segments of 1Mb each (1024Kb).</p>
<blockquote>
<p>ZEND_MM_SEG_SIZE must obviously be power-of-two aligned</p>
</blockquote>
<pre><code>&lt;?php
ini_set('memory_limit', -1); // unlimited memory

function get_mem_stats() {
    printf("Memory usage %.2f Kb\n", memory_get_usage() / 1024);
    if ($segSize = getenv('ZEND_MM_SEG_SIZE') {
        printf("Heap segmentation : %d segments of %d bytes (%d Kb used)\n", memory_get_usage(1)/$segSize, $segSize, memory_get_usage(1)/1024);
    }
}

get_mem_stats();

$a = str_repeat('a', 1024*1024*10); // 10 Mb

echo "\n";

get_mem_stats();

$&gt; ZEND_MM_SEG_SIZE=2048 php /tmp/mem.php
Memory usage 630.97 Ko
Heap segmentation : 325 segments of 2048 bytes (650 Kb used)

Memory usage 10871.18 Ko
Heap segmentation : 5446 segments of 2048 bytes (10892 Kb used)</code></pre>
<p>We can then say that the more tiny the segments are, the more the heap close to real memory usage (economical) but the more often it has to create segments.
This is why, by default, the segment size is 256Kb. With such a value, ZendMM will have to allocate few segments to fit the needs, which are usually around 5Mb. Sure, a framework based app (much more greedy in memory) may benefit from a tunning of the allocator. Look at that :</p>
<pre><code>&lt;?php
get_mem_stats();

/* This is the date component from ZF1. This class is known beeing huge
    https://github.com/zendframework/zf1/blob/master/library/Zend/Date.php */
require 'Zend/Date.php';

echo "\n";
get_mem_stats();

$&gt; ZEND_MM_SEG_SIZE=2048 php /tmp/mem.php 
Memory usage 630.35 Ko
Heap segmentation : 325 segments of 2048 bytes (650 Kb used)

Memory usage 4994.70 Ko
Heap segmentation : 2687 segments of 2048 bytes (5374 Kb used)</code></pre>
<p>Yeah, we raise from 630Kb to about 5Mb just by making PHP parse the Zend/Date.php, which contains a huge class. We even did not make any use of this class, just parsed it.
Remember that in PHP objects are really tiny and very well designed to be thrifty, but all the weigth is passed back to the class. In PHP, a class is something consuming memory, a fortiori a big class.</p>
<p>To well tune segment size, you must know the average PHP memory consumption of your app, so that with well sized segments, the allocator won't create and free too many segments too often.
A bad thing for performance is having an application oscillate around a segment, forcing the ZendMM to call the underlying allocator.</p>
<p><img alt="memory_get_usage" src="../../../img/php-memory/mm.png"><img alt="memory_get_usage" src="../../../img/php-memory/mm2.png"></p>
<h4 id="zend-mm-mem-type-choosing-the-underlying-allocator">ZEND_MM_MEM_TYPE : choosing the underlying allocator<a href="#zend-mm-mem-type-choosing-the-underlying-allocator" class="anchor">#</a></h4>
<p>As we've seen so far, the underlying allocator ZendMM will rely on is configurable. By default, it is set to 'malloc' ('win32' under Windows).</p>
<pre><code>#define ZEND_MM_MEM_WIN32_DSC {"win32", zend_mm_mem_win32_init, zend_mm_mem_win32_dtor, zend_mm_mem_win32_compact, zend_mm_mem_win32_alloc,
 zend_mm_mem_win32_realloc, zend_mm_mem_win32_free}

#define ZEND_MM_MEM_MALLOC_DSC {"malloc", zend_mm_mem_dummy_init, zend_mm_mem_dummy_dtor, zend_mm_mem_dummy_compact, zend_mm_mem_malloc_alloc,
 zend_mm_mem_malloc_realloc, zend_mm_mem_malloc_free}</code></pre>
<p>You can choose also mmap_anon or mmap_zero. mmap_anon will create a new anonymous memory mapping in your process mapping table :</p>
<pre><code>zend_mm_segment *ret = (zend_mm_segment*)mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);</code></pre>
<p>mmap_zero is the same, but using /dev/zero descriptor (usually BSD based Unixes) :</p>
<pre><code>zend_mm_dev_zero_fd = open("/dev/zero", O_RDWR, S_IRUSR | S_IWUSR);
zend_mm_segment *ret = (zend_mm_segment*)mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE, zend_mm_dev_zero_fd, 0);</code></pre>
<p>Using mmap_anon or mmap_zero is better if you don't want to suffer from your libc's malloc overhead :</p>
<pre><code>ini_set('memory_limit', -1);

function heap() {
return shell_exec(sprintf('grep "VmData:" /proc/%s/status', getmypid()));
}

printf ("Original heap status: %s\n", heap());

$a = range(1, 1024*1024); /* A very big array */

printf("I'm now eating heap memory: %s\n", heap());
unset($a); /* Free the memory */
printf("Memory should now have been freed: %s\n", heap());</code></pre>
<p>This code gets information about the process heap usage using the VmData field provided by the Linux Kernel. Here is the output with malloc :</p>
<pre><code>&gt; php leak.php

Original heap status: VmData:         4504 kB
I'm now eating heap memory: VmData:    152232 kB
Memory should now have been freed: VmData:    143780 kB</code></pre>
<p>mmm, seems like there is something strange. Seems like memory is heavily leaking because it does not reach back its original value when I destroy the very big array that did ask for mush memory from the heap. What's happening ?</p>
<p>Let's launch this script again, but now choosing mmap_anon as underlying allocator for ZendMM :</p>
<pre><code>&gt;ZEND_MM_MEM_TYPE=mmap_anon php leak.php 

Original heap status: VmData:         4404 kB
I'm now eating heap memory: VmData:      152116 kB
Memory should now have been freed: VmData:      4916 kB</code></pre>
<p>Aha, seems much better. In this particular case, we've been hit by malloc implementation. When we freed the memory, ZendMM did call <code>free()</code>, but <code>free()</code> itself did not free the memory back to the OS, but prefered keeping the blocks in a heat area to serve them back later. This is good if you don't use an overlay, like ZendMM. But using ZendMM, which itself implements a heat zone an reusage of pointers, it is silly to suffer from libc's malloc implementation details (which may vary a lot depending on how <code>malloc()</code> has been compiled on your system, you should read your system manual to know about this).</p>
<p>So using mmap_anon, if you know what this is, ZendMM will call <code>munmap()</code>, which is a Kernel service (system call) which will mark the physical pages as freed, thus unpaging them from your process memory image : your memory consumption will then drop.</p>
<h2 id="a-quick-word-on-the-garbage-collector">A quick word on the Garbage Collector<a href="#a-quick-word-on-the-garbage-collector" class="anchor">#</a></h2>
<p>Just to be clear, because we tend to read so many bullshit on the Web about PHP, by people just telling things that are not true... Anyway, let me clarify. Zend Memory Manager has nothing to share with ZendGC. ZendGC, appeared in PHP 5.3, is about clearing circular references in PHP variables and that's absolutely all it does. It then acts on top of ZendMM, for PHP variables containing themselves (circular references). PHP has always freed back the memory when it has not used it anymore, and this is ZendMM role</p>
<p><img alt="ZendGC" src="../../../img/php-memory/zendgc.png"></p>
<h2 id="deeper-example">Deeper example<a href="#deeper-example" class="anchor">#</a></h2>
<p>We're gonna trace every dynamic memory allocation from a PHP process, just to have an idea of how PHP uses the heap memory. We're gonna use Valgrind-Massif for that.</p>
<p>Here is the very simple script we'll benchmark :</p>
<pre><code>&lt;?php
echo "hello world";</code></pre>
<p>With such a script, there is no chance we use lots of memory from PHP land, as echoing a tiny string is something trivial for memory usage</p>
<pre><code>&gt; valgrind --tool=massif --massif-out-file=massif.out --max-snapshots=1000 --stacks=yes php /tmp/void.php &amp;&amp; ms_print massif.out &gt; massif.txt

    MB
4.189^                                                                  #     
     |                                                                 @#@    
     |                                                               ::@#@:   
     |                                                              :::@#@@   
     |                                                             @:::@#@@@  
     |                                                            :@:::@#@@@  
     |                                                           @:@:::@#@@@  
     |                                                          @@:@:::@#@@@: 
     |                                                        ::@@:@:::@#@@@@ 
     |                                            @@@@@@:@@@@@@:@@:@:::@#@@@@ 
     |                                          @:@@@@@@:@@@@@@:@@:@:::@#@@@@ 
     |                                         @@:@@@@@@:@@@@@@:@@:@:::@#@@@@ 
     |                                        @@@:@@@@@@:@@@@@@:@@:@:::@#@@@@:
     |                                        @@@:@@@@@@:@@@@@@:@@:@:::@#@@@@:
     |                                   @:::@@@@:@@@@@@:@@@@@@:@@:@:::@#@@@@:
     |                                   @:::@@@@:@@@@@@:@@@@@@:@@:@:::@#@@@@:
     |                                   @:::@@@@:@@@@@@:@@@@@@:@@:@:::@#@@@@:
     |                                   @:::@@@@:@@@@@@:@@@@@@:@@:@:::@#@@@@:
     |                                   @:::@@@@:@@@@@@:@@@@@@:@@:@:::@#@@@@:
     |                                   @:::@@@@:@@@@@@:@@@@@@:@@:@:::@#@@@@:
   0 +-----------------------------------------------------------------------&gt;Mi
     0                                                                   27.69

Number of snapshots: 589
 Detailed snapshots: [14, 19, 24, 27, 40, 44, 52, 59, 71, 77, 81, 82, 95, 113, 117, 154, 170, 172, 188, 192, 218, 221, 264, 268, 270, 299, 307, 317, 323, 324, 325, 338, 343, 351, 361, 364, 375, 390, 396, 400, 403, 406, 414, 423, 438, 442, 443, 446, 458, 461, 462, 492, 498 (peak), 508, 518, 528, 538, 548, 558, 568, 578, 588]</code></pre>
<p>The max memory usage is (about) 4Mb, and 588 snapshots have been taken. Be warned that this represents the memory usage of my PHP, on my platform etc...
If you have another OS or architecture, the numbers will vary. Also, if you activate more or less PHP extensions, those numbers will vary as well.</p>
<pre><code>--------------------------------------------------------------------------------
  n        time(i)         total(B)   useful-heap(B) extra-heap(B)    stacks(B)
--------------------------------------------------------------------------------
265     14,029,321              640               37            19          584
266     14,097,959              848               37            19          792
267     14,152,209           10,064            3,841           751        5,472
268     14,194,235        1,336,904        1,328,911         1,913        6,080
99.40% (1,328,911B) (heap allocation functions) malloc/new/new[], --alloc-fns, etc.
-&gt;78.43% (1,048,576B) 0x83F90B: zend_interned_strings_init (zend_string.c:48)
| -&gt;78.43% (1,048,576B) 0x81E0AC: zend_startup (zend.c:744)
|   -&gt;78.43% (1,048,576B) 0x7BDA18: php_module_startup (main.c:2055)
|     -&gt;78.43% (1,048,576B) 0x8CFA9B: php_cli_startup (php_cli.c:417)
|       -&gt;78.43% (1,048,576B) 0x445AA6: main (php_cli.c:1358)
|         
-&gt;19.61% (262,144B) 0x7F75FB: _zend_mm_alloc_int (zend_alloc.c:1982)
| -&gt;19.61% (262,144B) 0x7F8750: zend_mm_startup_ex (zend_alloc.c:1126)
|   -&gt;19.61% (262,144B) 0x7F8888: zend_mm_startup (zend_alloc.c:1221)
|     -&gt;19.61% (262,144B) 0x7F9306: start_memory_manager (zend_alloc.c:2733)
|       -&gt;19.61% (262,144B) 0x81DD8A: zend_startup (zend.c:649)
|         -&gt;19.61% (262,144B) 0x7BDA18: php_module_startup (main.c:2055)
|           -&gt;19.61% (262,144B) 0x8CFA9B: php_cli_startup (php_cli.c:417)
|             -&gt;19.61% (262,144B) 0x445AA6: main (php_cli.c:1358)
|               
-&gt;01.36% (18,191B) in 20 places, all below massif's threshold (01.00%)</code></pre>
<p>At timeslot 268, we can notice that 1.3Mb have been allocated, of which <code>zend_interned_string_init()</code> uses 1Mb, and <code>_zend_mm_alloc_int()</code> uses 256Kb.
<code>zend_interned_string_init()</code> is the interned string buffer used for string interning. By default, <a href="http://lxr.php.net/xref/PHP_5_5/Zend/zend_string.c#43">it is 1Mb size</a> and can only be changed
at PHP compilation.
<code>_zend_mm_alloc_int()</code> allocated 256Kb, yes, this is our underlying allocator call, to allocate one segment of memory, the very first one (default is 256Kb), PHP is actually starting and we are very soon in that process at timeslot 268.
Let's keep going :</p>
<pre><code>--------------------------------------------------------------------------------
  n        time(i)         total(B)   useful-heap(B) extra-heap(B)    stacks(B)
--------------------------------------------------------------------------------
300     15,909,135        1,406,104        1,377,534        12,882       15,688
301     15,963,752        1,407,088        1,378,252        13,196       15,640
302     16,018,604        1,407,112        1,378,248        13,176       15,688
303     16,089,865        1,408,296        1,379,153        13,503       15,640
304     16,144,629        1,407,288        1,386,986        14,806        5,496
305     16,183,971        1,743,384        1,720,538        16,886        5,960
306     16,248,952        1,771,944        1,746,686        19,298        5,960
307     16,288,999        1,790,200        1,763,176        20,960        6,064
98.49% (1,763,176B) (heap allocation functions) malloc/new/new[], --alloc-fns, etc.
-&gt;58.57% (1,048,576B) 0x83F90B: zend_interned_strings_init (zend_string.c:48)
| -&gt;58.57% (1,048,576B) 0x81E0AC: zend_startup (zend.c:744)
|   -&gt;58.57% (1,048,576B) 0x7BDA18: php_module_startup (main.c:2055)
|     -&gt;58.57% (1,048,576B) 0x8CFA9B: php_cli_startup (php_cli.c:417)
|       -&gt;58.57% (1,048,576B) 0x445AA6: main (php_cli.c:1358)
|         
-&gt;17.88% (320,000B) 0x83D6F5: gc_init (zend_gc.c:124)
| -&gt;17.88% (320,000B) 0x81DA5F: OnUpdateGCEnabled (zend.c:81)
|   -&gt;17.88% (320,000B) 0x833883: zend_register_ini_entries (zend_ini.c:208)
|     -&gt;17.88% (320,000B) 0x7BDFC7: php_module_startup (main.c:2191)
|       -&gt;17.88% (320,000B) 0x8CFA9B: php_cli_startup (php_cli.c:417)
|         -&gt;17.88% (320,000B) 0x445AA6: main (php_cli.c:1358)
|           
-&gt;14.64% (262,144B) 0x7F75FB: _zend_mm_alloc_int (zend_alloc.c:1982)
| -&gt;14.64% (262,144B) 0x7F8750: zend_mm_startup_ex (zend_alloc.c:1126)
|   -&gt;14.64% (262,144B) 0x7F8888: zend_mm_startup (zend_alloc.c:1221)
|     -&gt;14.64% (262,144B) 0x7F9306: start_memory_manager (zend_alloc.c:2733)
|       -&gt;14.64% (262,144B) 0x81DD8A: zend_startup (zend.c:649)
|         -&gt;14.64% (262,144B) 0x7BDA18: php_module_startup (main.c:2055)
|           -&gt;14.64% (262,144B) 0x8CFA9B: php_cli_startup (php_cli.c:417)
|             -&gt;14.64% (262,144B) 0x445AA6: main (php_cli.c:1358)
|               
-&gt;03.43% (61,493B) in 42 places, all below massif's threshold (01.00%)
| 
-&gt;02.72% (48,640B) 0x82B9B2: _zend_hash_quick_add_or_update (zend_alloc.h:95)
| -&gt;02.52% (45,136B) 0x824F74: zend_register_functions (zend_API.c:2139)
| | -&gt;02.52% (45,136B) 0x8257C6: zend_register_module_ex (zend_API.c:1946)
| |   -&gt;01.79% (31,992B) 0x7BD8B3: php_register_extensions (main.c:1924)
| |   | -&gt;01.79% (31,992B) 0x7BE020: php_module_startup (main.c:2213)
| |   |   -&gt;01.79% (31,992B) 0x8CFA9B: php_cli_startup (php_cli.c:417)
| |   |     -&gt;01.79% (31,992B) 0x445AA6: main (php_cli.c:1358)
| |   |       
| |   -&gt;00.73% (13,144B) in 1+ places, all below ms_print's threshold (01.00%)
| |   
| -&gt;00.20% (3,504B) in 1+ places, all below ms_print's threshold (01.00%)</code></pre>
<p>Interesting. At timeslot 307, the snapshot starts showing the famous garbage collector impact. The circular garbage collector, to be able to run and do its job, needs not less than 320Kb of memory, which is not trivial.  <code>php_module_startup()</code> is the call to start every PHP extensions, which will start registering some classes, some functions etc... 48Kb so far</p>
<p>Etc... We could detail all the snapshot if you wish to have a full night reading this article ;-)</p>
<h2 id="end">End<a href="#end" class="anchor">#</a></h2>
<p>Zend Memory Manager (ZendMM) is a layer sitting on top of every (ideally) PHP heap allocation request. It has been designed to improve PHP performances, as PHP started becoming more and more complex and heap dependent. As you know now, you must compile a debug build of PHP to activate all the interesting parts of ZendMM.</p>
<p>In any case, PHP is build with ZendMM, so you benefit from it, from its very complex lines of codes, without having noticing it yet. Am I wrong ? Memory allocation in a programm can easilly turn to nightmare when you want to take in consideration all the parts : leaks, performance, thread safety, etc...</p>
<p>You can read many articles about allocators (low level ones) on the web, starting by <a href="http://locklessinc.com/benchmarks_allocator.shtml">Benchmarks of the Lockless Memory Allocator</a> or <a href="https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919">Scalable memory allocation using jemalloc</a>.</p>]]></content>
    </entry>
        <entry>
        <title>realpath_cache</title>
                <id>http://jpauli.github.io//2014/06/30/realpath-cache.html</id>
                <updated>2014-06-30T00:00:00+00:00</updated>
        <author>
            <name>Julien Pauli</name>
            <email>jpauli@php.net</email>
        </author>
        <link rel="alternate" type="text/html" href="http://jpauli.github.io//2014/06/30/realpath-cache.html"/>
        <content type="html" xml:lang="en"><![CDATA[<h2 id="introduction">Introduction<a href="#introduction" class="anchor">#</a></h2>
<p>Do you know those PHP functions, <code>realpath_cache_get()</code>, <code>realpath_cache_size()</code> ?
php.ini setting <em>realpath_cache</em> ?</p>
<p>Realpath cache is a really important concept to know about, especially when it comes to play with symbolic links, a situation
some meet when they deploy code.
This setting is about performance and IO reduction of your server. It has been introducted in PHP 5.1 , when frameworks started
to show in the PHP scene.</p>
<h3 id="a-recall-on-the-stat-system-call">A recall on the stat system call<a href="#a-recall-on-the-stat-system-call" class="anchor">#</a></h3>
<p>Ok, so, you know how your system works don't you ? Let me refresh your mind.
When one want to play with a <em>path</em>, the Kernel and the filesystem must know exactly what you talk about.
So, whenever you'll use a path to access a file (in the Unix meaning), you or your library or at least your Kernel will
have to resolve it.
Resolving a path is getting information about it : basically is it a file ? is it a directory or is it link ?</p>
<p>The way to do this is by asking the system about the file type, and, in case of a symbolic link, the final file target.
Whenever you use relative paths, such as <em>"../hey/./you/../foobar"</em>, you have to resolve them to full paths, and then resolve
those full paths to file entities (Unix sense of "file", so a true file of any type or a directory or a link).</p>
<p>Usually, for relative paths, you're gonna call the <a href="http://repo.or.cz/w/glibc.git/blob/edea402804bce917cfd7cd1af76212e6364c23db:/stdlib/canonicalize.c#l43">realpath() C function</a>. As you can see, <a href="http://repo.or.cz/w/glibc.git/blob/edea402804bce917cfd7cd1af76212e6364c23db:/stdlib/canonicalize.c#l161">it will lead to</a> a stat() system call.</p>
<p>Calling stat() is heavy, first because this is a system call, needing a Kernel trap and a context switch, and also because it most likely asks the disk about metadata.
The kernel source for stat() is at <a href="http://lxr.free-electrons.com/source/fs/stat.c#L190"><a href="http://lxr.free-electrons.com/source/fs/stat.c#L190">http://lxr.free-electrons.com/source/fs/stat.c#L190</a>. Not surprinsingly, it leads to a FileSystem call (inode-&gt;getattr()).
Usually, the kernel uses <a href="http://www.faqs.org/docs/linux_admin/buffer-cache.html">its buffer caches</a>, so the impact is really 
tiny, but the buffer cache on a very busy server may not contain your information, thus an IO, which is something you'd prefer
preventing as much as possible.</p>
<h2 id="what-php-does">What PHP does ?<a href="#what-php-does" class="anchor">#</a></h2>
<p>In PHP projects, we use many files. Nowadays, we use tons of classes, meaning tons of files (assuming one class per file).
So, autoload or not, we'll have to include those files, we'll have to read them, we'll have to ask the Kernel for stat informations about them.
That's why whenever you access a file in PHP, PHP tries to resolve the paths, resolve the links, get file informations; all this using the <code>stat()</code> system call, and then caches the result from this call into what is called the <strong>realpath cache</strong>.
Many other softwares use a stat cache, read their source code and you'll notice that ;-)</p>
<p>PHP will cache the result of the call, but only about the realpath. Any other information (owner, access rights, times ...) won't be
cached in this cache, but in the last file access cache.</p>
<p>As usual, we find the solution by having a look at the source code.
Whenever you access a file in PHP, <a href="http://lxr.php.net/xref/PHP_5_5/main/fopen_wrappers.c#473">php_resolve_path()</a> is used.
This function quickly calls <a href="http://lxr.php.net/xref/PHP_5_5/TSRM/tsrm_virtual_cwd.c#1925">tsrm_reapath()</a> which itself
calls <a href="http://lxr.php.net/xref/PHP_5_5/TSRM/tsrm_virtual_cwd.c#1151">virtual_file_ex()</a> and finally, <a href="http://lxr.php.net/xref/PHP_5_5/TSRM/tsrm_virtual_cwd.c#750">tsrm_realpath_r()</a>.</p>
<p>That's where things get interested. Functions like <a href="http://lxr.php.net/xref/PHP_5_5/TSRM/tsrm_virtual_cwd.c#830">realpath_cache_find()</a> are called, to lookup in a table if the stat informations have already been asked and cached for this
specific path.</p>
<p>A <a href="http://lxr.php.net/xref/PHP_5_5/TSRM/tsrm_virtual_cwd.h#211">realpath_cache_bucket</a> structure is used, which encapsulates many things :</p>
<pre><code>typedef struct _realpath_cache_bucket {
    unsigned long                  key;
    char                          *path;
    int                            path_len;
    char                          *realpath;
    int                            realpath_len;
    int                            is_dir;
    time_t                         expires;
#ifdef PHP_WIN32
    unsigned char                  is_rvalid;
    unsigned char                  is_readable;
    unsigned char                  is_wvalid;
    unsigned char                  is_writable;
#endif
    struct _realpath_cache_bucket *next;
} realpath_cache_bucket;</code></pre>
<p>If the bucket is not found, <a href="http://lxr.php.net/xref/PHP_5_5/TSRM/tsrm_virtual_cwd.h#139">php_sys_lstat()</a> will be called, this function is a proxy to <code>lstat()</code>. Then finally, the bucket is <a href="http://lxr.php.net/xref/PHP_5_5/TSRM/tsrm_virtual_cwd.c#1139">saved into the realpath cache</a>.</p>
<h2 id="php-settings-and-customization">PHP Settings and customization<a href="#php-settings-and-customization" class="anchor">#</a></h2>
<p>So, in PHP, you have several things to know about realpath cache.
First, the INI settings :</p>
<ul><li><a href="http://www.php.net/manual/en/ini.core.php#ini.realpath-cache-size">realpath_cache_size</a></li>
<li><a href="http://www.php.net/manual/en/ini.core.php#ini.realpath-cache-ttl">realpath_cache_ttl</a></li>
</ul><p>The manual warns you, if you use files that are not modified often (production servers), you should increase the
TTL.
Also, the default size is ridiculously weak. 16K are gonna be filled in one web request, assuming a framework usage like Symfony2.
Monitor your <code>realpath_cache_get()</code> return, you'll see that you hit the default 16K limit very soon. You'd better increase this value to something like 512K or even a megabyte.
If your realpath cache is full, there is no space for other entries, and then PHP will start abusing the <code>stat()</code> call because of cache
misses, stressing your Kernel even more.
The size is hard to compute theoretically. As we can see from the source code <a href="http://lxr.php.net/xref/PHP_5_5/TSRM/tsrm_virtual_cwd.c#643">in here</a>, each entry consume sizeof(realpath_cache_bucket) + the total number of characters of the resolved path + 1.
To me (LP64), sizeof(realpath_cache_bucket) = 56 bytes.</p>
<p>There is another trick. PHP resolves <strong>every paths it meets</strong> and splits every path part, resolving it.
I explain : if you access the file "/home/julien/www/fooproject/app/web/entry.php", PHP is gonna split this path into as many single units
as can fit. PHP is gonna resolve "/home", creating an entry for it into the cache. Then "/home/julien", then "/home/julien/www", etc..
Why this ? Well, first this is used to check access at every level of directory. Secondly, because many PHP users tend to build their
pathnames using string concatenations, PHP may have a chance to have checked simple parts, it will then know if the user may access
it or not, by asking the realpath cache for details. A cache hit is very cheap.
The source code of <a href="http://lxr.php.net/xref/PHP_5_5/TSRM/tsrm_virtual_cwd.c#750">tsrm_realpath_r()</a> details the procedure. this is a recursive function which gets called for every subpath entry, by default.</p>
<p>As you can see from the preceding paragraph, better have a cache !</p>
<p>This also shows that priming the cache by hitting few URLs from your website before opening it to public just after a new deploy is important here as well. This will not only prime your OPcode cache, but also the realpath cache, and your Kernel's page cache as well.</p>
<p>How to clear this cache ? The function is hidden in PHP. <code>realpath_cache_clear()</code> ? No, it doesn't exist, too bad :-)
Welcome <code>clearstatcache(true)</code>.
The true parameter is very important, it is named <em>$clear_realpath_cache</em>, so yes, obviously this is what we want to do.</p>
<h2 id="an-example">An example<a href="#an-example" class="anchor">#</a></h2>
<p>So here is an example.</p>
<pre><code>&lt;?php
$f = @file_get_contents('/tmp/bar.php');

echo "hello";

var_dump(realpath_cache_get());</code></pre>
<p>And here is the result :</p>
<pre><code>hello
array(5) {
  ["/home/julien.pauli/www/realpath_example.php"]=&gt;
  array(4) {
    ["key"]=&gt;
    float(1.7251638834424E+19)
    ["is_dir"]=&gt;
    bool(false)
    ["realpath"]=&gt;
    string(43) "/home/julien.pauli/www/realpath_example.php"
    ["expires"]=&gt;
    int(1404137986)
  }
  ["/home"]=&gt;
  array(4) {
    ["key"]=&gt;
    int(4353355791257440477)
    ["is_dir"]=&gt;
    bool(true)
    ["realpath"]=&gt;
    string(5) "/home"
    ["expires"]=&gt;
    int(1404137986)
  }
  ["/home/julien.pauli"]=&gt;
  array(4) {
    ["key"]=&gt;
    int(159282770203332178)
    ["is_dir"]=&gt;
    bool(true)
    ["realpath"]=&gt;
    string(18) "/home/julien.pauli"
    ["expires"]=&gt;
    int(1404137986)
  }
  ["/tmp"]=&gt;
  array(4) {
    ["key"]=&gt;
    float(1.6709564980243E+19)
    ["is_dir"]=&gt;
    bool(true)
    ["realpath"]=&gt;
    string(4) "/tmp"
    ["expires"]=&gt;
    int(1404137986)
  }
  ["/home/julien.pauli/www"]=&gt;
  array(4) {
    ["key"]=&gt;
    int(5178407966190555102)
    ["is_dir"]=&gt;
    bool(true)
    ["realpath"]=&gt;
    string(22) "/home/julien.pauli/www"
    ["expires"]=&gt;
    int(1404137986)</code></pre>
<p>What we can see, is that the full path to my example PHP file has been resolved, parts by parts.
Then, as <em>/tmp/bar.php</em> doesn't exist on my disk, this entry is obviously missing from the cache. However, we can see that PHP
resolved <em>/tmp</em>, so it now knows that it can access to /tmp, and any further resolution behind <em>/tmp</em> will be cheaper than the first one. </p>
<p>In the array returned by <code>realpath_cache_get()</code>, you can see important information, such as the expires timestamp.
This has been computed related to the <em>realpath_cache_ttl</em> setting, and the time the file has been accessed.
The key field is a hash of the resolved path, a variant of <a href="http://www.isthe.com/chongo/tech/comp/fnv/index.html">FNV hash</a> is used, this
is an internal information you shouldn't really need though (which may be integer or float, depending on your integer max size).</p>
<p>Now, if you'd call <code>clearstatcache(true)</code>, you'd reset this array and force PHP to <code>stat()</code> any new file access that was previously cached.</p>
<h2 id="the-opcode-caches-case">The OPcode caches case<a href="#the-opcode-caches-case" class="anchor">#</a></h2>
<p>Ready for another trick ?</p>
<p><strong>The realpath cache is process bound, and not shared into shared memory</strong></p>
<p>This means that anytime a cache entry expires, changes, or you empty the cache manually, you have to do this <strong>for every process in your pool</strong>.
This is usually why people fail at deploying code using OPCode caches solutions.
What people usually do when deploying, is changing a symlink from say /www/deploy-a to /www/deploy-b. What they usually forget is that opcode cache solutions (at least OPCache and APC) rely on the internal realpath cache from PHP.
So those opcode cache solutions won't notice the link change, and worse, they're gonna start noticing it little by little, as the realpath cache of every entry slowly expires. You know the result.</p>
<p>What I find beeing the best solution for deployment to prevent this uncool mechanism to happen, is to prepare a totally new PHP worker pool, and load balance your FastCgi Handler onto it, giving up with the old one when all old workers have finished.</p>
<p>This solution has many advantages : deploy A runs on memory pool A, and deploy B runs on memory pool B. End of story. We use memory image isolation to be absolutely sure that nothing will be shared between two deploys. Realpath cache, OPCode cache, etc... Everything is new.
FastCGI pools load balancing is possible at least with Lighttpd and Nginx :-)
I experienced this solution on production, and it is rock solid !</p>
<h1 id="end">End<a href="#end" class="anchor">#</a></h1>
<p>I've been asked to write some lines about realpath cache, probably because people had bad experience about it (I think at code deployment). Well, now you know how it works, why it's here and how and why to customize it. Did I forget anything ?</p>]]></content>
    </entry>
        <entry>
        <title>Reference mismatch in PHP function calls</title>
                <id>http://jpauli.github.io//2014/06/27/references-mismatch.html</id>
                <updated>2014-06-27T00:00:00+00:00</updated>
        <author>
            <name>Julien Pauli</name>
            <email>jpauli@php.net</email>
        </author>
        <link rel="alternate" type="text/html" href="http://jpauli.github.io//2014/06/27/references-mismatch.html"/>
        <content type="html" xml:lang="en"><![CDATA[<h2 id="a-recall-on-references">A recall on references<a href="#a-recall-on-references" class="anchor">#</a></h2>
<p>Once again, a coworker just pinged me about a huge memory usage in a Symfony2 based project.
What is bad about Symfony2 ecosystem, is that people tend to use everyone else's code, because it
seems to fit the <strong>usage</strong> need. This is not bad as-is, but wait, what about the performance of the piece of code you're gonna
heavily use ? Nowadays we want fast things, treating much more data than 10 years ago. I think it's time for programmers
who ignore performance to start learning about it.</p>
<p>Tons of PHP programmers are very nice technical guys
at creating functionnal code, and what they call "nice code", you know, with tons of objects and interfaces everywhere...
Fine, right ! But when it comes to write critical parts of code, where performance
trully matter, here suddenly, noone stays on the scene.
This is simply because unfortunately, many people just ignore how PHP works, let me refresh your mind ;-)</p>
<p>So, usually the main problem comes about memory usage. When I hear "my code is eating a gigabyte of
memory" , I just wonder if it has been designed to solve a problem as huge as its memory impact, or what ?
Seriously...</p>
<p>Memory usage, in PHP code, is not really hard to understand. PHP uses a reference counting mechanism
to track variable usages, just like any other language, or even the Kernel itself to manage lists of ... many things.
Reference counting is a really really common basic computer programming trick to save memory.</p>
<p>PHP is very well designed (I'm serious). It tries to do its best to save memory while running your code.
But should you know how reference counting works, you should know there are some situations you should avoid.</p>
<p>I'm gonna talk about reference mismatch in PHP function calls here.</p>
<h2 id="what-to-do-or-not-to-do">What to do or not to do ?<a href="#what-to-do-or-not-to-do" class="anchor">#</a></h2>
<p>What you should do is not use references (&amp;) , until you really master what you do.</p>
<p>More seriously, you should absolutely avoid <strong>reference mismatch</strong> when calling functions.
This is absolutely awfull for PHP, as any mismatch will make it duplicate the variable's memory.
If the variable is big (a very long string, a very complex array), then you're gonna start feeling it.
Worse, you're gonna complain against PHP, which has nothing to do with that. The problem is you, and the
code you are using.</p>
<h2 id="what-is-a-reference-mismatch">What is a reference mismatch ?<a href="#what-is-a-reference-mismatch" class="anchor">#</a></h2>
<p>A reference mismatch is when you call a function whose argument is expected to be passed by reference, and
you pass it a non-reference, or the opposite case.</p>
<p>Here are few examples :</p>
<pre><code>function foo($arg) { }

$a = "some var";
$b = &amp;$a; /* turn $a and $b into references */

foo($a); /* Reference mismatch */
foo($b); /* idem */</code></pre>
<p>!</p>
<pre><code>function foo(&amp;$arg) { } /* this function accepts an arg by reference */

$a = "some var";
$b = $a; /* increment $a refcount so that the content is bound to two different variables */

foo($a); /* reference mismatch */
foo($b); /* idem */</code></pre>
<p>So those both examples are things you should avoid. PHP will duplicate the memory of the argument before
passing it to the function (this is true for every argument).</p>
<h2 id="what-about-the-objects">What about the objects ?<a href="#what-about-the-objects" class="anchor">#</a></h2>
<p>Objects are a special case. Let me be really clear : PHP never, ever, ever, duplicates an object in memory
until you explicitely tells it to do so. And you only have one way to tell it to do so : the <strong>clone</strong> keyword.</p>
<p>This is really easy to demonstrate :</p>
<pre><code>function wow($arg) { var_dump('in function wow : ', memory_get_usage()); }

$big = range(1, 1024*1024); /* This consumes lots of memory */
$big2 = &amp;$big; /* $big and $big2 are both references to the same memory slot */

var_dump('original memory', memory_get_usage());
wow($big); /* $big is a reference, but the function accepts a non-reference : mismatch : duplicate memory */
var_dump('final memory', memory_get_usage());</code></pre>
<p>Result :</p>
<pre><code>string(15) "original memory"
int(151223288)
string(18) "in function wow : "
int(251886800)
string(12) "final memory"
int(151224488)</code></pre>
<p>Here, there is a classical reference mismatch on a non-object, so PHP will duplicate the passed argument,
which is a big array, so memory usage will raise significantely because PHP will duplicate (shallow copy) a very huge array
(and this burns many CPU cycles as well). Sure, if you don't use the variable elsewhere, when the function call
is finished, PHP destroys the function stack and cleans the dup memory. This, I repeat, if you don't use the argument
elsewhere. This is just a <a href="http://en.wikipedia.org/wiki/Reference_counting">refcount strategy</a></p>
<p>What about now using an object as passed arg ?</p>
<pre><code>function wow($arg) { var_dump('in function wow : ', memory_get_usage()); }

$big = range(1, 1024*1024); /* This consumes lots of memory */
$obj = new StdClass; /* Create a basic object */
$obj-&gt;big = $big; /* Turn this object into a BIG object by affecting one of its property to a huge var */
$obj2 = &amp;$obj; /* Turn $obj into a reference, by linking it by reference to another variable */

var_dump('original memory', memory_get_usage());
wow($obj);
var_dump('final memory', memory_get_usage());</code></pre>
<p>Result:</p>
<pre><code>string(15) "original memory"
int(151223928)
string(18) "in function wow : "
int(151224040)
string(15) "final memory"
int(151223992)</code></pre>
<p>This is a confirmation : PHP doesn't duplicate objects, because objects are internally reference counted themselves.
Here, PHP just adds one more reference to the object, something that can't be done for other types.
So yes : usually, using objects in PHP tend to decrease global memory usage, because if you were using references at some
places, for objects, PHP won't duplicate memory container.</p>
<p>This can easilly be spoted into PHP source code. Have a look at <a href="http://lxr.php.net/xref/PHP_5_5/Zend/zend_variables.c#106">zval_copy_ctor()</a>
,the function called when PHP duplicate a variable. We can see that in the special case of an object,
PHP just increments a counter, whereas for any other types, it really duplicates memory of the variable, which usually is
not a bad thing as you don't use very big memory variables everytime, but cases happen where you'll carry a big array (with
lots of slots) or a huge string (a result of a file_get_contents() for example).</p>
<p>If you were curious about the duplication of arguments when a function is called, you should have a look at the
<a href="http://lxr.php.net/xref/PHP_5_5/Zend/zend_vm_def.h#3182">ZEND_SEND_VAR</a> and <a href="http://lxr.php.net/xref/PHP_5_5/Zend/zend_vm_def.h#3145">ZEND_SEND_REF</a> opcodes.
The <a href="http://jpauli.github.io/2015/01/22/on-php-function-calls.html">On PHP function calls</a> article may also be worth reading if you get interested in such concepts.</p>
<h2 id="other-use-cases">Other use cases<a href="#other-use-cases" class="anchor">#</a></h2>
<p>Any mismatch in function calls is bad. This is true also for internal functions, and some of them accept
parameters by references, like <code>array_shift()</code> for example.
When you use such functions, make sure to respect the references as well.</p>
<p>But there are other tricks, which I consider not tricks, but just normal and logical behaviors.
The case of <code>func_get_args()</code> is interesting :</p>
<pre><code>function foo()
{
    var_dump('Before func_get_args()', memory_get_usage());
    $args = func_get_args();
    var_dump('After func_get_args()', memory_get_usage());
}

/*
An example output with some big input variables could be :

string(22) "Before func_get_args()"
int(151222120)
string(21) "After func_get_args()"
int(251885904)
*/</code></pre>
<p>What you should know is that <code>func_get_args()</code> will duplicate all the passed variables to the function, ignoring references or not.
It has to do so, because PHP has no way to know if you're gonna modify the variables later-on.
You all agree that modifying a variable in $args here should not modify the passed arg right ?
Example:</p>
<pre><code>function foo()
{
    $args = func_get_args();
    $args[0] = 'foo';
}

$str = 'bar';
foo($str);

// here, $str still owns the string 'bar', and not 'foo'</code></pre>
<p>So PHP has to duplicate every variable passed on the function stack, when you call <code>func_get_args()</code>.</p>
<h2 id="end">End<a href="#end" class="anchor">#</a></h2>
<p>Well, as I said, usually you don't carry over huge variables in PHP scripts. This is a pretty uncommon use case, however,
as time pass and we ask PHP to build more and more complex systems, managing more and more data; knowing what happens
behind the scene becomes more and more valuable.
Scripting languages show advantages and drawbacks, and one should really master them all before choosing the right language.
For example, I will not make PHP the first choice when talking about designing a language grammar parser.</p>]]></content>
    </entry>
    </feed>
